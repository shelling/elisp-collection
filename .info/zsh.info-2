This is zsh.info, produced by makeinfo version 4.11 from ./zsh.texi.

INFO-DIR-SECTION Utilities
START-INFO-DIR-ENTRY
* ZSH: (zsh).                     The Z Shell Manual.
END-INFO-DIR-ENTRY


File: zsh.info,  Node: Shell Builtin Commands,  Next: Zsh Line Editor,  Prev: Options,  Up: Top

17 Shell Builtin Commands
*************************


- SIMPLE COMMAND
     See *note Precommand Modifiers::.

. FILE [ ARG ... ]
     Read commands from FILE and execute them in the current shell
     environment.

     If FILE does not contain a slash, or if PATH_DIRS is set, the
     shell looks in the components of $path to find the directory
     containing FILE.  Files in the current directory are not read
     unless `.' appears somewhere in $path.  If a file named `FILE.zwc'
     is found, is newer than FILE, and is the compiled form (created
     with the zcompile builtin) of FILE, then commands are read from
     that file instead of FILE.

     If any arguments ARG are given, they become the positional
     parameters; the old positional parameters are restored when the
     FILE is done executing.  The exit status is the exit status of the
     last command executed.

: [ ARG ... ]
     This command does nothing, although normal argument expansions is
     performed which may have effects on shell parameters.  A zero exit
     status is returned.

alias [ {+|-}gmrsL ] [ NAME[=VALUE] ... ]
     For each NAME with a corresponding VALUE, define an alias with
     that value.  A trailing space in VALUE causes the next word to be
     checked for alias expansion.  If the -g flag is present, define a
     global alias; global aliases are expanded even if they do not
     occur in command position.

     If the -s flags is present, define a suffix alias: if the command
     word on a command line is in the form `TEXT.NAME', where TEXT is
     any non-empty string, it is replaced by the text `VALUE
     TEXT.NAME'.  Note that NAME is treated as a literal string, not a
     pattern.  A trailing space in VALUE is not special in this case.
     For example,


          alias -s ps=gv

     will cause the command `*.ps' to be expanded to `gv *.ps'.  As
     alias expansion is carried out earlier than globbing, the `*.ps'
     will then be expanded.  Suffix aliases constitute a different name
     space from other aliases (so in the above example it is still
     possible to create an alias for the command ps) and the two sets
     are never listed together.

     For each NAME with no VALUE, print the value of NAME, if any.
     With no arguments, print all currently defined aliases other than
     suffix aliases.  If the -m flag is given the arguments are taken
     as patterns (they should be quoted to preserve them from being
     interpreted as glob patterns), and the aliases matching these
     patterns are printed.  When printing aliases and one of the -g, -r
     or -s flags is present, restrict the printing to global, regular
     or suffix aliases, respectively; a regular alias is one which is
     neither a global nor a suffix alias.   Using `+' instead of `-',
     or ending the option list with a single `+', prevents the values
     of the aliases from being printed.

     If the -L flag is present, then print each alias in a manner
     suitable for putting in a startup script.  The exit status is
     nonzero if a NAME (with no VALUE) is given for which no alias has
     been defined.

     For more on aliases, include common problems, *note Aliasing::.

autoload [ {+|-}UXktz ] [ -w ] [ NAME ... ]
     Equivalent to functions -u, with the exception of -X/+X and -w.

     The flag -X may be used only inside a shell function, and may not
     be followed by a NAME.  It causes the calling function to be
     marked for autoloading and then immediately loaded and executed,
     with the current array of positional parameters as arguments.
     This replaces the previous definition of the function.  If no
     function definition is found, an error is printed and the function
     remains undefined and marked for autoloading.

     The flag +X attempts to load each NAME as an autoloaded function,
     but does _not_ execute it.  The exit status is zero (success) if
     the function was not previously defined _and_ a definition for it
     was found.  This does _not_ replace any existing definition of the
     function.  The exit status is nonzero (failure) if the function
     was already defined or when no definition was found.  In the
     latter case the function remains undefined and marked for
     autoloading.  If ksh-style autoloading is enabled, the function
     created will contain the contents of the file plus a call to the
     function itself appended to it, thus giving normal ksh autoloading
     behaviour on the first call to the function.

     With the -w flag, the NAMEs are taken as names of files compiled
     with the zcompile builtin, and all functions defined in them are
     marked for autoloading.

bg [ JOB ... ]
JOB ... &
     Put each specified JOB in the background, or the current job if
     none is specified.

bindkey
     See *note Zle Builtins::.

break [ N ]
     Exit from an enclosing for, while, until, select or repeat loop.
     If N is specified, then break N levels instead of just one.

builtin NAME [ ARGS ... ]
     Executes the builtin NAME, with the given ARGS.

bye
     Same as exit.

cap
     See *note The zsh/cap Module::.

cd [ -qsLP ] [ ARG ]
cd [ -qsLP ] OLD NEW
cd [ -qsLP ] {+|-}N
     Change the current directory.  In the first form, change the
     current directory to ARG, or to the value of $HOME if ARG is not
     specified.  If ARG is `-', change to the value of $OLDPWD, the
     previous directory.

     Otherwise, if ARG begins with a slash, attempt to change to the
     directory given by ARG.

     If ARG does not begin with a slash, the behaviour depends on
     whether the current directory `.' occurs in the list of
     directories contained in the shell parameter cdpath.  If it does
     not, first attempt to change to the directory ARG under the
     current directory, and if that fails but cdpath is set and
     contains at least one element attempt to change to the directory
     ARG under each component of cdpath in turn until successful.  If
     `.' occurs in cdpath, then cdpath is searched strictly in order so
     that `.' is only tried at the appropriate point.

     If no directory is found, the option CDABLE_VARS is set, and a
     parameter named ARG exists whose value begins with a slash, treat
     its value as the directory.  In that case, the parameter is added
     to the named directory hash table.

     The second form of cd substitutes the string NEW for the string
     OLD in the name of the current directory, and tries to change to
     this new directory.

     The third form of cd extracts an entry from the directory stack,
     and changes to that directory.  An argument of the form `+N'
     identifies a stack entry by counting from the left of the list
     shown by the dirs command, starting with zero.  An argument of the
     form `-N' counts from the right.  If the PUSHD_MINUS option is
     set, the meanings of `+' and `-' in this context are swapped.

     If the -q (quiet) option is specified, the hook function chpwd and
     the functions in the array chpwd_functions are not called.  This
     is useful for calls to cd that do not change the environment seen
     by an interactive user.

     If the -s option is specified, cd refuses to change the current
     directory if the given pathname contains symlinks.  If the -P
     option is given or the CHASE_LINKS option is set, symbolic links
     are resolved to their true values.  If the -L option is given
     symbolic links are retained in the directory (and not resolved)
     regardless of the state of the CHASE_LINKS option.

chdir
     Same as cd.

clone
     See *note The zsh/clone Module::.

command [ -pvV ] SIMPLE COMMAND
     The simple command argument is taken as an external command
     instead of a function or builtin and is executed. If the
     POSIX_BUILTINS option is set, builtins will also be executed but
     certain special properties of them are suppressed. The -p flag
     causes a default path to be searched instead of that in $path.
     With the -v flag, command is similar to whence and with -V, it is
     equivalent to whence -v.

     See also *note Precommand Modifiers::.

comparguments
     See *note The zsh/computil Module::.

compcall
     See *note The zsh/compctl Module::.

compctl
     See *note The zsh/compctl Module::.

compdescribe
     See *note The zsh/computil Module::.

compfiles
     See *note The zsh/computil Module::.

compgroups
     See *note The zsh/computil Module::.

compquote
     See *note The zsh/computil Module::.

comptags
     See *note The zsh/computil Module::.

comptry
     See *note The zsh/computil Module::.

compvalues
     See *note The zsh/computil Module::.

continue [ N ]
     Resume the next iteration of the enclosing for, while, until,
     select or repeat loop.  If N is specified, break out of N-1 loops
     and resume at the Nth enclosing loop.

declare
     Same as typeset.

dirs [ -c ] [ ARG ... ]
dirs [ -lpv ]
     With no arguments, print the contents of the directory stack.
     Directories are added to this stack with the pushd command, and
     removed with the cd or popd commands.  If arguments are specified,
     load them onto the directory stack, replacing anything that was
     there, and push the current directory onto the stack.


    -c
          clear the directory stack.

    -l
          print directory names in full instead of using of using ~
          expressions.

    -p
          print directory entries one per line.

    -v
          number the directories in the stack when printing.


     
disable [ -afmrs ] NAME ...
     Temporarily disable the NAMEd hash table elements.  The default is
     to disable builtin commands.  This allows you to use an external
     command with the same name as a builtin command.  The -a option
     causes disable to act on regular or global aliases.  The -s option
     causes disable to act on suffix aliases.  The -f option causes
     disable to act on shell functions.  The -r options causes disable
     to act on reserved words.  Without arguments all disabled hash
     table elements from the corresponding hash table are printed.
     With the -m flag the arguments are taken as patterns (which should
     be quoted to prevent them from undergoing filename expansion), and
     all hash table elements from the corresponding hash table matching
     these patterns are disabled.  Disabled objects can be enabled with
     the enable command.

disown [ JOB ... ]
JOB ... &|
JOB ... &!
     Remove the specified JOBs from the job table; the shell will no
     longer report their status, and will not complain if you try to
     exit an interactive shell with them running or stopped.  If no JOB
     is specified, disown the current job.

     If the JOBs are currently stopped and the AUTO_CONTINUE option is
     not set, a warning is printed containing information about how to
     make them running after they have been disowned.  If one of the
     latter two forms is used, the JOBs will automatically be made
     running, independent of the setting of the AUTO_CONTINUE option.

echo [ -neE ] [ ARG ... ]
     Write each ARG on the standard output, with a space separating
     each one.  If the -n flag is not present, print a newline at the
     end.  echo recognizes the following escape sequences:


    \a
          bell character

    \b
          backspace

    \c
          suppress final newline

    \e
          escape

    \f
          form feed

    \n
          linefeed (newline)

    \r
          carriage return

    \t
          horizontal tab

    \v
          vertical tab

    \\
          backslash

    \0NNN
          character code in octal

    \xNN
          character code in hexadecimal

    \uNNNN
          unicode character code in hexadecimal

    \UNNNNNNNN
          unicode character code in hexadecimal

     The -E flag, or the BSD_ECHO option, can be used to disable these
     escape sequences.  In the latter case, -e flag can be used to
     enable them.

echotc
     See *note The zsh/termcap Module::.

echoti
     See *note The zsh/terminfo Module::.

emulate [ -LR ] {zsh|sh|ksh|csh}
     Set up zsh options to emulate the specified shell as much as
     possible.  `csh' will never be fully emulated.  If the argument is
     not one of the shells listed above, zsh will be used as a default;
     more precisely, the tests performed on the argument are the same
     as those used to determine the emulation at startup based on the
     shell name, see *note Compatibility:: .  If the -R option is
     given, all options are reset to their default value corresponding
     to the specified emulation mode, except for certain options
     describing the interactive environment; otherwise, only those
     options likely to cause portability problems in scripts and
     functions are altered.  If the -L option is given, the options
     LOCAL_OPTIONS and LOCAL_TRAPS will be set as well, causing the
     effects of the emulate command and any setopt and trap commands to
     be local to the immediately surrounding shell function, if any;
     normally these options are turned off in all emulation modes
     except ksh.

enable [ -afmrs ] NAME ...
     Enable the NAMEd hash table elements, presumably disabled earlier
     with disable.  The default is to enable builtin commands.  The -a
     option causes enable to act on regular or global aliases.  The -s
     option causes enable to act on suffix aliases.  The -f option
     causes enable to act on shell functions.  The -r option causes
     enable to act on reserved words.  Without arguments all enabled
     hash table elements from the corresponding hash table are printed.
     With the -m flag the arguments are taken as patterns (should be
     quoted) and all hash table elements from the corresponding hash
     table matching these patterns are enabled.  Enabled objects can be
     disabled with the disable builtin command.

eval [ ARG ... ]
     Read the arguments as input to the shell and execute the resulting
     command(s) in the current shell process.  The return status is the
     same as if the commands had been executed directly by the shell;
     if there are no ARGS or they contain no commands (i.e. are an
     empty string or whitespace) the return status is zero.

exec [ -cl ] [ -a ARGV0 ] SIMPLE COMMAND
     Replace the current shell with an external command rather than
     forking.  With -c clear the environment; with -l prepend - to the
     argv[0] string of the command executed (to simulate a login shell);
     with -a ARGV0 set the argv[0] string of the command executed.  See
     *note Precommand Modifiers::.

exit [ N ]
     Exit the shell with the exit status specified by N; if none is
     specified, use the exit status from the last command executed.  An
     EOF condition will also cause the shell to exit, unless the
     IGNORE_EOF option is set.

export [ NAME[=VALUE] ... ]
     The specified NAMEs are marked for automatic export to the
     environment of subsequently executed commands.  Equivalent to
     typeset -gx.  If a parameter specified does not already exist, it
     is created in the global scope.

false [ ARG ... ]
     Do nothing and return an exit status of 1.

fc [ -e ENAME ] [ -nlrdDfEim ] [ OLD=NEW ... ] [ FIRST [ LAST ] ]
fc -p [ -a ] [ FILENAME [ HISTSIZE [ SAVEHISTSIZE ] ] ]
fc -P
fc -ARWI [ FILENAME ]
     Select a range of commands from FIRST to LAST from the history
     list.  The arguments FIRST and LAST may be specified as a number
     or as a string.  A negative number is used as an offset to the
     current history event number.  A string specifies the most recent
     event beginning with the given string.  All substitutions OLD=NEW,
     if any, are then performed on the commands.

     If the -l flag is given, the resulting commands are listed on
     standard output.  If the -m flag is also given the first argument
     is taken as a pattern (should be quoted) and only the history
     events matching this pattern will be shown.  Otherwise the editor
     program ENAME is invoked on a file containing these history
     events.  If ENAME is not given, the value of the parameter FCEDIT
     is used; if that is not set the value of the parameter EDITOR is
     used; if that is not set a builtin default, usually `vi' is used.
     If ENAME is `-', no editor is invoked.  When editing is complete,
     the edited command is executed.

     If FIRST is not specified, it will be set to -1 (the most recent
     event), or to -16 if the -l flag is given.  If LAST is not
     specified, it will be set to FIRST, or to -1 if the -l flag is
     given.

     The flag -r reverses the order of the commands and the flag -n
     suppresses command numbers when listing.  Also when listing, -d
     prints timestamps for each command, and -f prints full time-date
     stamps.  Adding the -E flag causes the dates to be printed as
     `DD.MM.YYYY', instead of the default `MM/DD/YYYY'.  Adding the -i
     flag causes the dates to be printed in ISO8601 `YYYY-MM-DD' format.
     With the -D flag, fc prints elapsed times.

     

     `fc -p' pushes the current history list onto a stack and switches
     to a new history list.  If the -a option is also specified, this
     history list will be automatically popped when the current
     function scope is exited, which is a much better solution than
     creating a trap function to call `fc -P' manually.  If no
     arguments are specified, the history list is left empty, $HISTFILE
     is unset, and $HISTSIZE & $SAVEHIST are set to their default
     values.  If one argument is given, $HISTFILE is set to that
     filename, $HISTSIZE & $SAVEHIST are left unchanged, and the history
     file is read in (if it exists) to initialize the new list.  If a
     second argument is specified, $HISTSIZE & $SAVEHIST are instead
     set to the single specified numeric value.  Finally, if a third
     argument is specified, $SAVEHIST is set to a separate value from
     $HISTSIZE.  You are free to change these environment values for
     the new history list however you desire in order to manipulate the
     new history list.

     `fc -P' pops the history list back to an older list saved by `fc
     -p'.  The current list is saved to its $HISTFILE before it is
     destroyed (assuming that $HISTFILE and $SAVEHIST are set
     appropriately, of course).  The values of $HISTFILE, $HISTSIZE,
     and $SAVEHIST are restored to the values they had when `fc -p' was
     called.  Note that this restoration can conflict with making these
     variables "local", so your best bet is to avoid local declarations
     for these variables in functions that use `fc -p'.  The one other
     guaranteed-safe combination is declaring these variables to be
     local at the top of your function and using the automatic option
     (-a) with `fc -p'.  Finally, note that it is legal to manually pop
     a push marked for automatic popping if you need to do so before the
     function exits.

     `fc -R' reads the history from the given file, `fc -W' writes the
     history out to the given file, and `fc -A' appends the history out
     to the given file.  If no filename is specified, the $HISTFILE is
     assumed.  If the -I option is added to -R, only those events that
     are not already contained within the internal history list are
     added.  If the -I option is added to -A or -W, only those events
     that are new since last incremental append/write to the history
     file are appended/written.  In any case, the created file will
     have no more than $SAVEHIST entries.

fg [ JOB ... ]
JOB ...
     Bring each specified JOB in turn to the foreground.  If no JOB is
     specified, resume the current job.

float [ {+|-}EFHghlprtux ] [ -LRZ [ N ]] [ NAME[=VALUE] ... ]
     Equivalent to typeset -E, except that options irrelevant to
     floating point numbers are not permitted.

functions [ {+|-}UXkmtuz ] [ NAME ... ]
functions -M MATHFN [ MIN [ MAX [ SHELLFN ] ] ]
functions -M [ -m PATTERN ... ]
functions +M [ -m ] MATHFN
     Equivalent to typeset -f, with the exception of the -M option.
     Use of the -M option may not be combined with any of the options
     handled by typeset -f.

     functions -M MATHFN defines MATHFN as the name of a mathematical
     function recognised in all forms of arithmetical expressions; see
     *note Arithmetic Evaluation::.  By default MATHFN may take any
     number of comma-separated arguments.  If MIN is given, it must
     have exactly MIN args; if MIN and MAX are both given, it must have
     at least MIN and and at most MAX args.  MAX may be -1 to indicate
     that there is no upper limit.

     By default the function is implemented by a shell function of the
     same name; if SHELLFN is specified it gives the name of the
     corresponding shell function while MATHFN remains the name used in
     arithmetical expressions.  The name of the function in $0 is
     MATHFN (not SHELLFN as would usually be the case), provided the
     option FUNCTION_ARGZERO is in effect.  The positional parameters
     in the shell function correspond to the arguments of the
     mathematical function call.  The result of the last arithmetical
     expression evaluated inside the shell function (even if it is a
     form that normally only returns a status) gives the result of the
     mathematical function.

     functions -M with no arguments lists all such user-defined
     functions in the same form as a definition.  With the additional
     option -m and a list of arguments, all functions whose MATHFN
     matches one of the pattern arguments are listed.

     function +M removes the list of mathematical functions; with the
     additional option -m the arguments are treated as patterns and all
     functions whose mathfn matches the pattern are removed.  Note that
     the shell function implementing the behaviour is not removed
     (regardless of whether its name coincides with mathfn).

     For example, the following prints the cube of 3:


          zmath_cube() { (( $1 * $1 * $1 )) }
          functions -M cube 1 1 zmath_cube
          print $(( cube(3) ))

getcap
     See *note The zsh/cap Module::.

getln [ -AclneE ] NAME ...
     Read the top value from the buffer stack and put it in the shell
     parameter name.  Equivalent to read -zr.

getopts OPTSTRING NAME [ ARG ... ]
     Checks the ARGs for legal options.  If the ARGs are omitted, use
     the positional parameters.  A valid option argument begins with a
     `+' or a `-'.  An argument not beginning with a `+' or a `-', or
     the argument `--', ends the options.  Note that a single `-' is
     not considered a valid option argument.  OPTSTRING contains the
     letters that getopts recognizes.  If a letter is followed by a
     `:', that option is expected to have an argument.  The options can
     be separated from the argument by blanks.

     Each time it is invoked, getopts places the option letter it finds
     in the shell parameter NAME, prepended with a `+' when ARG begins
     with a `+'.  The index of the next ARG is stored in OPTIND.  The
     option argument, if any, is stored in OPTARG.  

     The first option to be examined may be changed by explicitly
     assigning to OPTIND.  OPTIND has an initial value of 1, and is
     normally reset to 1 upon exit from a shell function.  OPTARG is
     not reset and retains its value from the most recent call to
     getopts.  If either of OPTIND or OPTARG is explicitly unset, it
     remains unset, and the index or option argument is not stored.
     The option itself is still stored in NAME in this case.

     A leading `:' in OPTSTRING causes getopts to store the letter of
     any invalid option in OPTARG, and to set NAME to `?' for an
     unknown option and to `:' when a required option is missing.
     Otherwise, getopts sets NAME to `?' and prints an error message
     when an option is invalid.  The exit status is nonzero when there
     are no more options.

hash [ -Ldfmrv ] [ NAME[=VALUE] ] ...
     hash can be used to directly modify the contents of the command
     hash table, and the named directory hash table.  Normally one would
     modify these tables by modifying one's PATH (for the command hash
     table) or by creating appropriate shell parameters (for the named
     directory hash table).  The choice of hash table to work on is
     determined by the -d option; without the option the command hash
     table is used, and with the option the named directory hash table
     is used.

     Given no arguments, and neither the -r or -f options, the selected
     hash table will be listed in full.

     The -r option causes the selected hash table to be emptied.  It
     will be subsequently rebuilt in the normal fashion.  The -f option
     causes the selected hash table to be fully rebuilt immediately.
     For the command hash table this hashes all the absolute
     directories in the PATH, and for the named directory hash table
     this adds all users' home directories.  These two options cannot
     be used with any arguments.

     The -m option causes the arguments to be taken as patterns (which
     should be quoted) and the elements of the hash table matching
     those patterns are printed.  This is the only way to display a
     limited selection of hash table elements.

     For each NAME with a corresponding VALUE, put `NAME' in the
     selected hash table, associating it with the pathname `VALUE'.  In
     the command hash table, this means that whenever `NAME' is used as
     a command argument, the shell will try to execute the file given
     by `VALUE'.  In the named directory hash table, this means that
     `VALUE' may be referred to as `~NAME'.

     For each NAME with no corresponding VALUE, attempt to add NAME to
     the hash table, checking what the appropriate value is in the
     normal manner for that hash table.  If an appropriate value can't
     be found, then the hash table will be unchanged.

     The -v option causes hash table entries to be listed as they are
     added by explicit specification.  If has no effect if used with -f.

     If the -L flag is present, then each hash table entry is printed in
     the form of a call to hash.

history
     Same as fc -l.

integer [ {+|-}Hghilprtux ] [ -LRZ [ N ]] [ NAME[=VALUE] ... ]
     Equivalent to typeset -i, except that options irrelevant to
     integers are not permitted.

jobs [ -dlprs ] [ JOB ... ]
jobs -Z STRING
     Lists information about each given job, or all jobs if JOB is
     omitted.  The -l flag lists process IDs, and the -p flag lists
     process groups.  If the -r flag is specified only running jobs
     will be listed and if the -s flag is given only stopped jobs are
     shown.  If the -d flag is given, the directory from which the job
     was started (which may not be the current directory of the job)
     will also be shown.

     The -Z option replaces the shell's argument and environment space
     with the given string, truncated if necessary to fit.  This will
     normally be visible in ps (man page ps(1)) listings.  This feature
     is typically used by daemons, to indicate their state.

kill [ -s SIGNAL_NAME | -n SIGNAL_NUMBER | -SIG ] JOB ...
kill -l [ SIG ... ]
     Sends either SIGTERM or the specified signal to the given jobs or
     processes.  Signals are given by number or by names, with or
     without the `SIG' prefix.  If the signal being sent is not `KILL'
     or `CONT', then the job will be sent a `CONT' signal if it is
     stopped.  The argument JOB can be the process ID of a job not in
     the job list.  In the second form, kill -l, if SIG is not
     specified the signal names are listed.  Otherwise, for each SIG
     that is a name, the corresponding signal number is listed.  For
     each SIG that is a signal number or a number representing the exit
     status of a process which was terminated or stopped by a signal
     the name of the signal is printed.

     On some systems, alternative signal names are allowed for a few
     signals.  Typical examples are SIGCHLD and SIGCLD or SIGPOLL and
     SIGIO, assuming they correspond to the same signal number.  kill
     -l will only list the preferred form, however kill -l ALT will
     show if the alternative form corresponds to a signal number.  For
     example, under Linux kill -l IO and kill -l POLL both output 29,
     hence kill -IO and kill -POLL have the same effect.

     Many systems will allow process IDs to be negative to kill a
     process group or zero to kill the current process group.

let ARG ...
     Evaluate each ARG as an arithmetic expression.  See *note
     Arithmetic Evaluation:: for a description of arithmetic
     expressions.  The exit status is 0 if the value of the last
     expression is nonzero, 1 if it is zero, and 2 if an error occurred.

limit [ -hs ] [ RESOURCE [ LIMIT ] ] ...
     Set or display resource limits.  Unless the -s flag is given, the
     limit applies only the children of the shell.  If -s is given
     without other arguments, the resource limits of the current shell
     is set to the previously set resource limits of the children.

     If LIMIT is not specified, print the current limit placed on
     RESOURCE, otherwise set the limit to the specified value.  If the
     -h flag is given, use hard limits instead of soft limits.  If no
     RESOURCE is given, print all limits.

     When looping over multiple resources, the shell will abort
     immediately if it detects a badly formed argument.  However, if it
     fails to set a limit for some other reason it will continue trying
     to set the remaining limits.

     RESOURCE can be one of:


    addressspace
          Maximum amount of address space used.

    aiomemorylocked
          Maximum amount of memory locked in RAM for AIO operations.

    aiooperations
          Maximum number of AIO operations.

    cachedthreads
          Maximum number of cached threads.

    coredumpsize
          Maximum size of a core dump.

    cputime
          Maximum CPU seconds per process.

    datasize
          Maximum data size (including stack) for each process.

    descriptors
          Maximum value for a file descriptor.

    filesize
          Largest single file allowed.

    maxproc
          Maximum number of processes.

    maxpthreads
          Maximum number of threads per process.

    memorylocked
          Maximum amount of memory locked in RAM.

    memoryuse
          Maximum resident set size.

    msgqueue
          Maximum number of bytes in POSIX message queues.

    resident
          Maximum resident set size.

    sigpending
          Maximum number of pending signals.

    sockbufsize
          Maximum size of all socket buffers.

    stacksize
          Maximum stack size for each process.

    vmemorysize
          Maximum amount of virtual memory.

     Which of these resource limits are available depends on the system.
     RESOURCE can be abbreviated to any unambiguous prefix.  It can
     also be an integer, which corresponds to the integer defined for
     the resource by the operating system.

     If argument corresponds to a number which is out of the range of
     the resources configured into the shell, the shell will try to
     read or write the limit anyway, and will report an error if this
     fails.  As the shell does not store such resources internally, an
     attempt to set the limit will fail unless the -s option is present.

     LIMIT is a number, with an optional scaling factor, as follows:


    Nh
          hours

    Nk
          kilobytes (default)

    Nm
          megabytes or minutes

    [MM:]SS
          minutes and seconds

local [ {+|-}AEFHUahlprtux ] [ -LRZi [ N ]] [ NAME[=VALUE] ] ...
     Same as typeset, except that the options -g, and -f are not
     permitted.  In this case the -x option does not force the use of
     -g, i.e. exported variables will be local to functions.

log
     List all users currently logged in who are affected by the current
     setting of the watch parameter.

logout [ N ]
     Same as exit, except that it only works in a login shell.

noglob SIMPLE COMMAND
     See *note Precommand Modifiers::.

popd [ [-q] {+|-}N ]
     Remove an entry from the directory stack, and perform a cd to the
     new top directory.  With no argument, the current top entry is
     removed.  An argument of the form `+N' identifies a stack entry by
     counting from the left of the list shown by the dirs command,
     starting with zero.  An argument of the form -n counts from the
     right.  If the PUSHD_MINUS option is set, the meanings of `+' and
     `-' in this context are swapped.

     If the -q (quiet) option is specified, the hook function chpwd and
     the functions in the array $chpwd_functions are not called, and
     the new directory stack is not printed.  This is useful for calls
     to popd that do not change the environment seen by an interactive
     user.

print [ -abcDilmnNoOpPrsz ] [ -u N ] [ -f FORMAT ] [ -C COLS ]
[ -R [ -en ]] [ ARG ... ]
     With the `-f' option the arguments are printed as described by
     printf.  With no flags or with the flag `-', the arguments are
     printed on the standard output as described by echo, with the
     following differences: the escape sequence `\M-X' metafies the
     character X (sets the highest bit), `\C-X' produces a control
     character (`\C-@' and `\C-?' give the characters NUL and delete),
     and `\E' is a synonym for `\e'.  Finally, if not in an escape
     sequence, `\' escapes the following character and is not printed.


    -a
          Print arguments with the column incrementing first.  Only
          useful with the -c and -C options.

    -b
          Recognize all the escape sequences defined for the bindkey
          command, see *note Zle Builtins::.

    -c
          Print the arguments in columns.  Unless -a is also given,
          arguments are printed with the row incrementing first.

    -C COLS
          Print the arguments in COLS columns.  Unless -a is also given,
          arguments are printed with the row incrementing first.

    -D
          Treat the arguments as directory names, replacing prefixes
          with ~ expressions, as appropriate.

    -i
          If given together with -o or -O, sorting is performed
          case-independently.

    -l
          Print the arguments separated by newlines instead of spaces.

    -m
          Take the first argument as a pattern (should be quoted), and
          remove it from the argument list together with subsequent
          arguments that do not match this pattern.

    -n
          Do not add a newline to the output.

    -N
          Print the arguments separated and terminated by nulls.

    -o
          Print the arguments sorted in ascending order.

    -O
          Print the arguments sorted in descending order.

    -p
          Print the arguments to the input of the coprocess.

    -P
          Perform prompt expansion (see *note Prompt Expansion::).

    -r
          Ignore the escape conventions of echo.

    -R
          Emulate the BSD echo command, which does not process escape
          sequences unless the -e flag is given.  The -n flag
          suppresses the trailing newline.  Only the -e and -n flags
          are recognized after -R; all other arguments and options are
          printed.

    -s
          Place the results in the history list instead of on the
          standard output.

    -u N
          Print the arguments to file descriptor N.

    -z
          Push the arguments onto the editing buffer stack, separated
          by spaces.


     If any of `-m', `-o' or `-O' are used in combination with `-f' and
     there are no arguments (after the removal process in the case of
     `-m') then nothing is printed.

printf FORMAT [ ARG ... ]
     Print the arguments according to the format specification.
     Formatting rules are the same as used in C. The same escape
     sequences as for echo are recognised in the format. All C
     conversion specifications ending in one of csdiouxXeEfgGn are
     handled. In addition to this, `%b' can be used instead of `%s' to
     cause escape sequences in the argument to be recognised and `%q'
     can be used to quote the argument in such a way that allows it to
     be reused as shell input. With the numeric format specifiers, if
     the corresponding argument starts with a quote character, the
     numeric value of the following character is used as the number to
     print otherwise the argument is evaluated as an arithmetic
     expression. See *note Arithmetic Evaluation:: for a description of
     arithmetic expressions. With `%n', the corresponding argument is
     taken as an identifier which is created as an integer parameter.

     Normally, conversion specifications are applied to each argument
     in order but they can explicitly specify the Nth argument is to be
     used by replacing `%' by `%N$' and `*' by `*N$'.  It is
     recommended that you do not mix references of this explicit style
     with the normal style and the handling of such mixed styles may be
     subject to future change.

     If arguments remain unused after formatting, the format string is
     reused until all arguments have been consumed. With the print
     builtin, this can be suppressed by using the -r option. If more
     arguments are required by the format than have been specified, the
     behaviour is as if zero or an empty string had been specified as
     the argument.

pushd [ -qsLP ] [ ARG ]
pushd [ -qsLP ] OLD NEW
pushd [ -qsLP ] {+|-}N
     Change the current directory, and push the old current directory
     onto the directory stack.  In the first form, change the current
     directory to ARG.  If ARG is not specified, change to the second
     directory on the stack (that is, exchange the top two entries), or
     change to $HOME if the PUSHD_TO_HOME option is set or if there is
     only one entry on the stack.  Otherwise, ARG is interpreted as it
     would be by cd.  The meaning of OLD and NEW in the second form is
     also the same as for cd.

     The third form of pushd changes directory by rotating the
     directory list.  An argument of the form `+N' identifies a stack
     entry by counting from the left of the list shown by the dirs
     command, starting with zero.  An argument of the form `-N' counts
     from the right.  If the PUSHD_MINUS option is set, the meanings of
     `+' and `-' in this context are swapped.

     If the -q (quiet) option is specified, the hook function chpwd and
     the functions in the array $chpwd_functions are not called, and
     the new directory stack is not printed.  This is useful for calls
     to pushd that do not change the environment seen by an interactive
     user.

     If the option -q is not specified and the shell option PUSHD_SILENT
     is not set, the directory stack will be printed after a pushd is
     performed.

     The options -s, -L and -P have the same meanings as for the cd
     builtin.

pushln [ ARG ... ]
     Equivalent to print -nz.

pwd [ -rLP ]
     Print the absolute pathname of the current working directory.  If
     the -r or the -P flag is specified, or the CHASE_LINKS option is
     set and the -L flag is not given, the printed path will not
     contain symbolic links.

r
     Same as fc -e -.

read [ -rszpqAclneE ] [ -t [ NUM ] ] [ -k [ NUM ] ] [ -d DELIM ] [ -u N ] [ NAME[?PROMPT] ] [ NAME ...  ]
     Read one line and break it into fields using the characters in
     $IFS as separators, except as noted below.  The first field is
     assigned to the first NAME, the second field to the second NAME,
     etc., with leftover fields assigned to the last NAME.  If NAME is
     omitted then REPLY is used for scalars and reply for arrays.


    -r
          Raw mode: a `\' at the end of a line does not signify line
          continuation and backslashes in the line don't quote the
          following character and are not removed.

    -s
          Don't echo back characters if reading from the terminal.
          Currently does not work with the -q option.

    -q
          Read only one character from the terminal and set NAME to `y'
          if this character was `y' or `Y' and to `n' otherwise.  With
          this flag set the return status is zero only if the character
          was `y' or `Y'.  Note that this always reads from the
          terminal, even if used with the -p or -u or -z flags or with
          redirected input.  This option may also be used within zle
          widgets.

    -k [ NUM ]
          Read only one (or NUM) characters.  All are assigned to the
          first NAME, without word splitting.  This flag is ignored
          when -q is present.  Input is read from the terminal unless
          one of -u or -p is present.  This option may also be used
          within zle widgets.

          Note that despite the mnemonic `key' this option does read
          full characters, which may consist of multiple bytes if the
          option MULTIBYTE is set.

    -z
          Read one entry from the editor buffer stack and assign it to
          the first NAME, without word splitting.  Text is pushed onto
          the stack with `print -z' or with push-line from the line
          editor (see *note Zsh Line Editor::).  This flag is ignored
          when the -k or -q flags are present.

    -e
    -E
          The input read is printed (echoed) to the standard output.
          If the -e flag is used, no input is assigned to the
          parameters.

    -A
          The first NAME is taken as the name of an array and all words
          are assigned to it.

    -c
    -l
          These flags are allowed only if called inside a function used
          for completion (specified with the -K flag to compctl).  If
          the -c flag is given, the words of the current command are
          read. If the -l flag is given, the whole line is assigned as
          a scalar.  If both flags are present, -l is used and -c is
          ignored.

    -n
          Together with -c, the number of the word the cursor is on is
          read.  With -l, the index of the character the cursor is on is
          read.  Note that the command name is word number 1, not word
          0, and that when the cursor is at the end of the line, its
          character index is the length of the line plus one.

    -u N
          Input is read from file descriptor N.

    -p
          Input is read from the coprocess.

    -d DELIM
          Input is terminated by the first character of DELIM instead of
          by newline.

    -t [ NUM ]
          Test if input is available before attempting to read.  If NUM
          is present, it must begin with a digit and will be evaluated
          to give a number of seconds, which may be a floating point
          number; in this case the read times out if input is not
          available within this time.  If NUM is not present, it is
          taken to be zero, so that read returns immediately if no
          input is available.  If no input is available, return status
          1 and do not set any variables.

          This option is not available when reading from the editor
          buffer with -z, when called from within completion with -c or
          -l, with -q which clears the input queue before reading, or
          within zle where other mechanisms should be used to test for
          input.

          Note that read does not attempt to alter the input processing
          mode.  The default mode is canonical input, in which an
          entire line is read at a time, so usually `read -t' will not
          read anything until an entire line has been typed.  However,
          when reading from the terminal with -k input is processed one
          key at a time; in this case, only availability of the first
          character is tested, so that e.g. `read -t -k 2' can still
          block on the second character.  Use two instances of `read -t
          -k' if this is not what is wanted.

     If the first argument contains a `?', the remainder of this word
     is used as a PROMPT on standard error when the shell is
     interactive.

     The value (exit status) of read is 1 when an end-of-file is
     encountered, or when -c or -l is present and the command is not
     called from a compctl function, or as described for -q.  Otherwise
     the value is 0.

     The behavior of some combinations of the -k, -p, -q, -u and -z
     flags is undefined.  Presently -q cancels all the others, -p
     cancels -u, -k cancels -z, and otherwise -z cancels both -p and -u.

     The -c or -l flags cancel any and all of -kpquz.

readonly
     Same as typeset -r.

rehash
     Same as hash -r.

return [ N ]
     Causes a shell function or . script to return to the invoking
     script with the return status specified by N.  If N is omitted,
     the return status is that of the last command executed.

     If return was executed from a trap in a TRAPNAL function, the
     effect is different for zero and non-zero return status.  With zero
     status (or after an implicit return at the end of the trap), the
     shell will return to whatever it was previously processing; with a
     non-zero status, the shell will behave as interrupted except that
     the return status of the trap is retained.  Note that the numeric
     value of the signal which caused the trap is passed as the first
     argument, so the statement `return $((128+$1))' will return the
     same status as if the signal had not been trapped.

sched
     See *note The zsh/sched Module::.

set [ {+|-}OPTIONS | {+|-}o [ OPTION_NAME ] ] ... [ {+|-}A [ NAME ] ] [ ARG ... ]
     Set the options for the shell and/or set the positional
     parameters, or declare and set an array.  If the -s option is
     given, it causes the specified arguments to be sorted before
     assigning them to the positional parameters (or to the array NAME
     if -A is used).  With +s sort arguments in descending order.  For
     the meaning of the other flags, see *note Options::.  Flags may be
     specified by name using the -o option. If no option name is
     supplied with -o, the current option states are printed:  see the
     description of setopt below for more information on the format.
     With +o they are printed in a form that can be used as input to
     the shell.

     If the -A flag is specified, NAME is set to an array containing
     the given ARGs; if no NAME is specified, all arrays are printed
     together with their values.

     If +A is used and NAME is an array, the given arguments will
     replace the initial elements of that array; if no NAME is
     specified, all arrays are printed without their values.

     The behaviour of arguments after -A NAME or +A NAME depends on
     whether the option KSH_ARRAYS is set.  If it is not set, all
     arguments following NAME are treated as values for the array,
     regardless of their form.  If the option is set, normal option
     processing continues at that point; only regular arguments are
     treated as values for the array.  This means that


          set -A array -x -- foo

     sets array to `-x -- foo' if KSH_ARRAYS is not set, but sets the
     array to foo and turns on the option `-x' if it is set.

     If the -A flag is not present, but there are arguments beyond the
     options, the positional parameters are set.  If the option list
     (if any) is terminated by `--', and there are no further
     arguments, the positional parameters will be unset.

     If no arguments and no `--' are given, then the names and values of
     all parameters are printed on the standard output.  If the only
     argument is `+', the names of all parameters are printed.

     For historical reasons, `set -' is treated as `set +xv' and `set -
     ARGS' as `set +xv - ARGS' when in any other emulation mode than
     zsh's native mode.

setcap
     See *note The zsh/cap Module::.

setopt [ {+|-}OPTIONS | {+|-}o OPTION_NAME ] [ NAME ... ]
     Set the options for the shell.  All options specified either with
     flags or by name are set.

     If no arguments are supplied, the names of all options currently
     set are printed.  The form is chosen so as to minimize the
     differences from the default options for the current emulation
     (the default emulation being native zsh, shown as <Z> in *note
     Description of Options::).  Options that are on by default for the
     emulation are shown with the prefix no only if they are off, while
     other options are shown without the prefix no and only if they are
     on.  In addition to options changed from the default state by the
     user, any options activated automatically by the shell (for
     example, SHIN_STDIN or INTERACTIVE) will be shown in the list.
     The format is further modified by the option KSH_OPTION_PRINT,
     however the rationale for choosing options with or without the no
     prefix remains the same in this case.

     If the -m flag is given the arguments are taken as patterns (which
     should be quoted to protect them from filename expansion), and all
     options with names matching these patterns are set.

shift [ N ] [ NAME ... ]
     The positional parameters ${N+1} ... are renamed to $1 ..., where
     N is an arithmetic expression that defaults to 1.  If any NAMEs
     are given then the arrays with these names are shifted instead of
     the positional parameters.

source FILE [ ARG ... ]
     Same as ., except that the current directory is always searched and
     is always searched first, before directories in $path.

stat
     See *note The zsh/stat Module::.

suspend [ -f ]
     Suspend the execution of the shell (send it a SIGTSTP) until it
     receives a SIGCONT.  Unless the -f option is given, this will
     refuse to suspend a login shell.

test [ ARG ... ]
[ [ ARG ... ] ]
     Like the system version of test.  Added for compatibility; use
     conditional expressions instead (see *note Conditional
     Expressions::).  The main differences between the conditional
     expression syntax and the test and [ builtins are:  these commands
     are not handled syntactically, so for example an empty variable
     expansion may cause an argument to be omitted; syntax errors cause
     status 2 to be returned instead of a shell error; and arithmetic
     operators expect integer arguments rather than arithmetic
     expressions.

     The command attempts to implement POSIX and its extensions where
     these are specified.  Unfortunately there are intrinsic
     ambiguities in the syntax; in particular there is no distinction
     between test operators and strings that resemble them.  The
     standard attempts to resolve these for small numbers of arguments
     (up to four); for five or more arguments compatibility cannot be
     relied on.  Users are urged wherever possible to use the `[[' test
     syntax which does not have these ambiguities.

times
     Print the accumulated user and system times for the shell and for
     processes run from the shell.

trap [ ARG ] [ SIG ... ]
     ARG is a series of commands (usually quoted to protect it from
     immediate evaluation by the shell) to be read and executed when
     the shell receives any of the signals specified by one or more SIG
     args.  Each SIG can be given as a number, or as the name of a
     signal either with or without the string SIG in front (e.g. 1,
     HUP, and SIGHUP are all the same signal).

     If ARG is `-', then the specified signals are reset to their
     defaults, or, if no SIG args are present, all traps are reset.

     If ARG is an empty string, then the specified signals are ignored
     by the shell (and by the commands it invokes).

     If ARG is omitted but one or more SIG args are provided (i.e.  the
     first argument is a valid signal number or name), the effect is the
     same as if ARG had been specified as `-'.

     The trap command with no arguments prints a list of commands
     associated with each signal.

     If SIG is ZERR then ARG will be executed after each command with a
     nonzero exit status.  ERR is an alias for ZERR on systems that
     have no SIGERR signal (this is the usual case).

     If SIG is DEBUG then ARG will be executed before each command if
     the option DEBUG_BEFORE_CMD is set (as it is by default), else
     after each command.  Here, a `command' is what is described as a
     `sublist' in the shell grammar, see *note Simple Commands &
     Pipelines::.  If DEBUG_BEFORE_CMD is set various additional
     features are available.  First, it is possible to skip the next
     command by setting the option ERR_EXIT; see the description of the
     ERR_EXIT option in *note Description of Options::.  Also, the
     shell parameter ZSH_DEBUG_CMD is set to the string corresponding
     to the command to be executed following the trap.  Note that this
     string is reconstructed from the internal format and may not be
     formatted the same way as the original text.  The parameter is
     unset after the trap is executed.

     If SIG is 0 or EXIT and the trap statement is executed inside the
     body of a function, then the command ARG is executed after the
     function completes.  The value of $? at the start of execution is
     the exit status of the shell or the return status of the function
     exiting.  If SIG is 0 or EXIT and the trap statement is not
     executed inside the body of a function, then the command ARG is
     executed when the shell terminates.

     ZERR, DEBUG, and EXIT traps are not executed inside other traps.
     ZERR and DEBUG traps are kept within subshells, while other traps
     are reset.

     Note that traps defined with the trap builtin are slightly
     different from those defined as `TRAPNAL () { ... }', as the
     latter have their own function environment (line numbers, local
     variables, etc.) while the former use the environment of the
     command in which they were called.  For example,


          trap 'print $LINENO' DEBUG

     will print the line number of a command executed after it has run,
     while


          TRAPDEBUG() { print $LINENO; }

     will always print the number zero.

     Alternative signal names are allowed as described under kill above.
     Defining a trap under either name causes any trap under an
     alternative name to be removed.  However, it is recommended that
     for consistency users stick exclusively to one name or another.

true [ ARG ... ]
     Do nothing and return an exit status of 0.

ttyctl -fu
     The -f option freezes the tty, and -u unfreezes it.  When the tty
     is frozen, no changes made to the tty settings by external
     programs will be honored by the shell, except for changes in the
     size of the screen; the shell will simply reset the settings to
     their previous values as soon as each command exits or is
     suspended.  Thus, stty and similar programs have no effect when
     the tty is frozen.  Without options it reports whether the
     terminal is frozen or not.

type [ -wfpams ] NAME ...
     Equivalent to whence -v.

typeset [ {+|-}AEFHUafghklprtuxmz ] [ -LRZi [ N ]] [ NAME[=VALUE] ... ]
typeset -T [ {+|-}Urux ] [ -LRZ [ N ]] SCALAR[=VALUE] ARRAY [ SEP ]
     Set or display attributes and values for shell parameters.

     A parameter is created for each NAME that does not already refer
     to one.  When inside a function, a new parameter is created for
     every NAME (even those that already exist), and is unset again
     when the function completes.  See *note Local Parameters::.  The
     same rules apply to special shell parameters, which retain their
     special attributes when made local.

     For each NAME=VALUE assignment, the parameter NAME is set to
     VALUE.  Note that arrays currently cannot be assigned in typeset
     expressions, only scalars and integers.  Unless the option
     KSH_TYPESET is set, normal expansion rules apply to assignment
     arguments, so VALUE may be split into separate words; if the
     option is set, assignments which can be recognised when expansion
     is performed are treated as single words.  For example the command
     typeset vbl=$(echo one two) is treated as having one argument if
     KSH_TYPESET is set, but otherwise is treated as having the two
     arguments vbl=one and two.

     If the shell option TYPESET_SILENT is not set, for each remaining
     NAME that refers to a parameter that is set, the name and value of
     the parameter are printed in the form of an assignment.  Nothing
     is printed for newly-created parameters, or when any attribute
     flags listed below are given along with the NAME.  Using `+'
     instead of minus to introduce an attribute turns it off.

     If the -p option is given, parameters and values are printed in the
     form of a typeset command and an assignment (which will be printed
     separately for arrays and associative arrays), regardless of other
     flags and options.  Note that the -h flag on parameters is
     respected; no value will be shown for these parameters.

     If the -T option is given, two or three arguments must be present
     (an exception is that zero arguments are allowed to show the list
     of parameters created in this fashion).  The first two are the
     name of a scalar and an array parameter (in that order) that will
     be tied together in the manner of $PATH and $path.  The optional
     third argument is a single-character separator which will be used
     to join the elements of the array to form the scalar; if absent, a
     colon is used, as with $PATH.  Only the first character of the
     separator is significant; any remaining characters are ignored.
     Only the scalar parameter may be assigned an initial value.  Both
     the scalar and the array may otherwise be manipulated as normal.
     If one is unset, the other will automatically be unset too.  There
     is no way of untying the variables without unsetting them, or
     converting the type of one of them with another typeset command;
     +T does not work, assigning an array to SCALAR is an error, and
     assigning a scalar to ARRAY sets it to be a single-element array.
     Note that both `typeset -xT ...'  and `export -T ...' work, but
     only the scalar will be marked for export.  Setting the value
     using the scalar version causes a split on all separators (which
     cannot be quoted).

     The -g (global) flag is treated specially: it means that any
     resulting parameter will not be restricted to local scope.  Note
     that this does not necessarily mean that the parameter will be
     global, as the flag will apply to any existing parameter (even if
     unset) from an enclosing function.  This flag does not affect the
     parameter after creation, hence it has no effect when listing
     existing parameters, nor does the flag +g have any effect except
     in combination with -m (see below).

     If no NAME is present, the names and values of all parameters are
     printed.  In this case the attribute flags restrict the display to
     only those parameters that have the specified attributes, and
     using `+' rather than `-' to introduce the flag suppresses
     printing of the values of parameters when there is no parameter
     name.  Also, if the last option is the word `+', then names are
     printed but values are not.

     If the -m flag is given the NAME arguments are taken as patterns
     (which should be quoted).  With no attribute flags, all parameters
     (or functions with the -f flag) with matching names are printed
     (the shell option TYPESET_SILENT is not used in this case).  Note
     that -m is ignored if no patterns are given.  If the +g flag is
     combined with -m, a new local parameter is created for every
     matching parameter that is not already local.  Otherwise -m
     applies all other flags or assignments to the existing parameters.
     Except when assignments are made with NAME=VALUE, using +m forces
     the matching parameters to be printed, even inside a function.

     If no attribute flags are given and either no -m flag is present or
     the +m form was used, each parameter name printed is preceded by a
     list of the attributes of that parameter (array, association,
     exported, integer, readonly).  If +m is used with attribute flags,
     and all those flags are introduced with +, the matching parameter
     names are printed but their values are not.

     Attribute flags that transform the final value (-L, -R, -Z, -l, u)
     are only applied to the expanded value at the point of a parameter
     expansion expression using `$'.  They are not applied when a
     parameter is retrieved internally by the shell for any purpose.

     The following attribute flags may be specified:


    -A
          The names refer to associative array parameters; see *note
          Array Parameters::.

    -L
          Left justify and remove leading blanks from VALUE.  If N is
          nonzero, it defines the width of the field.  If N is zero,
          the width is determined by the width of the value of the
          first assignment.  In the case of numeric parameters, the
          length of the complete value assigned to the parameter is
          used to determine the width, not the value that would be
          output.

          The width is the count of characters, which may be multibyte
          characters if the MULTIBYTE option is in effect.  Note that
          the screen width of the character is not taken into account;
          if this is required, use padding with parameter expansion
          flags ${(ml...)...} as described in `Parameter Expansion
          Flags' in *note Parameter Expansion::.

          When the parameter is expanded, it is filled on the right with
          blanks or truncated if necessary to fit the field.  Note
          truncation can lead to unexpected results with numeric
          parameters.  Leading zeros are removed if the -Z flag is also
          set.

    -R
          Similar to -L, except that right justification is used; when
          the parameter is expanded, the field is left filled with
          blanks or truncated from the end.  May not be combined with
          the -Z flag.

    -U
          For arrays (but not for associative arrays), keep only the
          first occurrence of each duplicated value.  This may also be
          set for colon-separated special parameters like PATH or
          FIGNORE, etc.  This flag has a different meaning when used
          with -f; see below.

    -Z
          Specially handled if set along with the -L flag.  Otherwise,
          similar to -R, except that leading zeros are used for padding
          instead of blanks if the first non-blank character is a digit.
          Numeric parameters are specially handled: they are always
          eligible for padding with zeroes, and the zeroes are inserted
          at an appropriate place in the output.

    -a
          The names refer to array parameters.  An array parameter may
          be created this way, but it may not be assigned to in the
          typeset statement.  When displaying, both normal and
          associative arrays are shown.

    -f
          The names refer to functions rather than parameters.  No
          assignments can be made, and the only other valid flags are
          -t, -k, -u, -U and -z.  The flag -t turns on execution
          tracing for this function.  The -u and -U flags cause the
          function to be marked for autoloading; -U also causes alias
          expansion to be suppressed when the function is loaded.  The
          fpath parameter will be searched to find the function
          definition when the function is first referenced; see *note
          Functions::. The -k and -z flags make the function be loaded
          using ksh-style or zsh-style autoloading respectively. If
          neither is given, the setting of the KSH_AUTOLOAD option
          determines how the function is loaded.

    -h
          Hide: only useful for special parameters (those marked `<S>'
          in the table in *note Parameters Set By The Shell::), and for
          local parameters with the same name as a special parameter,
          though harmless for others.  A special parameter with this
          attribute will not retain its special effect when made local.
          Thus after `typeset -h PATH', a function containing `typeset
          PATH' will create an ordinary local parameter without the
          usual behaviour of PATH.  Alternatively, the local parameter
          may itself be given this attribute; hence inside a function
          `typeset -h PATH' creates an ordinary local parameter and the
          special PATH parameter is not altered in any way.  It is also
          possible to create a local parameter using `typeset +h
          SPECIAL', where the local copy of SPECIAL will retain its
          special properties regardless of having the -h attribute.
          Global special parameters loaded from shell modules
          (currently those in zsh/mapfile and zsh/parameter) are
          automatically given the -h attribute to avoid name clashes.

    -H
          Hide value: specifies that typeset will not display the value
          of the parameter when listing parameters; the display for
          such parameters is always as if the `+' flag had been given.
          Use of the parameter is in other respects normal, and the
          option does not apply if the parameter is specified by name,
          or by pattern with the -m option.  This is on by default for
          the parameters in the zsh/parameter and zsh/mapfile modules.
          Note, however, that unlike the -h flag this is also useful
          for non-special parameters.

    -i
          Use an internal integer representation.  If N is nonzero it
          defines the output arithmetic base, otherwise it is
          determined by the first assignment.  Bases from 2 to 36
          inclusive are allowed.

    -E
          Use an internal double-precision floating point
          representation.  On output the variable will be converted to
          scientific notation.  If N is nonzero it defines the number
          of significant figures to display; the default is ten.

    -F
          Use an internal double-precision floating point
          representation.  On output the variable will be converted to
          fixed-point decimal notation.  If N is nonzero it defines the
          number of digits to display after the decimal point; the
          default is ten.

    -l
          Convert the result to lower case whenever the parameter is
          expanded.  The value is _not_ converted when assigned.

    -r
          The given NAMEs are marked readonly.  Note that if NAME is a
          special parameter, the readonly attribute can be turned on,
          but cannot then be turned off.

    -t
          Tags the named parameters.  Tags have no special meaning to
          the shell.  This flag has a different meaning when used with
          -f; see above.

    -u
          Convert the result to upper case whenever the parameter is
          expanded.  The value is _not_ converted when assigned.  This
          flag has a different meaning when used with -f; see above.

    -x
          Mark for automatic export to the environment of subsequently
          executed commands.  If the option GLOBAL_EXPORT is set, this
          implies the option -g, unless +g is also explicitly given; in
          other words the parameter is not made local to the enclosing
          function.  This is for compatibility with previous versions
          of zsh.


ulimit [ [ -SHacdfilmnpqstvx | -N RESOURCE [ LIMIT ] ... ]
     Set or display resource limits of the shell and the processes
     started by the shell.  The value of LIMIT can be a number in the
     unit specified below or the value `unlimited'.  By default, only
     soft limits are manipulated. If the -H flag is given use hard
     limits instead of soft limits.  If the -S flag is given together
     with the -H flag set both hard and soft limits.  If no options are
     used, the file size limit (-f) is assumed.  If LIMIT is omitted
     the current value of the specified resources are printed.  When
     more than one resource values are printed the limit name and unit
     is printed before each value.

     When looping over multiple resources, the shell will abort
     immediately if it detects a badly formed argument.  However, if it
     fails to set a limit for some other reason it will continue trying
     to set the remaining limits.


    -a
          Lists all of the current resource limits.

    -c
          512-byte blocks on the size of core dumps.

    -d
          K-bytes on the size of the data segment.

    -f
          512-byte blocks on the size of files written.

    -i
          The number of pending signals.

    -l
          K-bytes on the size of locked-in memory.

    -m
          K-bytes on the size of physical memory.

    -n
          open file descriptors.

    -q
          Bytes in POSIX message queues.

    -s
          K-bytes on the size of the stack.

    -t
          CPU seconds to be used.

    -u
          processes available to the user.

    -v
          K-bytes on the size of virtual memory.  On some systems this
          refers to the limit called `address space'.

    -x
          The number of locks on files.

     A resource may also be specified by integer in the form `-N
     RESOURCE', where RESOURCE corresponds to the integer defined for
     the resource by the operating system.  This may be used to set the
     limits for resources known to the shell which do not correspond to
     option letters.  Such limits will be shown by number in the output
     of `ulimit -a'.

     The number may alternatively be out of the range of limits
     compiled into the shell.  The shell will try to read or write the
     limit anyway, and will report an error if this fails.

umask [ -S ] [ MASK ]
     The umask is set to MASK.  MASK can be either an octal number or a
     symbolic value as described in man page chmod(1).  If MASK is
     omitted, the current value is printed.  The -S option causes the
     mask to be printed as a symbolic value.  Otherwise, the mask is
     printed as an octal number.  Note that in the symbolic form the
     permissions you specify are those which are to be allowed (not
     denied) to the users specified.

unalias
     Same as unhash -a.

unfunction
     Same as unhash -f.

unhash [ -adfms ] NAME ...
     Remove the element named NAME from an internal hash table.  The
     default is remove elements from the command hash table.  The -a
     option causes unhash to remove regular or global aliases; note
     when removing a global aliases that the argument must be quoted to
     prevent it from being expanded before being passed to the command.
     The -s option causes unhash to remove suffix aliases.  The -f
     option causes unhash to remove shell functions.  The -d options
     causes unhash to remove named directories.  If the -m flag is given
     the arguments are taken as patterns (should be quoted) and all
     elements of the corresponding hash table with matching names will
     be removed.

unlimit [ -hs ] RESOURCE ...
     The resource limit for each RESOURCE is set to the hard limit.  If
     the -h flag is given and the shell has appropriate privileges, the
     hard resource limit for each RESOURCE is removed.  The resources
     of the shell process are only changed if the -s flag is given.

unset [ -fmv ] NAME ...
     Each named parameter is unset.  Local parameters remain local even
     if unset; they appear unset within scope, but the previous value
     will still reappear when the scope ends.

     Individual elements of associative array parameters may be unset
     by using subscript syntax on NAME, which should be quoted (or the
     entire command prefixed with noglob) to protect the subscript from
     filename generation.

     If the -m flag is specified the arguments are taken as patterns
     (should be quoted) and all parameters with matching names are
     unset.  Note that this cannot be used when unsetting associative
     array elements, as the subscript will be treated as part of the
     pattern.

     The -v flag specifies that NAME refers to parameters. This is the
     default behaviour.

     unset -f is equivalent to unfunction.

unsetopt [ {+|-}OPTIONS | {+|-}o OPTION_NAME ] [ NAME ... ]
     Unset the options for the shell.  All options specified either
     with flags or by name are unset.  If no arguments are supplied,
     the names of all options currently unset are printed.  If the -m
     flag is given the arguments are taken as patterns (which should be
     quoted to preserve them from being interpreted as glob patterns),
     and all options with names matching these patterns are unset.

vared
     See *note Zle Builtins::.

wait [ JOB ... ]
     Wait for the specified jobs or processes.  If JOB is not given
     then all currently active child processes are waited for.  Each
     JOB can be either a job specification or the process ID of a job
     in the job table.  The exit status from this command is that of
     the job waited for.

whence [ -vcwfpams ] NAME ...
     For each name, indicate how it would be interpreted if used as a
     command name.


    -v
          Produce a more verbose report.

    -c
          Print the results in a `csh'-like format.  This takes
          precedence over -v.

    -w
          For each NAME, print `NAME: WORD' where WORD is one of alias,
          builtin, command, function, hashed, reserved or none,
          according as NAME corresponds to an alias, a built-in
          command, an external command, a shell function, a command
          defined with the hash builtin, a reserved word, or is not
          recognised.  This takes precedence over -v and -c.

    -f
          Causes the contents of a shell function to be displayed,
          which would otherwise not happen unless the -c flag were used.

    -p
          Do a path search for NAME even if it is an alias, reserved
          word, shell function or builtin.

    -a
          Do a search for all occurrences of NAME throughout the
          command path.  Normally only the first occurrence is printed.

    -m
          The arguments are taken as patterns (should be quoted), and
          the information is displayed for each command matching one of
          these patterns.

    -s
          If a pathname contains symlinks, print the symlink-free
          pathname as well.


where [ -wpms ] NAME ...
     Equivalent to whence -ca.

which [ -wpams ] NAME ...
     Equivalent to whence -c.

zcompile [ -U ] [ -z | -k ] [ -R | -M ] FILE [ NAME ... ]
zcompile -ca [ -m ] [ -R | -M ] FILE [ NAME ... ]
zcompile -t FILE [ NAME ... ]
     This builtin command can be used to compile functions or scripts,
     storing the compiled form in a file, and to examine files
     containing the compiled form.  This allows faster autoloading of
     functions and execution of scripts by avoiding parsing of the text
     when the files are read.

     The first form (without the -c, -a or -t options) creates a
     compiled file.  If only the FILE argument is given, the output
     file has the name `FILE.zwc' and will be placed in the same
     directory as the FILE.  The shell will load the compiled file
     instead of the normal function file when the function is
     autoloaded; see *note Functions:: for a description of how
     autoloaded functions are searched.  The extension .zwc stands for
     `zsh word code'.

     If there is at least one NAME argument, all the named files are
     compiled into the output FILE given as the first argument.  If
     FILE does not end in .zwc, this extension is automatically
     appended.  Files containing multiple compiled functions are called
     `digest' files, and are intended to be used as elements of the
     FPATH/fpath special array.

     The second form, with the -c or -a options, writes the compiled
     definitions for all the named functions into FILE.  For -c, the
     names must be functions currently defined in the shell, not those
     marked for autoloading.  Undefined functions that are marked for
     autoloading may be written by using the -a option, in which case
     the fpath is searched and the contents of the definition files for
     those functions, if found, are compiled into FILE.  If both -c and
     -a are given, names of both defined functions and functions marked
     for autoloading may be given.  In either case, the functions in
     files written with the -c or -a option will be autoloaded as if the
     KSH_AUTOLOAD option were unset.

     The reason for handling loaded and not-yet-loaded functions with
     different options is that some definition files for autoloading
     define multiple functions, including the function with the same
     name as the file, and, at the end, call that function.  In such
     cases the output of `zcompile -c' does not include the additional
     functions defined in the file, and any other initialization code
     in the file is lost.  Using `zcompile -a' captures all this extra
     information.

     If the -m option is combined with -c or -a, the NAMEs are used as
     patterns and all functions whose names match one of these patterns
     will be written. If no NAME is given, the definitions of all
     functions currently defined or marked as autoloaded will be
     written.

     The third form, with the -t option, examines an existing compiled
     file.  Without further arguments, the names of the original files
     compiled into it are listed.  The first line of output shows the
     version of the shell which compiled the file and how the file will
     be used (i.e. by reading it directly or by mapping it into memory).
     With arguments, nothing is output and the return status is set to
     zero if definitions for _all_ NAMEs were found in the compiled
     file, and non-zero if the definition for at least one NAME was not
     found.

     Other options:


    -U
          Aliases are not expanded when compiling the NAMEd files.

    -R
          When the compiled file is read, its contents are copied into
          the shell's memory, rather than memory-mapped (see -M).  This
          happens automatically on systems that do not support memory
          mapping.

          When compiling scripts instead of autoloadable functions, it
          is often desirable to use this option; otherwise the whole
          file, including the code to define functions which have
          already been defined, will remain mapped, consequently
          wasting memory.

    -M
          The compiled file is mapped into the shell's memory when
          read. This is done in such a way that multiple instances of
          the shell running on the same host will share this mapped
          file.  If neither -R nor -M is given, the zcompile builtin
          decides what to do based on the size of the compiled file.

    -k
    -z
          These options are used when the compiled file contains
          functions which are to be autoloaded. If -z is given, the
          function will be autoloaded as if the KSH_AUTOLOAD option is
          _not_ set, even if it is set at the time the compiled file is
          read, while if the -k is given, the function will be loaded
          as if KSH_AUTOLOAD _is_ set.  These options also take
          precedence over any -k or -z options specified to the
          autoload builtin. If neither of these options is given, the
          function will be loaded as determined by the setting of the
          KSH_AUTOLOAD option at the time the compiled file is read.

          These options may also appear as many times as necessary
          between the listed NAMEs to specify the loading style of all
          following functions, up to the next -k or -z.


     The created file always contains two versions of the compiled
     format, one for big-endian machines and one for small-endian
     machines.  The upshot of this is that the compiled file is machine
     independent and if it is read or mapped, only one half of the file
     is actually used (and mapped).

zformat
     See *note The zsh/zutil Module::.

zftp
     See *note The zsh/zftp Module::.

zle
     See *note Zle Builtins::.

zmodload [ -dL ] [ ... ]
zmodload -F [ -lLme -P param ] MODULE [+-]FEATURE...
zmodload -e [ -A ] [ ... ]
zmodload [ -a [ -bcpf [ -I ] ] ] [ -iL ] ...
zmodload -u [ -abcdpf [ -I ] ] [ -iL ] ...
zmodload -A [ -L ] [ MODALIAS[=MODULE] ... ]
zmodload -R MODALIAS ...
     Performs operations relating to zsh's loadable modules.  Loading
     of modules while the shell is running (`dynamical loading') is not
     available on all operating systems, or on all installations on a
     particular operating system, although the zmodload command itself
     is always available and can be used to manipulate modules built
     into versions of the shell executable without dynamical loading.

     Without arguments the names of all currently loaded binary modules
     are printed.  The -L option causes this list to be in the form of a
     series of zmodload commands.  Forms with arguments are:


    zmodload [ -i ] NAME ...
    zmodload -u [ -i ] NAME ...
          In the simplest case, zmodload loads a binary module.  The
          module must be in a file with a name consisting of the
          specified NAME followed by a standard suffix, usually `.so'
          (`.sl' on HPUX).  If the module to be loaded is already
          loaded the duplicate module is ignored.  If zmodload detects
          an inconsistency, such as an invalid module name or circular
          dependency list, the current code block is aborted.   Hence
          `zmodload MODULE 2>/dev/null' is sufficient to test whether a
          module is available.  If it is available, the module is
          loaded if necessary, while if it is not available, non-zero
          status is silently returned.  The option -i is accepted for
          compatibility but has no effect.

          The NAMEd module is searched for in the same way a command
          is, using $module_path instead of $path.  However, the path
          search is performed even when the module name contains a `/',
          which it usually does.  There is no way to prevent the path
          search.

          If the module supports features (see below), zmodload tries to
          enable all features when loading a module.  If the module was
          successfully loaded but not all features could be enabled,
          zmodload returns status 2.

          With -u, zmodload unloads modules.  The same NAME must be
          given that was given when the module was loaded, but it is not
          necessary for the module to exist in the filesystem.  The -i
          option suppresses the error if the module is already unloaded
          (or was never loaded).

          Each module has a boot and a cleanup function.  The module
          will not be loaded if its boot function fails.  Similarly a
          module can only be unloaded if its cleanup function runs
          successfully.

    zmodload -F [ -almLe -P param ] MODULE [+-]FEATURE...
          zmodload -F allows more selective control over the features
          provided by modules.  With no options apart from -F, the
          module named MODULE is loaded, if it was not already loaded,
          and the list of FEATUREs is set to the required state.  If no
          FEATUREs are specified, the module is loaded, if it was not
          already loaded, but the state of features is unchanged.  Each
          feature may be preceded by a + to turn the feature on, or -
          to turn it off; the + is assumed if neither character is
          present.  Any feature not explicitly mentioned is left in its
          current state; if the module was not previously loaded this
          means any such features will remain disabled.  The return
          status is zero if all features were set, 1 if the module
          failed to load, and 2 if some features could not be set (for
          example, a parameter couldn't be added because there was a
          different parameter of the same name) but the module was
          loaded.

          The standard features are builtins, conditions, parameters
          and math functions; these are indicated by the prefix `b:',
          `c:' (`C:' for an infix condition), `p:' and `f:',
          respectively, followed by the name that the corresponding
          feature would have in the shell.  For example, `b:strftime'
          indicates a builtin named strftime and p:EPOCHSECONDS
          indicates a parameter named EPOCHSECONDS.  The module may
          provide other (`abstract') features of its own as indicated
          by its documentation; these have no prefix.

          With -l or -L, features provided by the module are listed.
          With -l alone, a list of features together with their states
          is shown, one feature per line.  With -L alone, a zmodload -F
          command that would cause enabled features of the module to be
          turned on is shown.  With -lL, a zmodload -F command that
          would cause all the features to be set to their current state
          is shown.  If one of these combinations is given the option
          -P PARAM then the parameter param is set to an array of
          features, either features together with their state or (if -L
          alone is given) enabled features.

          With the option -L the module name may be omitted; then a list
          of all enabled features for all modules providing features is
          printed in the form of zmodload -F commands.  If -l is also
          given, the state of both enabled and disabled features is
          output in that form.

          A set of features may be provided together with -l or -L and a
          module name; in that case only the state of those features is
          considered.  Each feature may be preceded by + or - but the
          character has no effect.  If no set of features is provided,
          all features are considered.

          With -e, the command first tests that the module is loaded;
          if it is not, status 1 is returned.  If the module is loaded,
          the list of features given as an argument is examined.  Any
          feature given with no prefix is simply tested to see if the
          module provides it; any feature given with a prefix + or - is
          tested to see if is provided and in the given state.  If the
          tests on all features in the list succeed, status 0 is
          returned, else status 1.

          With -m, each entry in the given list of features is taken as
          a pattern to be matched against the list of features provided
          by the module.  An initial + or - must be given explicitly.
          This may not be combined with the -a option as autoloads must
          be specified explicitly.

          With -a, the given list of features is marked for autoload
          from the specified module, which may not yet be loaded.  An
          optional + may appear before the feature name.  If the
          feature is prefixed with -, any existing autoload is removed.
          The options -l and -L may be used to list autoloads.
          Autoloading is specific to individual features; when the
          module is loaded only the requested feature is enabled.
          Autoload requests are preserved if the module is subsequently
          unloaded until an explicit `zmodload -Fa MODULE -FEATURE' is
          issued.  It is not an error to request an autoload for a
          feature of a module that is already loaded.

          When the module is loaded each autoload is checked against
          the features actually provided by the module; if the feature
          is not provided the autoload request is deleted.  A warning
          message is output; if the module is being loaded to provide a
          different feature, and that autoload is successful, there is
          no effect on the status of the current command.  If the
          module is already loaded at the time when zmodload -Fa is
          run, an error message is printed and status 1 returned.

          zmodload -Fa can be used with the -l, -L, -e and -P options
          for listing and testing the existence of autoloadable
          features.  In this case -l is ignored if -L is specified.
          zmodload -FaL with no module name lists autoloads for all
          modules.

          Note that only standard features as described above can be
          autoloaded; other features require the module to be loaded
          before enabling.

    zmodload -d [ -L ] [ NAME ]
    zmodload -d NAME DEP ...
    zmodload -ud NAME [ DEP ... ]
          The -d option can be used to specify module dependencies.
          The modules named in the second and subsequent arguments will
          be loaded before the module named in the first argument.

          With -d and one argument, all dependencies for that module
          are listed.  With -d and no arguments, all module
          dependencies are listed.  This listing is by default in a
          Makefile-like format.  The -L option changes this format to a
          list of zmodload -d commands.

          If -d and -u are both used, dependencies are removed.  If
          only one argument is given, all dependencies for that module
          are removed.

    zmodload -ab [ -L ]
    zmodload -ab [ -i ] NAME [ BUILTIN ... ]
    zmodload -ub [ -i ] BUILTIN ...
          The -ab option defines autoloaded builtins.  It defines the
          specified BUILTINs.  When any of those builtins is called,
          the module specified in the first argument is loaded and all
          its features are enabled (for selective control of features
          use `zmodload -F -a' as described above).  If only the NAME
          is given, one builtin is defined, with the same name as the
          module.  -i suppresses the error if the builtin is already
          defined or autoloaded, but not if another builtin of the same
          name is already defined.

          With -ab and no arguments, all autoloaded builtins are
          listed, with the module name (if different) shown in
          parentheses after the builtin name.  The -L option changes
          this format to a list of zmodload -a commands.

          If -b is used together with the -u option, it removes builtins
          previously defined with -ab.  This is only possible if the
          builtin is not yet loaded.  -i suppresses the error if the
          builtin is already removed (or never existed).

          Autoload requests are retained if the module is subsequently
          unloaded until an explicit `zmodload -ub BUILTIN' is issued.

    zmodload -ac [ -IL ]
    zmodload -ac [ -iI ] NAME [ COND ... ]
    zmodload -uc [ -iI ] COND ...
          The -ac option is used to define autoloaded condition codes.
          The COND strings give the names of the conditions defined by
          the module. The optional -I option is used to define infix
          condition names. Without this option prefix condition names
          are defined.

          If given no condition names, all defined names are listed (as
          a series of zmodload commands if the -L option is given).

          The -uc option removes definitions for autoloaded conditions.

    zmodload -ap [ -L ]
    zmodload -ap [ -i ] NAME [ PARAMETER ... ]
    zmodload -up [ -i ] PARAMETER ...
          The -p option is like the -b and -c options, but makes
          zmodload work on autoloaded parameters instead.

    zmodload -af [ -L ]
    zmodload -af [ -i ] NAME [ FUNCTION ... ]
    zmodload -uf [ -i ] FUNCTION ...
          The -f option is like the -b, -p, and -c options, but makes
          zmodload work on autoloaded math functions instead.

    zmodload -a [ -L ]
    zmodload -a [ -i ] NAME [ BUILTIN ... ]
    zmodload -ua [ -i ] BUILTIN ...
          Equivalent to -ab and -ub.

    zmodload -e [ -A ] [ STRING ... ]
          The -e option without arguments lists all loaded modules; if
          the -A option is also given, module aliases corresponding to
          loaded modules are also shown.  If arguments are provided,
          nothing is printed; the return status is set to zero if all
          STRINGs given as arguments are names of loaded modules and to
          one if at least on STRING is not the name of a loaded module.
          This can be used to test for the availability of things
          implemented by modules.  In this case, any aliases are
          automatically resolved and the -A flag is not used.

    zmodload -A [ -L ] [ MODALIAS[=MODULE] ... ]
          For each argument, if both MODALIAS and MODULE are given,
          define MODALIAS to be an alias for the module MODULE.  If the
          module MODALIAS is ever subsequently requested, either via a
          call to zmodload or implicitly, the shell will attempt to load
          MODULE instead.  If MODULE is not given, show the definition
          of MODALIAS.  If no arguments are given, list all defined
          module aliases.  When listing, if the -L flag was also given,
          list the definition as a zmodload command to recreate the
          alias.

          The existence of aliases for modules is completely
          independent of whether the name resolved is actually loaded
          as a module: while the alias exists, loading and unloading
          the module under any alias has exactly the same effect as
          using the resolved name, and does not affect the connection
          between the alias and the resolved name which can be removed
          either by zmodload -R or by redefining the alias.  Chains of
          aliases (i.e. where the first resolved name is itself an
          alias) are valid so long as these are not circular.  As the
          aliases take the same format as module names, they may
          include path separators:  in this case, there is no
          requirement for any part of the path named to exist as the
          alias will be resolved first.  For example, `any/old/alias'
          is always a valid alias.

          Dependencies added to aliased modules are actually added to
          the resolved module; these remain if the alias is removed.
          It is valid to create an alias whose name is one of the
          standard shell modules and which resolves to a different
          module.  However, if a module has dependencies, it will not
          be possible to use the module name as an alias as the module
          will already be marked as a loadable module in its own right.

          Apart from the above, aliases can be used in the zmodload
          command anywhere module names are required.  However, aliases
          will not be shown in lists of loaded modules with a bare
          `zmodload'.

    zmodload -R MODALIAS ...
          For each MODALIAS argument that was previously defined as a
          module alias via zmodload -A, delete the alias.  If any was
          not defined, an error is caused and the remainder of the line
          is ignored.


     Note that zsh makes no distinction between modules that were linked
     into the shell and modules that are loaded dynamically. In both
     cases this builtin command has to be used to make available the
     builtins and other things defined by modules (unless the module is
     autoloaded on these definitions). This is true even for systems
     that don't support dynamic loading of modules.

zparseopts
     See *note The zsh/zutil Module::.

zprof
     See *note The zsh/zprof Module::.

zpty
     See *note The zsh/zpty Module::.

zregexparse
     See *note The zsh/zutil Module::.

zsocket
     See *note The zsh/net/socket Module::.

zstyle
     See *note The zsh/zutil Module::.

ztcp
     See *note The zsh/net/tcp Module::.



File: zsh.info,  Node: Zsh Line Editor,  Next: Completion Widgets,  Prev: Shell Builtin Commands,  Up: Top

18 Zsh Line Editor
******************



18.1 Description
================

If the ZLE option is set (which it is by default in interactive shells)
and the shell input is attached to the terminal, the user is able to
edit command lines.

There are two display modes.  The first, multiline mode, is the
default.  It only works if the TERM parameter is set to a valid
terminal type that can move the cursor up.  The second, single line
mode, is used if TERM is invalid or incapable of moving the cursor up,
or if the SINGLE_LINE_ZLE option is set.  This mode is similar to
`ksh', and uses no termcap sequences.  If TERM is "emacs", the ZLE
option will be unset by default.

The parameters BAUD, COLUMNS, and LINES are also used by the line
editor.  *note Parameters Used By The Shell::.

The parameter zle_highlight is also used by the line editor; *note
Character Highlighting::.  Highlighting of special characters and the
region between the cursor and the mark (as set with set-mark-command in
Emacs mode) is enabled by default; consult this reference for more
information.  Irascible conservatives will wish to know that all
highlighting may be disabled by the following setting:


     zle_highlight=(none)


* Menu:

* Keymaps::
* Zle Builtins::
* Zle Widgets::
* Character Highlighting::



File: zsh.info,  Node: Keymaps,  Next: Zle Builtins,  Up: Zsh Line Editor

18.2 Keymaps
============

A keymap in ZLE contains a set of bindings between key sequences and
ZLE commands.  The empty key sequence cannot be bound.

There can be any number of keymaps at any time, and each keymap has one
or more names.  If all of a keymap's names are deleted, it disappears.  bindkey
can be used to manipulate keymap names.

Initially, there are four keymaps:


emacs
     EMACS emulation

viins
     vi emulation - insert mode

vicmd
     vi emulation - command mode

.safe
     fallback keymap

The `.safe' keymap is special.  It can never be altered, and the name
can never be removed.  However, it can be linked to other names, which
can be removed.  In the future other special keymaps may be added;
users should avoid using names beginning with `.' for their own keymaps.

In addition to these four names, either `emacs' or `viins' is also
linked to the name `main'.  If one of the VISUAL or EDITOR environment
variables contain the string `vi' when the shell starts up then it will
be `viins', otherwise it will be `emacs'.  bindkey's -e and -v options
provide a convenient way to override this default choice.

When the editor starts up, it will select the `main' keymap.  If that
keymap doesn't exist, it will use `.safe' instead.

In the `.safe' keymap, each single key is bound to self-insert, except
for ^J (line feed) and ^M (return) which are bound to accept-line.
This is deliberately not pleasant to use; if you are using it, it means
you deleted the main keymap, and you should put it back.

18.2.1 Reading Commands
-----------------------

When ZLE is reading a command from the terminal, it may read a sequence
that is bound to some command and is also a prefix of a longer bound
string.  In this case ZLE will wait a certain time to see if more
characters are typed, and if not (or they don't match any longer
string) it will execute the binding.  This timeout is defined by the
KEYTIMEOUT parameter; its default is 0.4 sec.  There is no timeout if
the prefix string is not itself bound to a command.

The key timeout is also applied when ZLE is reading the bytes from a
multibyte character string when it is in the appropriate mode.  (This
requires that the shell was compiled with multibyte mode enabled;
typically also the locale has characters with the UTF-8 encoding,
although any multibyte encoding known to the operating system is
supported.)  If the second or a subsequent byte is not read within the
timeout period, the shell acts as if ? were typed and resets the input
state.

As well as ZLE commands, key sequences can be bound to other strings,
by using `bindkey -s'.  When such a sequence is read, the replacement
string is pushed back as input, and the command reading process starts
again using these fake keystrokes.  This input can itself invoke
further replacement strings, but in order to detect loops the process
will be stopped if there are twenty such replacements without a real
command being read.

A key sequence typed by the user can be turned into a command name for
use in user-defined widgets with the read-command widget, described in
*note Miscellaneous:: below.




File: zsh.info,  Node: Zle Builtins,  Next: Zle Widgets,  Prev: Keymaps,  Up: Zsh Line Editor

18.3 Zle Builtins
=================

The ZLE module contains three related builtin commands. The bindkey
command manipulates keymaps and key bindings; the vared command invokes
ZLE on the value of a shell parameter; and the zle command manipulates
editing widgets and allows command line access to ZLE commands from
within shell functions.


bindkey [ OPTIONS ] -l
bindkey [ OPTIONS ] -d
bindkey [ OPTIONS ] -D KEYMAP ...
bindkey [ OPTIONS ] -A OLD-KEYMAP NEW-KEYMAP
bindkey [ OPTIONS ] -N NEW-KEYMAP [ OLD-KEYMAP ]
bindkey [ OPTIONS ] -m
bindkey [ OPTIONS ] -r IN-STRING ...
bindkey [ OPTIONS ] -s IN-STRING OUT-STRING ...
bindkey [ OPTIONS ] IN-STRING COMMAND ...
bindkey [ OPTIONS ] [ IN-STRING ]
     bindkey's options can be divided into three categories: keymap
     selection, operation selection, and others.  The keymap selection
     options are:


    -e
          Selects keymap `emacs', and also links it to `main'.

    -v
          Selects keymap `viins', and also links it to `main'.

    -a
          Selects keymap `vicmd'.

    -M KEYMAP
          The KEYMAP specifies a keymap name.


     If a keymap selection is required and none of the options above
     are used, the `main' keymap is used.  Some operations do not
     permit a keymap to be selected, namely:


    -l
          List all existing keymap names.  If the -L option is also
          used, list in the form of bindkey commands to create the
          keymaps.

    -d
          Delete all existing keymaps and reset to the default state.

    -D KEYMAP ...
          Delete the named KEYMAPs.

    -A OLD-KEYMAP NEW-KEYMAP
          Make the NEW-KEYMAP name an alias for OLD-KEYMAP, so that
          both names refer to the same keymap.  The names have equal
          standing; if either is deleted, the other remains.  If there
          is already a keymap with the NEW-KEYMAP name, it is deleted.

    -N NEW-KEYMAP [ OLD-KEYMAP ]
          Create a new keymap, named NEW-KEYMAP.  If a keymap already
          has that name, it is deleted.  If an OLD-KEYMAP name is
          given, the new keymap is initialized to be a duplicate of it,
          otherwise the new keymap will be empty.


     To use a newly created keymap, it should be linked to main.  Hence
     the sequence of commands to create and use a new keymap `mymap'
     initialized from the emacs keymap (which remains unchanged) is:


          bindkey -N mymap emacs
          bindkey -A mymap main

     Note that while `bindkey -A NEWMAP main' will work when NEWMAP is
     emacs or viins, it will not work for vicmd, as switching from vi
     insert to command mode becomes impossible.

     The following operations act on the `main' keymap if no keymap
     selection option was given:


    -m
          Add the built-in set of meta-key bindings to the selected
          keymap.  Only keys that are unbound or bound to self-insert
          are affected.

    -r IN-STRING ...
          Unbind the specified IN-STRINGs in the selected keymap.  This
          is exactly equivalent to binding the strings to undefined-key.

          When -R is also used, interpret the IN-STRINGs as ranges.

          When -p is also used, the IN-STRINGs specify prefixes.  Any
          binding that has the given IN-STRING as a prefix, not
          including the binding for the IN-STRING itself, if any, will
          be removed.  For example,


               bindkey -rpM viins '^['

          will remove all bindings in the vi-insert keymap beginning
          with an escape character (probably cursor keys), but leave
          the binding for the escape character itself (probably
          vi-cmd-mode).  This is incompatible with the option -R.

    -s IN-STRING OUT-STRING ...
          Bind each IN-STRING to each OUT-STRING.  When IN-STRING is
          typed, OUT-STRING will be pushed back and treated as input to
          the line editor.  When -R is also used, interpret the
          IN-STRINGs as ranges.

    IN-STRING COMMAND ...
          Bind each IN-STRING to each COMMAND.  When -R is used,
          interpret the IN-STRINGs as ranges.

    [ IN-STRING ]
          List key bindings.  If an IN-STRING is specified, the binding
          of that string in the selected keymap is displayed.
          Otherwise, all key bindings in the selected keymap are
          displayed.  (As a special case, if the -e or -v option is
          used alone, the keymap is _not_ displayed - the implicit
          linking of keymaps is the only thing that happens.)

          When the option -p is used, the IN-STRING must be present.
          The listing shows all bindings which have the given key
          sequence as a prefix, not including any bindings for the key
          sequence itself.

          When the -L option is used, the list is in the form of bindkey
          commands to create the key bindings.


     When the -R option is used as noted above, a valid range consists
     of two characters, with an optional `-' between them.  All
     characters between the two specified, inclusive, are bound as
     specified.

     For either IN-STRING or OUT-STRING, the following escape sequences
     are recognised:


    \a
          bell character

    \b
          backspace

    \e, \E
          escape

    \f
          form feed

    \n
          linefeed (newline)

    \r
          carriage return

    \t
          horizontal tab

    \v
          vertical tab

    \NNN
          character code in octal

    \xNN
          character code in hexadecimal

    \M[-]X
          character with meta bit set

    \C[-]X
          control character

    ^X
          control character

     In all other cases, `\' escapes the following character.  Delete is
     written as `^?'.  Note that `\M^?' and `^\M?' are not the same,
     and that (unlike emacs), the bindings `\M-X' and `\eX' are
     entirely distinct, although they are initialized to the same
     bindings by `bindkey -m'.

vared [ -Aache ] [ -p PROMPT ] [ -r RPROMPT ]
[ -M MAIN-KEYMAP ] [ -m VICMD-KEYMAP ] NAME
     The value of the parameter NAME is loaded into the edit buffer,
     and the line editor is invoked.  When the editor exits, NAME is
     set to the string value returned by the editor.  When the -c flag
     is given, the parameter is created if it doesn't already exist.
     The -a flag may be given with -c to create an array parameter, or
     the -A flag to create an associative array.  If the type of an
     existing parameter does not match the type to be created, the
     parameter is unset and recreated.

     If an array or array slice is being edited, separator characters
     as defined in $IFS will be shown quoted with a backslash, as will
     backslashes themselves.  Conversely, when the edited text is split
     into an array, a backslash quotes an immediately following
     separator character or backslash; no other special handling of
     backslashes, or any handling of quotes, is performed.

     Individual elements of existing array or associative array
     parameters may be edited by using subscript syntax on NAME.  New
     elements are created automatically, even without -c.

     If the -p flag is given, the following string will be taken as the
     prompt to display at the left.  If the -r flag is given, the
     following string gives the prompt to display at the right.  If the
     -h flag is specified, the history can be accessed from ZLE. If the
     -e flag is given, typing ^D (Control-D) on an empty line causes
     vared to exit immediately with a non-zero return value.

     The -M option gives a keymap to link to the main keymap during
     editing, and the -m option gives a keymap to link to the vicmd
     keymap during editing.  For vi-style editing, this allows a pair
     of keymaps to override viins and vicmd.  For emacs-style editing,
     only -M is normally needed but the -m option may still be used.
     On exit, the previous keymaps will be restored.

zle
zle -l [ -L | -a ] [ STRING ... ]
zle -D WIDGET ...
zle -A OLD-WIDGET NEW-WIDGET
zle -N WIDGET [ FUNCTION ]
zle -C WIDGET COMPLETION-WIDGET FUNCTION
zle -R [ -c ] [ DISPLAY-STRING ] [ STRING ... ]
zle -M STRING
zle -U STRING
zle -K KEYMAP
zle -F [ -L ] [ FD [ HANDLER ] ]
zle -I
zle WIDGET [ -n NUM ] [ -Nw ] [ -K KEYMAP ] ARGS ...
     The zle builtin performs a number of different actions concerning
     ZLE.

     With no options and no arguments, only the return status will be
     set.  It is zero if ZLE is currently active and widgets could be
     invoked using this builtin command and non-zero otherwise.  Note
     that even if non-zero status is returned, zle may still be active
     as part of the completion system; this does not allow direct calls
     to ZLE widgets.

     Otherwise, which operation it performs depends on its options:


    -l [ -L | -a ]
          List all existing user-defined widgets.  If the -L option is
          used, list in the form of zle commands to create the widgets.

          When combined with the -a option, all widget names are listed,
          including the builtin ones. In this case the -L option is
          ignored.

          If at least one STRING is given, nothing will be printed but
          the return status will be zero if all STRINGs are names of
          existing widgets (or of user-defined widgets if the -a flag
          is not given) and non-zero if at least one STRING is not a
          name of an defined widget.

    -D WIDGET ...
          Delete the named WIDGETs.

    -A OLD-WIDGET NEW-WIDGET
          Make the NEW-WIDGET name an alias for OLD-WIDGET, so that
          both names refer to the same widget.  The names have equal
          standing; if either is deleted, the other remains.  If there
          is already a widget with the NEW-WIDGET name, it is deleted.

    -N WIDGET [ FUNCTION ]
          Create a user-defined widget.  If there is already a widget
          with the specified name, it is overwritten.  When the new
          widget is invoked from within the editor, the specified shell
          FUNCTION is called.  If no function name is specified, it
          defaults to the same name as the widget.  For further
          information, see the section _Widgets_ in *note Zsh Line
          Editor::.

    -C WIDGET COMPLETION-WIDGET FUNCTION
          Create a user-defined completion widget named WIDGET. The
          completion widget will behave like the built-in
          completion-widget whose name is given as COMPLETION-WIDGET.
          To generate the completions, the shell function FUNCTION will
          be called.  For further information, see *note Completion
          Widgets::.

    -R [ -c ] [ DISPLAY-STRING ] [ STRING ... ]
          Redisplay the command line; this is to be called from within
          a user-defined widget to allow changes to become visible.  If
          a DISPLAY-STRING is given and not empty, this is shown in the
          status line (immediately below the line being edited).

          If the optional STRINGs are given they are listed below the
          prompt in the same way as completion lists are printed. If no
          STRINGs are given but the -c option is used such a list is
          cleared.

          Note that this option is only useful for widgets that do not
          exit immediately after using it because the strings displayed
          will be erased immediately after return from the widget.

          This command can safely be called outside user defined
          widgets; if zle is active, the display will be refreshed,
          while if zle is not active, the command has no effect.  In
          this case there will usually be no other arguments.

          The status is zero if zle was active, else one.

    -M STRING
          As with the -R option, the STRING will be displayed below the
          command line; unlike the -R option, the string will not be
          put into the status line but will instead be printed normally
          below the prompt.  This means that the STRING will still be
          displayed after the widget returns (until it is overwritten
          by subsequent commands).

    -U STRING
          This pushes the characters in the STRING onto the input stack
          of ZLE.  After the widget currently executed finishes ZLE
          will behave as if the characters in the STRING were typed by
          the user.

          As ZLE uses a stack, if this option is used repeatedly the
          last string pushed onto the stack will be processed first.
          However, the characters in each STRING will be processed in
          the order in which they appear in the string.

    -K KEYMAP
          Selects the keymap named KEYMAP.  An error message will be
          displayed if there is no such keymap.

          This keymap selection affects the interpretation of following
          keystrokes within this invocation of ZLE.  Any following
          invocation (e.g., the next command line) will start as usual
          with the `main' keymap selected.

    -F [ -L ] [ FD [ HANDLER ] ]
          Only available if your system supports one of the `poll' or
          `select' system calls; most modern systems do.

          Installs HANDLER (the name of a shell function) to handle
          input from file descriptor FD.  When zle is attempting to
          read data, it will examine both the terminal and the list of
          handled FD's.  If data becomes available on a handled FD, zle
          will call HANDLER with the fd which is ready for reading as
          the only argument.  If the handler produces output to the
          terminal, it should call `zle -I' before doing so (see
          below).  The handler should not attempt to read from the
          terminal.  Note that zle makes no attempt to check whether
          this fd is actually readable when installing the handler.
          The user must make their own arrangements for handling the
          file descriptor when zle is not active.

          Any number of handlers for any number of readable file
          descriptors may be installed.  Installing a handler for an FD
          which is already handled causes the existing handler to be
          replaced.

          If no HANDLER is given, but an FD is present, any handler for
          that FD is removed.  If there is none, an error message is
          printed and status 1 is returned.

          If no arguments are given, or the -L option is supplied, a
          list of handlers is printed in a form which can be stored for
          later execution.

          An FD (but not a HANDLER) may optionally be given with the -L
          option; in this case, the function will list the handler if
          any, else silently return status 1.

          Note that this feature should be used with care.  Activity on
          one of the FD's which is not properly handled can cause the
          terminal to become unusable.

          Here is a simple example of using this feature.  A connection
          to a remote TCP port is created using the ztcp command; see
          *note The zsh/net/tcp Module::.  Then a handler is installed
          which simply prints out any data which arrives on this
          connection.  Note that `select' will indicate that the file
          descriptor needs handling if the remote side has closed the
          connection; we handle that by testing for a failed read.
               if ztcp pwspc 2811; then
                 tcpfd=$REPLY
                 handler() {
                   zle -I
                   local line
                   if ! read -r line <&$1; then
                     # select marks this fd if we reach EOF,
                     # so handle this specially.
                     print "[Read on fd $1 failed, removing.]" >&2
                     zle -F $1
                     return 1
                   fi
                   print -r - $line
                 }
                 zle -F $tcpfd handler
               fi

    -I
          Unusually, this option is most useful outside ordinary widget
          functions, though it may be used within if normal output to
          the terminal is required.  It invalidates the current zle
          display in preparation for output; typically this will be
          from a trap function.  It has no effect if zle is not active.
          When a trap exits, the shell checks to see if the display
          needs restoring, hence the following will print output in
          such a way as not to disturb the line being edited:


               TRAPUSR1() {
                   # Invalidate zle display
                 [[ -o zle ]] && zle -I
                   # Show output
                 print Hello
               }

          In general, the trap function may need to test whether zle is
          active before using this method (as shown in the example),
          since the zsh/zle module may not even be loaded; if it is
          not, the command can be skipped.

          It is possible to call `zle -I' several times before control
          is returned to the editor; the display will only be
          invalidated the first time to minimise disruption.

          Note that there are normally better ways of manipulating the
          display from within zle widgets; see, for example, `zle -R'
          above.

          The returned status is zero if zle was invalidated, even
          though this may have been by a previous call to `zle -I' or
          by a system notification.  To test if a zle widget may be
          called at this point, execute zle with no arguments and
          examine the return status.

    WIDGET [ -n NUM ] [ -Nw ] [ -K KEYMAP ] ARGS ...
          Invoke the specified widget.  This can only be done when ZLE
          is active; normally this will be within a user-defined widget.

          With the options -n and -N, the current numerical argument
          will be saved and then restored after the call to widget; `-n
          NUM' sets the numerical argument temporarily to NUM, while
          `-N' sets it to the default, i.e. as if there were none.

          With the option -K, KEYMAP will be used as the current keymap
          during the execution of the widget.  The previous keymap will
          be restored when the widget exits.

          Normally, calling a widget in this way does not set the
          special parameter WIDGET and related parameters, so that the
          environment appears as if the top-level widget called by the
          user were still active.  With the option -w, WIDGET and
          related parameters are set to reflect the widget being
          executed by the zle call.

          Any further arguments will be passed to the widget; note that
          as standard argument handling is performed, any general
          argument list should be preceded by --.  If it is a shell
          function, these are passed down as positional parameters; for
          builtin widgets it is up to the widget in question what it
          does with them.  Currently arguments are only handled by the
          incremental-search commands, the history-search-forward and
          -backward and the corresponding functions prefixed by vi-,
          and by universal-argument.  No error is flagged if the
          command does not use the arguments, or only uses some of them.

          The return status reflects the success or failure of the
          operation carried out by the widget, or if it is a
          user-defined widget the return status of the shell function.

          A non-zero return status causes the shell to beep when the
          widget exits, unless the BEEP options was unset or the widget
          was called via the zle command.  Thus if a user defined
          widget requires an immediate beep, it should call the beep
          widget directly.





File: zsh.info,  Node: Zle Widgets,  Next: Character Highlighting,  Prev: Zle Builtins,  Up: Zsh Line Editor

18.4 Widgets
============

All actions in the editor are performed by `widgets'.  A widget's job is
simply to perform some small action.  The ZLE commands that key
sequences in keymaps are bound to are in fact widgets.  Widgets can be
user-defined or built in.

The standard widgets built in to ZLE are listed in Standard Widgets
below.  Other built-in widgets can be defined by other modules (see
*note Zsh Modules::).  Each built-in widget has two names: its normal
canonical name, and the same name preceded by a `.'.  The `.' name is
special: it can't be rebound to a different widget.  This makes the
widget available even when its usual name has been redefined.

User-defined widgets are defined using `zle -N', and implemented as
shell functions.  When the widget is executed, the corresponding shell
function is executed, and can perform editing (or other) actions.  It
is recommended that user-defined widgets should not have names starting
with `.'.

18.5 User-Defined Widgets
=========================

User-defined widgets, being implemented as shell functions, can execute
any normal shell command.  They can also run other widgets (whether
built-in or user-defined) using the zle builtin command.  The standard
input of the function is closed to prevent external commands from
unintentionally blocking ZLE by reading from the terminal, but read -k
or read -q can be used to read characters.  Finally, they can examine
and edit the ZLE buffer being edited by reading and setting the special
parameters described below.

These special parameters are always available in widget functions, but
are not in any way special outside ZLE.  If they have some normal value
outside ZLE, that value is temporarily inaccessible, but will return
when the widget function exits.  These special parameters in fact have
local scope, like parameters created in a function using local.

Inside completion widgets and traps called while ZLE is active, these
parameters are available read-only.


BUFFER (scalar)
     The entire contents of the edit buffer.  If it is written to, the
     cursor remains at the same offset, unless that would put it
     outside the buffer.

BUFFERLINES (integer)
     The number of screen lines needed for the edit buffer currently
     displayed on screen (i.e. without any changes to the preceding
     parameters done after the last redisplay); read-only.

CONTEXT (scalar)
     The context in which zle was called to read a line; read-only.
     One of the values:
    start
          The start of a command line (at prompt PS1).

    cont
          A continuation to a command line (at prompt PS2).

    select
          In a select loop.

    vared
          Editing a variable in vared.


CURSOR (integer)
     The offset of the cursor, within the edit buffer.  This is in the
     range 0 to $#BUFFER, and is by definition equal to $#LBUFFER.
     Attempts to move the cursor outside the buffer will result in the
     cursor being moved to the appropriate end of the buffer.

CUTBUFFER (scalar)
     The last item to be cut using one of the `kill-' commands; the
     string which the next yank would insert in the line.  Later
     entries in the kill ring are in the array killring.  Note that the
     command `zle copy-region-as-kill STRING' can be used to set the
     text of the cut buffer from a shell function and cycle the kill
     ring in the same way as interactively killing text.

HISTNO (integer)
     The current history number.  Setting this has the same effect as
     moving up or down in the history to the corresponding history line.
     An attempt to set it is ignored if the line is not stored in the
     history.  Note this is not the same as the parameter HISTCMD,
     which always gives the number of the history line being added to
     the main shell's history.  HISTNO refers to the line being
     retrieved within zle.

KEYMAP (scalar)
     The name of the currently selected keymap; read-only.

KEYS (scalar)
     The keys typed to invoke this widget, as a literal string;
     read-only.

killring (array)
     The array of previously killed items, with the most recently
     killed first.  This gives the items that would be retrieved by a
     yank-pop in the same order.  Note, however, that the most recently
     killed item is in $CUTBUFFER; $killring shows the array of
     previous entries.

     The default size for the kill ring is eight, however the length
     may be changed by normal array operations.  Any empty string in
     the kill ring is ignored by the yank-pop command, hence the size
     of the array effectively sets the maximum length of the kill ring,
     while the number of non-zero strings gives the current length,
     both as seen by the user at the command line.

     

LASTSEARCH (scalar)
     The last search string used by an interactive search ; read-only.

LASTWIDGET (scalar)
     The name of the last widget that was executed; read-only.

LBUFFER (scalar)
     The part of the buffer that lies to the left of the cursor
     position.  If it is assigned to, only that part of the buffer is
     replaced, and the cursor remains between the new $LBUFFER and the
     old $RBUFFER.

MARK (integer)
     Like CURSOR, but for the mark.

NUMERIC (integer)
     The numeric argument. If no numeric argument was given, this
     parameter is unset. When this is set inside a widget function,
     builtin widgets called with the zle builtin command will use the
     value assigned. If it is unset inside a widget function, builtin
     widgets called behave as if no numeric argument was given.

PENDING (integer)
     The number of bytes pending for input, i.e. the number of bytes
     which have already been typed and can immediately be read. On
     systems where the shell is not able to get this information, this
     parameter will always have a value of zero.  Read-only.

PREBUFFER (scalar)
     In a multi-line input at the secondary prompt, this read-only
     parameter contains the contents of the lines before the one the
     cursor is currently in.

PREDISPLAY (scalar)
     Text to be displayed before the start of the editable text buffer.
     This does not have to be a complete line; to display a complete
     line, a newline must be appended explicitly.    The text is reset
     on each new invocation (but not recursive invocation) of zle.

POSTDISPLAY (scalar)
     Text to be displayed after the end of the editable text buffer.
     This does not have to be a complete line; to display a complete
     line, a newline must be prepended explicitly.  The text is reset
     on each new invocation (but not recursive invocation) of zle.

RBUFFER (scalar)
     The part of the buffer that lies to the right of the cursor
     position.  If it is assigned to, only that part of the buffer is
     replaced, and the cursor remains between the old $LBUFFER and the
     new $RBUFFER.

REGION_ACTIVE (integer)
     Indicates if the region is currently active.  It can be assigned 0
     or 1 to deactivate and activate the region respectively; *note
     Character Highlighting::.

region_highlight (array)
     Each element of this array may be set to a string that describes
     highlighting for an arbitrary region of the command line that will
     take effect the next time the command line is redisplayed.
     Highlighting of the non-editable parts of the command line in
     PREDISPLAY and POSTDISPLAY are possible, but note that the P flag
     is needed for character indexing to include PREDISPLAY.

     Each string consists of the following parts:


    Optionally, a `P' to signify that the start and end offset that
          follow include any string set by the PREDISPLAY special
          parameter; this is needed if the predisplay string itself is
          to be highlighted.  Whitespace may follow the `P'.

    A start offset in the same units as CURSOR, terminated by
          whitespace.

    An end offset in the same units as CURSOR, terminated by
          whitespace.

    A highlight specification in the same format as
          used for the contexts region or special in the parameter
          zle_highlight, *note Character Highlighting::.  Hence this
          should be a comma-separated list of any of the words bold,
          standout or underline.



     For example,


          region_highlight=("P0 20 bold")

     specifies that the first twenty characters of the text including
     any predisplay string should be highlighted in bold.

     Note that the effect of region_highlight is not saved and
     disappears as soon as the line is accepted.  The line editor makes
     no attempt to keep the highlighting effect synchronised with the
     line as it is edited; hence region highlighting is best limited to
     static effects within user widgets.

WIDGET (scalar)
     The name of the widget currently being executed; read-only.

WIDGETFUNC (scalar)
     The name of the shell function that implements a widget defined
     with either zle -N or zle -C.  In the former case, this is the
     second argument to the zle -N command that defined the widget, or
     the first argument if there was no second argument.  In the latter
     case this is the the third argument to the zle -C command that
     defined the widget.  Read-only.

WIDGETSTYLE (scalar)
     Describes the implementation behind the completion widget
     currently being executed; the second argument that followed zle -C
     when the widget was defined.  This is the name of a builtin
     completion widget.  For widgets defined with zle -N this is set to
     the empty string.  Read-only.



18.5.1 Special Widgets
----------------------

There are a few user-defined widgets which are special to the shell.
If they do not exist, no special action is taken.  The environment
provided is identical to that for any other editing widget.


zle-line-init
     Executed every time the line editor is started to read a new line
     of input.  The following example puts the line editor into vi
     command mode when it starts up.


          zle-line-init() { zle -K vicmd; }
          zle -N zle-line-init

     (The command inside the function sets the keymap directly; it is
     equivalent to zle vi-cmd-mode.)

zle-keymap-select
     Executed every time the keymap changes, i.e. the special parameter
     KEYMAP is set to a different value, while the line editor is
     active.  Initialising the keymap when the line editor starts does
     not cause the widget to be called.

     The value $KEYMAP within the function reflects the new keymap.  The
     old keymap is passed as the sole argument.

     This can been used for detecting switches between the vi command
     (vicmd) and insert (usually main) keymaps.



18.6 Standard Widgets
=====================

The following is a list of all the standard widgets, and their default
bindings in emacs mode, vi command mode and vi insert mode (the
`emacs', `vicmd' and `viins' keymaps, respectively).

Note that cursor keys are bound to movement keys in all three keymaps;
the shell assumes that the cursor keys send the key sequences reported
by the terminal-handling library (termcap or terminfo).  The key
sequences shown in the list are those based on the VT100, common on
many modern terminals, but in fact these are not necessarily bound.  In
the case of the viins keymap, the initial escape character of the
sequences serves also to return to the vicmd keymap: whether this
happens is determined by the KEYTIMEOUT parameter, see *note
Parameters::.

* Menu:

* Movement::
* History Control::
* Modifying Text::
* Arguments::
* Completion::
* Miscellaneous::


File: zsh.info,  Node: Movement,  Next: History Control,  Up: Zle Widgets

18.6.1 Movement
---------------


vi-backward-blank-word (unbound) (B) (unbound)
     Move backward one word, where a word is defined as a series of
     non-blank characters.

backward-char (^B ESC-[D) (unbound) (unbound)
     Move backward one character.

vi-backward-char (unbound) (^H h ^?) (ESC-[D)
     Move backward one character, without changing lines.

backward-word (ESC-B ESC-b) (unbound) (unbound)
     Move to the beginning of the previous word.

emacs-backward-word
     Move to the beginning of the previous word.

vi-backward-word (unbound) (b) (unbound)
     Move to the beginning of the previous word, vi-style.

beginning-of-line (^A) (unbound) (unbound)
     Move to the beginning of the line.  If already at the beginning of
     the line, move to the beginning of the previous line, if any.

vi-beginning-of-line
     Move to the beginning of the line, without changing lines.

end-of-line (^E) (unbound) (unbound)
     Move to the end of the line.  If already at the end of the line,
     move to the end of the next line, if any.

vi-end-of-line (unbound) ($) (unbound)
     Move to the end of the line.  If an argument is given to this
     command, the cursor will be moved to the end of the line (argument
     - 1) lines down.

vi-forward-blank-word (unbound) (W) (unbound)
     Move forward one word, where a word is defined as a series of
     non-blank characters.

vi-forward-blank-word-end (unbound) (E) (unbound)
     Move to the end of the current word, or, if at the end of the
     current word, to the end of the next word, where a word is defined
     as a series of non-blank characters.

forward-char (^F ESC-[C) (unbound) (unbound)
     Move forward one character.

vi-forward-char (unbound) (space l) (ESC-[C)
     Move forward one character.

vi-find-next-char (^X^F) (f) (unbound)
     Read a character from the keyboard, and move to the next
     occurrence of it in the line.

vi-find-next-char-skip (unbound) (t) (unbound)
     Read a character from the keyboard, and move to the position just
     before the next occurrence of it in the line.

vi-find-prev-char (unbound) (F) (unbound)
     Read a character from the keyboard, and move to the previous
     occurrence of it in the line.

vi-find-prev-char-skip (unbound) (T) (unbound)
     Read a character from the keyboard, and move to the position just
     after the previous occurrence of it in the line.

vi-first-non-blank (unbound) (^) (unbound)
     Move to the first non-blank character in the line.

vi-forward-word (unbound) (w) (unbound)
     Move forward one word, vi-style.

forward-word (ESC-F ESC-f) (unbound) (unbound)
     Move to the beginning of the next word.  The editor's idea of a
     word is specified with the WORDCHARS parameter.

emacs-forward-word
     Move to the end of the next word.

vi-forward-word-end (unbound) (e) (unbound)
     Move to the end of the next word.

vi-goto-column (ESC-|) (|) (unbound)
     Move to the column specified by the numeric argument.

vi-goto-mark (unbound) (`) (unbound)
     Move to the specified mark.

vi-goto-mark-line (unbound) (') (unbound)
     Move to beginning of the line containing the specified mark.

vi-repeat-find (unbound) (;) (unbound)
     Repeat the last vi-find command.

vi-rev-repeat-find (unbound) (,) (unbound)
     Repeat the last vi-find command in the opposite direction.



File: zsh.info,  Node: History Control,  Next: Modifying Text,  Prev: Movement,  Up: Zle Widgets

18.6.2 History Control
----------------------


beginning-of-buffer-or-history (ESC-<) (unbound) (unbound)
     Move to the beginning of the buffer, or if already there, move to
     the first event in the history list.

beginning-of-line-hist
     Move to the beginning of the line.  If already at the beginning of
     the buffer, move to the previous history line.

beginning-of-history
     Move to the first event in the history list.

down-line-or-history (^N ESC-[B) (j) (ESC-[B)
     Move down a line in the buffer, or if already at the bottom line,
     move to the next event in the history list.

vi-down-line-or-history (unbound) (+) (unbound)
     Move down a line in the buffer, or if already at the bottom line,
     move to the next event in the history list.  Then move to the
     first non-blank character on the line.

down-line-or-search
     Move down a line in the buffer, or if already at the bottom line,
     search forward in the history for a line beginning with the first
     word in the buffer.

     If called from a function by the zle command with arguments, the
     first argument is taken as the string for which to search, rather
     than the first word in the buffer.

down-history (unbound) (^N) (unbound)
     Move to the next event in the history list.

history-beginning-search-backward
     Search backward in the history for a line beginning with the
     current line up to the cursor.  This leaves the cursor in its
     original position.

end-of-buffer-or-history (ESC->) (unbound) (unbound)
     Move to the end of the buffer, or if already there, move to the
     last event in the history list.

end-of-line-hist
     Move to the end of the line.  If already at the end of the buffer,
     move to the next history line.

end-of-history
     Move to the last event in the history list.

vi-fetch-history (unbound) (G) (unbound)
     Fetch the history line specified by the numeric argument.  This
     defaults to the current history line (i.e. the one that isn't
     history yet).

history-incremental-search-backward (^R ^Xr) (unbound) (unbound)
     Search backward incrementally for a specified string.  The search
     is case-insensitive if the search string does not have uppercase
     letters and no numeric argument was given.  The string may begin
     with `^' to anchor the search to the beginning of the line.

     A restricted set of editing functions is available in the
     mini-buffer.  An interrupt signal, as defined by the stty setting,
     will stop the search and go back to the original line.  An
     undefined key will have the same effect. The supported functions
     are:


    accept-and-hold
    accept-and-infer-next-history
    accept-line
    accept-line-and-down-history
          Perform the usual function after exiting incremental search.
          The command line displayed is executed.

    backward-delete-char
    vi-backward-delete-char
          Back up one place in the search history.  If the search has
          been repeated this does not immediately erase a character in
          the minibuffer.

    backward-delete-word
    backward-kill-word
    vi-backward-kill-word
          Back up one character in the minibuffer; if multiple searches
          have been performed since the character was inserted the
          search history is rewound to the point just before the
          character was entered.  Hence this has the effect of repeating
          backward-delete-char.

    clear-screen
          Clear the screen, remaining in incremental search mode.

    history-incremental-search-backward
          Find the next occurrence of the contents of the mini-buffer.

    history-incremental-search-forward
          Invert the sense of the search.

    magic-space
          Inserts a non-magical space.

    quoted-insert
    vi-quoted-insert
          Quote the character to insert into the minibuffer.

    redisplay
          Redisplay the command line, remaining in incremental search
          mode.

    vi-cmd-mode
          Toggle between the `main' and `vicmd' keymaps; the `main'
          keymap (insert mode) will be selected initially.

    vi-repeat-search
    vi-rev-repeat-search
          Repeat the search.  The direction of the search is indicated
          in the mini-buffer.


     Any multi-character string that is not bound to one of the above
     functions will beep and interrupt the search, leaving the last
     found line in the buffer. Any single character that is not bound
     to one of the above functions, or self-insert or
     self-insert-unmeta, will have the same effect but the function
     will be executed.

     When called from a widget function by the zle command, the
     incremental search commands can take a string argument.  This will
     be treated as a string of keys, as for arguments to the bindkey
     command, and used as initial input for the command.  Any
     characters in the string which are unused by the incremental
     search will be silently ignored.  For example,


          zle history-incremental-search-backward forceps

     will search backwards for forceps, leaving the minibuffer
     containing the string `forceps'.

history-incremental-search-forward (^S ^Xs) (unbound) (unbound)
     Search forward incrementally for a specified string.  The search is
     case-insensitive if the search string does not have uppercase
     letters and no numeric argument was given.  The string may begin
     with `^' to anchor the search to the beginning of the line.  The
     functions available in the mini-buffer are the same as for
     history-incremental-search-backward.

history-incremental-pattern-search-backward
history-incremental-pattern-search-forward
     These widgets behave similarly to the corresponding widgets with
     no -pattern, but the search string typed by the user is treated as
     a pattern, respecting the current settings of the various options
     affecting pattern matching.  See *note Filename Generation:: for a
     description of patterns.  If no numeric argument was given
     lowercase letters in the search string may match uppercase letters
     in the history.  The string may begin with `^' to anchor the
     search to the beginning of the line.

     The prompt changes to indicate an invalid pattern; this may simply
     indicate the pattern is not yet complete.

     Note that only non-overlapping matches are reported, so an
     expression with wildcards may return fewer matches on a line than
     are visible by inspection.

history-search-backward (ESC-P ESC-p) (unbound) (unbound)
     Search backward in the history for a line beginning with the first
     word in the buffer.

     If called from a function by the zle command with arguments, the
     first argument is taken as the string for which to search, rather
     than the first word in the buffer.

vi-history-search-backward (unbound) (/) (unbound)
     Search backward in the history for a specified string.  The string
     may begin with `^' to anchor the search to the beginning of the
     line.

     A restricted set of editing functions is available in the
     mini-buffer.  An interrupt signal, as defined by the stty setting,
     will stop the search.  The functions available in the mini-buffer
     are: accept-line, backward-delete-char, vi-backward-delete-char,
     backward-kill-word, vi-backward-kill-word, clear-screen, redisplay,
     quoted-insert and vi-quoted-insert.

     vi-cmd-mode is treated the same as accept-line, and magic-space is
     treated as a space.  Any other character that is not bound to
     self-insert or self-insert-unmeta will beep and be ignored. If the
     function is called from vi command mode, the bindings of the
     current insert mode will be used.

     If called from a function by the zle command with arguments, the
     first argument is taken as the string for which to search, rather
     than the first word in the buffer.

history-search-forward (ESC-N ESC-n) (unbound) (unbound)
     Search forward in the history for a line beginning with the first
     word in the buffer.

     If called from a function by the zle command with arguments, the
     first argument is taken as the string for which to search, rather
     than the first word in the buffer.

vi-history-search-forward (unbound) (?) (unbound)
     Search forward in the history for a specified string.  The string
     may begin with `^' to anchor the search to the beginning of the
     line. The functions available in the mini-buffer are the same as
     for vi-history-search-backward.  Argument handling is also the same
     as for that command.

infer-next-history (^X^N) (unbound) (unbound)
     Search in the history list for a line matching the current one and
     fetch the event following it.

insert-last-word (ESC-_ ESC-.) (unbound) (unbound)
     Insert the last word from the previous history event at the cursor
     position.  If a positive numeric argument is given, insert that
     word from the end of the previous history event.  If the argument
     is zero or negative insert that word from the left (zero inserts
     the previous command word).  Repeating this command replaces the
     word just inserted with the last word from the history event prior
     to the one just used; numeric arguments can be used in the same
     way to pick a word from that event.

     When called from a shell function invoked from a user-defined
     widget, the command can take one to three arguments.  The first
     argument specifies a history offset which applies to successive
     calls to this widget: if is -1, the default behaviour is used,
     while if it is 1, successive calls will move forwards through the
     history.  The value 0 can be used to indicate that the history
     line examined by the previous execution of the command will be
     reexamined.  Note that negative numbers should be preceded with a
     `--' argument to avoid confusing them with options.

     If two arguments are given, the second specifies the word on the
     command line in normal array index notation (as a more natural
     alternative to the prefix argument).  Hence 1 is the first word,
     and -1 (the default) is the last word.

     If a third argument is given, its value is ignored, but it is used
     to signify that the history offset is relative to the current
     history line, rather than the one remembered after the previous
     invocations of insert-last-word.

     For example, the default behaviour of the command corresponds to


          zle insert-last-word -- -1 -1

     while the command


          zle insert-last-word -- -1 1 -

     always copies the first word of the line in the history
     immediately before the line being edited.  This has the side
     effect that later invocations of the widget will be relative to
     that line.

vi-repeat-search (unbound) (n) (unbound)
     Repeat the last vi history search.

vi-rev-repeat-search (unbound) (N) (unbound)
     Repeat the last vi history search, but in reverse.

up-line-or-history (^P ESC-[A) (k) (ESC-[A)
     Move up a line in the buffer, or if already at the top line, move
     to the previous event in the history list.

vi-up-line-or-history (unbound) (-) (unbound)
     Move up a line in the buffer, or if already at the top line, move
     to the previous event in the history list.  Then move to the first
     non-blank character on the line.

up-line-or-search
     Move up a line in the buffer, or if already at the top line,
     search backward in the history for a line beginning with the first
     word in the buffer.

     If called from a function by the zle command with arguments, the
     first argument is taken as the string for which to search, rather
     than the first word in the buffer.

up-history (unbound) (^P) (unbound)
     Move to the previous event in the history list.

history-beginning-search-forward
     Search forward in the history for a line beginning with the current
     line up to the cursor.  This leaves the cursor in its original
     position.



File: zsh.info,  Node: Modifying Text,  Next: Arguments,  Prev: History Control,  Up: Zle Widgets

18.6.3 Modifying Text
---------------------


vi-add-eol (unbound) (A) (unbound)
     Move to the end of the line and enter insert mode.

vi-add-next (unbound) (a) (unbound)
     Enter insert mode after the current cursor position, without
     changing lines.

backward-delete-char (^H ^?) (unbound) (unbound)
     Delete the character behind the cursor.

vi-backward-delete-char (unbound) (X) (^H)
     Delete the character behind the cursor, without changing lines.
     If in insert mode, this won't delete past the point where insert
     mode was last entered.

backward-delete-word
     Delete the word behind the cursor.

backward-kill-line
     Kill from the beginning of the line to the cursor position.

backward-kill-word (^W ESC-^H ESC-^?) (unbound) (unbound)
     Kill the word behind the cursor.

vi-backward-kill-word (unbound) (unbound) (^W)
     Kill the word behind the cursor, without going past the point
     where insert mode was last entered.

capitalize-word (ESC-C ESC-c) (unbound) (unbound)
     Capitalize the current word and move past it.

vi-change (unbound) (c) (unbound)
     Read a movement command from the keyboard, and kill from the
     cursor position to the endpoint of the movement.  Then enter
     insert mode.  If the command is vi-change, change the current line.

vi-change-eol (unbound) (C) (unbound)
     Kill to the end of the line and enter insert mode.

vi-change-whole-line (unbound) (S) (unbound)
     Kill the current line and enter insert mode.

copy-region-as-kill (ESC-W ESC-w) (unbound) (unbound)
     Copy the area from the cursor to the mark to the kill buffer.

     If called from a ZLE widget function in the form `zle
     copy-region-as-kill STRING' then STRING will be taken as the text
     to copy to the kill buffer.  The cursor, the mark and the text on
     the command line are not used in this case.

copy-prev-word (ESC-^_) (unbound) (unbound)
     Duplicate the word to the left of the cursor.

copy-prev-shell-word
     Like copy-prev-word, but the word is found by using shell parsing,
     whereas copy-prev-word looks for blanks. This makes a difference
     when the word is quoted and contains spaces.

vi-delete (unbound) (d) (unbound)
     Read a movement command from the keyboard, and kill from the
     cursor position to the endpoint of the movement.  If the command
     is vi-delete, kill the current line.

delete-char
     Delete the character under the cursor.

vi-delete-char (unbound) (x) (unbound)
     Delete the character under the cursor, without going past the end
     of the line.

delete-word
     Delete the current word.

down-case-word (ESC-L ESC-l) (unbound) (unbound)
     Convert the current word to all lowercase and move past it.

kill-word (ESC-D ESC-d) (unbound) (unbound)
     Kill the current word.

gosmacs-transpose-chars
     Exchange the two characters behind the cursor.

vi-indent (unbound) (>) (unbound)
     Indent a number of lines.

vi-insert (unbound) (i) (unbound)
     Enter insert mode.

vi-insert-bol (unbound) (I) (unbound)
     Move to the first non-blank character on the line and enter insert
     mode.

vi-join (^X^J) (J) (unbound)
     Join the current line with the next one.

kill-line (^K) (unbound) (unbound)
     Kill from the cursor to the end of the line.  If already on the
     end of the line, kill the newline character.

vi-kill-line (unbound) (unbound) (^U)
     Kill from the cursor back to wherever insert mode was last entered.

vi-kill-eol (unbound) (D) (unbound)
     Kill from the cursor to the end of the line.

kill-region
     Kill from the cursor to the mark.

kill-buffer (^X^K) (unbound) (unbound)
     Kill the entire buffer.

kill-whole-line (^U) (unbound) (unbound)
     Kill the current line.

vi-match-bracket (^X^B) (%) (unbound)
     Move to the bracket character (one of {}, () or []) that matches
     the one under the cursor.  If the cursor is not on a bracket
     character, move forward without going past the end of the line to
     find one, and then go to the matching bracket.

vi-open-line-above (unbound) (O) (unbound)
     Open a line above the cursor and enter insert mode.

vi-open-line-below (unbound) (o) (unbound)
     Open a line below the cursor and enter insert mode.

vi-oper-swap-case
     Read a movement command from the keyboard, and swap the case of
     all characters from the cursor position to the endpoint of the
     movement.  If the movement command is vi-oper-swap-case, swap the
     case of all characters on the current line.

overwrite-mode (^X^O) (unbound) (unbound)
     Toggle between overwrite mode and insert mode.

vi-put-before (unbound) (P) (unbound)
     Insert the contents of the kill buffer before the cursor.  If the
     kill buffer contains a sequence of lines (as opposed to
     characters), paste it above the current line.

vi-put-after (unbound) (p) (unbound)
     Insert the contents of the kill buffer after the cursor.  If the
     kill buffer contains a sequence of lines (as opposed to
     characters), paste it below the current line.

quoted-insert (^V) (unbound) (unbound)
     Insert the next character typed into the buffer literally.  An
     interrupt character will not be inserted.

vi-quoted-insert (unbound) (unbound) (^Q ^V)
     Display a `^' at the cursor position, and insert the next
     character typed into the buffer literally.  An interrupt character
     will not be inserted.

quote-line (ESC-') (unbound) (unbound)
     Quote the current line; that is, put a `'' character at the
     beginning and the end, and convert all `'' characters to `'\'''.

quote-region (ESC-") (unbound) (unbound)
     Quote the region from the cursor to the mark.

vi-replace (unbound) (R) (unbound)
     Enter overwrite mode.

vi-repeat-change (unbound) (.) (unbound)
     Repeat the last vi mode text modification.  If a count was used
     with the modification, it is remembered.  If a count is given to
     this command, it overrides the remembered count, and is remembered
     for future uses of this command.  The cut buffer specification is
     similarly remembered.

vi-replace-chars (unbound) (r) (unbound)
     Replace the character under the cursor with a character read from
     the keyboard.

self-insert (printable characters) (unbound) (printable characters and some control characters)
     Insert a character into the buffer at the cursor position.

self-insert-unmeta (ESC-^I ESC-^J ESC-^M) (unbound) (unbound)
     Insert a character into the buffer after stripping the meta bit
     and converting ^M to ^J.

vi-substitute (unbound) (s) (unbound)
     Substitute the next character(s).

vi-swap-case (unbound) (~) (unbound)
     Swap the case of the character under the cursor and move past it.

transpose-chars (^T) (unbound) (unbound)
     Exchange the two characters to the left of the cursor if at end of
     line, else exchange the character under the cursor with the
     character to the left.

transpose-words (ESC-T ESC-t) (unbound) (unbound)
     Exchange the current word with the one before it.

vi-unindent (unbound) (<) (unbound)
     Unindent a number of lines.

up-case-word (ESC-U ESC-u) (unbound) (unbound)
     Convert the current word to all caps and move past it.

yank (^Y) (unbound) (unbound)
     Insert the contents of the kill buffer at the cursor position.

yank-pop (ESC-y) (unbound) (unbound)
     Remove the text just yanked, rotate the kill-ring (the history of
     previously killed text) and yank the new top.  Only works following
     yank or yank-pop.

vi-yank (unbound) (y) (unbound)
     Read a movement command from the keyboard, and copy the region
     from the cursor position to the endpoint of the movement into the
     kill buffer.  If the command is vi-yank, copy the current line.

vi-yank-whole-line (unbound) (Y) (unbound)
     Copy the current line into the kill buffer.

vi-yank-eol
     Copy the region from the cursor position to the end of the line
     into the kill buffer.  Arguably, this is what Y should do in vi,
     but it isn't what it actually does.



File: zsh.info,  Node: Arguments,  Next: Completion,  Prev: Modifying Text,  Up: Zle Widgets

18.6.4 Arguments
----------------


digit-argument (ESC-0..ESC-9) (1-9) (unbound)
     Start a new numeric argument, or add to the current one.  See also
     vi-digit-or-beginning-of-line.  This only works if bound to a key
     sequence ending in a decimal digit.

     Inside a widget function, a call to this function treats the last
     key of the key sequence which called the widget as the digit.

neg-argument (ESC--) (unbound) (unbound)
     Changes the sign of the following argument.

universal-argument
     Multiply the argument of the next command by 4.  Alternatively, if
     this command is followed by an integer (positive or negative), use
     that as the argument for the next command.  Thus digits cannot be
     repeated using this command.  For example, if this command occurs
     twice, followed immediately by forward-char, move forward sixteen
     spaces; if instead it is followed by -2, then forward-char, move
     backward two spaces.

     Inside a widget function, if passed an argument, i.e. `zle
     universal-argument NUM', the numerical argument will be set to
     NUM; this is equivalent to `NUMERIC=NUM'.

argument-base
     Use the existing numeric argument as a numeric base, which must be
     in the range 2 to 36 inclusive.  Subsequent use of digit-argument
     and universal-argument will input a new prefix in the given base.
     The usual hexadecimal convention is used: the letter a or A
     corresponds to 10, and so on.  Arguments in bases requiring digits
     from 10 upwards are more conveniently input with
     universal-argument, since ESC-a etc. are not usually bound to
     digit-argument.

     The function can be used with a command argument inside a
     user-defined widget.  The following code sets the base to 16 and
     lets the user input a hexadecimal argument until a key out of the
     digit range is typed:


          zle argument-base 16
          zle universal-argument



File: zsh.info,  Node: Completion,  Next: Miscellaneous,  Prev: Arguments,  Up: Zle Widgets

18.6.5 Completion
-----------------


accept-and-menu-complete
     In a menu completion, insert the current completion into the
     buffer, and advance to the next possible completion.

complete-word
     Attempt completion on the current word.

delete-char-or-list (^D) (unbound) (unbound)
     Delete the character under the cursor.  If the cursor is at the
     end of the line, list possible completions for the current word.

expand-cmd-path
     Expand the current command to its full pathname.

expand-or-complete (TAB) (unbound) (TAB)
     Attempt shell expansion on the current word.  If that fails,
     attempt completion.

expand-or-complete-prefix
     Attempt shell expansion on the current word up to cursor.

expand-history (ESC-space ESC-!) (unbound) (unbound)
     Perform history expansion on the edit buffer.

expand-word (^X*) (unbound) (unbound)
     Attempt shell expansion on the current word.

list-choices (ESC-^D) (^D =) (^D)
     List possible completions for the current word.

list-expand (^Xg ^XG) (^G) (^G)
     List the expansion of the current word.

magic-space
     Perform history expansion and insert a space into the buffer.
     This is intended to be bound to space.

menu-complete
     Like complete-word, except that menu completion is used.  See the
     MENU_COMPLETE option.

menu-expand-or-complete
     Like expand-or-complete, except that menu completion is used.

reverse-menu-complete
     Perform menu completion, like menu-complete, except that if a menu
     completion is already in progress, move to the _previous_
     completion rather than the next.

end-of-list
     When a previous completion displayed a list below the prompt, this
     widget can be used to move the prompt below the list.



File: zsh.info,  Node: Miscellaneous,  Prev: Completion,  Up: Zle Widgets

18.6.6 Miscellaneous
--------------------


accept-and-hold (ESC-A ESC-a) (unbound) (unbound)
     Push the contents of the buffer on the buffer stack and execute it.

accept-and-infer-next-history
     Execute the contents of the buffer.  Then search the history list
     for a line matching the current one and push the event following
     onto the buffer stack.

accept-line (^J ^M) (^J ^M) (^J ^M)
     Finish editing the buffer.  Normally this causes the buffer to be
     executed as a shell command.

accept-line-and-down-history (^O) (unbound) (unbound)
     Execute the current line, and push the next history event on the
     the buffer stack.

auto-suffix-remove
     If the previous action added a suffix (space, slash, etc.) to the
     word on the command line, remove it.  Otherwise do nothing.
     Removing the suffix ends any active menu completion or menu
     selection.

     This widget is intended to be called from user-defined widgets to
     enforce a desired suffix-removal behavior.

auto-suffix-retain
     If the previous action added a suffix (space, slash, etc.) to the
     word on the command line, force it to be preserved.  Otherwise do
     nothing.  Retaining the suffix ends any active menu completion or
     menu selection.

     This widget is intended to be called from user-defined widgets to
     enforce a desired suffix-preservation behavior.

beep
     Beep, unless the BEEP option is unset.

vi-cmd-mode (^X^V) (unbound) (^[)
     Enter command mode; that is, select the `vicmd' keymap.  Yes, this
     is bound by default in emacs mode.

vi-caps-lock-panic
     Hang until any lowercase key is pressed.  This is for vi users
     without the mental capacity to keep track of their caps lock key
     (like the author).

clear-screen (^L ESC-^L) (^L) (^L)
     Clear the screen and redraw the prompt.

describe-key-briefly
     Reads a key sequence, then prints the function bound to that
     sequence.

exchange-point-and-mark (^X^X) (unbound) (unbound)
     Exchange the cursor position (point) with the position of the mark.
     Unless a negative prefix argument is given, the region between
     point and mark is activated so that it can be highlighted.  If a
     zero prefix argument is given, the region is activated but point
     and mark are not swapped.

execute-named-cmd (ESC-x) (unbound) (unbound)
     Read the name of an editor command and execute it.  A restricted
     set of editing functions is available in the mini-buffer.  An
     interrupt signal, as defined by the stty setting, will abort the
     function. The allowed functions are: backward-delete-char,
     vi-backward-delete-char, clear-screen, redisplay, quoted-insert,
     vi-quoted-insert, backward-kill-word, vi-backward-kill-word,
     kill-whole-line, vi-kill-line, backward-kill-line, list-choices,
     delete-char-or-list, complete-word, accept-line,
     expand-or-complete and expand-or-complete-prefix.

     kill-region kills the last word, and vi-cmd-mode is treated the
     same as accept-line.  The space and tab characters, if not bound
     to one of these functions, will complete the name and then list the
     possibilities if the AUTO_LIST option is set.  Any other character
     that is not bound to self-insert or self-insert-unmeta will beep
     and be ignored.  The bindings of the current insert mode will be
     used.

     Currently this command may not be redefined or called by name.

execute-last-named-cmd (ESC-z) (unbound) (unbound)
     Redo the last function executed with execute-named-cmd.

     Currently this command may not be redefined or called by name.

get-line (ESC-G ESC-g) (unbound) (unbound)
     Pop the top line off the buffer stack and insert it at the cursor
     position.

pound-insert (unbound) (#) (unbound)
     If there is no # character at the beginning of the buffer, add one
     to the beginning of each line.  If there is one, remove a # from
     each line that has one.  In either case, accept the current line.
     The INTERACTIVE_COMMENTS option must be set for this to have any
     usefulness.

vi-pound-insert
     If there is no # character at the beginning of the current line,
     add one.  If there is one, remove it.  The INTERACTIVE_COMMENTS
     option must be set for this to have any usefulness.

push-input
     Push the entire current multiline construct onto the buffer stack
     and return to the top-level (PS1) prompt.  If the current parser
     construct is only a single line, this is exactly like push-line.
     Next time the editor starts up or is popped with get-line, the
     construct will be popped off the top of the buffer stack and loaded
     into the editing buffer.

push-line (^Q ESC-Q ESC-q) (unbound) (unbound)
     Push the current buffer onto the buffer stack and clear the buffer.
     Next time the editor starts up, the buffer will be popped off the
     top of the buffer stack and loaded into the editing buffer.

push-line-or-edit
     At the top-level (PS1) prompt, equivalent to push-line.  At a
     secondary (PS2) prompt, move the entire current multiline
     construct into the editor buffer.  The latter is equivalent to
     push-input followed by get-line.

read-command
     Only useful from a user-defined widget.  A keystroke is read just
     as in normal operation, but instead of the command being executed
     the name of the command that would be executed is stored in the
     shell parameter REPLY.  This can be used as the argument of a
     future zle command.  If the key sequence is not bound, status 1 is
     returned; typically, however, REPLY is set to undefined-key to
     indicate a useless key sequence.

recursive-edit
     Only useful from a user-defined widget.  At this point in the
     function, the editor regains control until one of the standard
     widgets which would normally cause zle to exit (typically an
     accept-line caused by hitting the return key) is executed.
     Instead, control returns to the user-defined widget.  The status
     returned is non-zero if the return was caused by an error, but the
     function still continues executing and hence may tidy up.  This
     makes it safe for the user-defined widget to alter the command
     line or key bindings temporarily.

     The following widget, caps-lock, serves as an example.
          self-insert-ucase() {
            LBUFFER+=${(U)KEYS[-1]}
          }

          integer stat

          zle -N self-insert self-insert-ucase
          zle -A caps-lock save-caps-lock
          zle -A accept-line caps-lock

          zle recursive-edit
          stat=$?

          zle -A .self-insert self-insert
          zle -A save-caps-lock caps-lock
          zle -D save-caps-lock

          (( stat )) && zle send-break

          return $stat
     This causes typed letters to be inserted capitalised until either
     accept-line (i.e. typically the return key) is typed or the
     caps-lock widget is invoked again; the later is handled by saving
     the old definition of caps-lock as save-caps-lock and then
     rebinding it to invoke accept-line.  Note that an error from the
     recursive edit is detected as a non-zero return status and
     propagated by using the send-break widget.

redisplay (unbound) (^R) (^R)
     Redisplays the edit buffer.

reset-prompt (unbound) (unbound) (unbound)
     Force the prompts on both the left and right of the screen to be
     re-expanded, then redisplay the edit buffer.  This reflects
     changes both to the prompt variables themselves and changes in the
     expansion of the values (for example, changes in time or
     directory, or changes to the value of variables referred to by the
     prompt).

     Otherwise, the prompt is only expanded each time zle starts, and
     when the display as been interrupted by output from another part
     of the shell (such as a job notification) which causes the command
     line to be reprinted.

send-break (^G ESC-^G) (unbound) (unbound)
     Abort the current editor function, e.g. execute-named-command, or
     the editor itself, e.g. if you are in vared. Otherwise abort the
     parsing of the current line.

run-help (ESC-H ESC-h) (unbound) (unbound)
     Push the buffer onto the buffer stack, and execute the command
     `run-help CMD', where CMD is the current command.  run-help is
     normally aliased to man.

vi-set-buffer (unbound) (") (unbound)
     Specify a buffer to be used in the following command.  There are
     35 buffers that can be specified: the 26 `named' buffers "a to "z
     and the nine `queued' buffers "1 to "9.  The named buffers can also
     be specified as "A to "Z.

     When a buffer is specified for a cut command, the text being cut
     replaces the previous contents of the specified buffer.  If a
     named buffer is specified using a capital, the newly cut text is
     appended to the buffer instead of overwriting it.

     If no buffer is specified for a cut command, "1 is used, and the
     contents of "1 to "8 are each shifted along one buffer; the
     contents of "9 is lost.

vi-set-mark (unbound) (m) (unbound)
     Set the specified mark at the cursor position.

set-mark-command (^@) (unbound) (unbound)
     Set the mark at the cursor position.  If called with a negative
     prefix argument, do not set the mark but deactivate the region so
     that it is no longer highlighted (it is still usable for other
     purposes).  Otherwise the region is marked as active.

spell-word (ESC-$ ESC-S ESC-s) (unbound) (unbound)
     Attempt spelling correction on the current word.

undefined-key
     This command is executed when a key sequence that is not bound to
     any command is typed.  By default it beeps.

undo (^_ ^Xu ^X^U) (unbound) (unbound)
     Incrementally undo the last text modification.

redo
     Incrementally redo undone text modifications.

vi-undo-change (unbound) (u) (unbound)
     Undo the last text modification.  If repeated, redo the
     modification.

what-cursor-position (^X=) (unbound) (unbound)
     Print the character under the cursor, its code as an octal,
     decimal and hexadecimal number, the current cursor position within
     the buffer and the column of the cursor in the current line.

where-is
     Read the name of an editor command and and print the listing of key
     sequences that invoke the specified command.

which-command (ESC-?) (unbound) (unbound)
     Push the buffer onto the buffer stack, and execute the command
     `which-command CMD'. where CMD is the current command.
     which-command is normally aliased to WHENCE.

vi-digit-or-beginning-of-line (unbound) (0) (unbound)
     If the last command executed was a digit as part of an argument,
     continue the argument.  Otherwise, execute vi-beginning-of-line.




File: zsh.info,  Node: Character Highlighting,  Prev: Zle Widgets,  Up: Zsh Line Editor

18.7 Character Highlighting
===========================

The line editor has the ability to highlight characters or regions of
the line that have a particular significance.  This is controlled by
the array parameter zle_highlight, if it has been set by the user.

If the parameter contains the single entry none all highlighting is
turned off.  Note the parameter is still expected to be an array.

Otherwise each entry of the array should consist of a word indicating a
context for highlighting, then a colon, then a comma-separated list of
the types of highlighting to apply in that context.

The contexts available for highlighting are the following:


default
     Any text within the command line not affected by any other
     highlighting.  Text outside the editable area of the command line
     is not affected.

isearch
     When one of the incremental history search widgets is active, the
     area of the command line matched by the search string or pattern.

region
     The region between the cursor (point) and the mark as set with
     set-mark-command.  The region is only highlighted if it is active,
     which is the case if set-mark-command or exchange-point-and-mark
     has been called and the line has not been subsequently modified.
     The region can be deactivated by calling set-mark-command with a
     negative prefix argument, or reactivated by calling
     exchange-point-and-mark with a zero prefix argument.  Note that
     whether or not the region is active has no effect on its use
     within widgets, it simply determines whether it is highlighted.

special
     Individual characters that have no direct printable representation
     but are shown in a special manner by the line editor.  These
     characters are described below.


zle_highlight may contain additional fields for controlling how
terminal sequences to change colours are output.  Each of the following
is followed by a colon and a string in the same form as for key
bindings.  This will not be necessary for the vast majority of
terminals as the defaults shown in parentheses are widely used.


fg_start_code (\e[3)
     The start of the escape sequence for the foreground colour.  This
     is followed by an ASCII digit representing the colour.

fg_default_code (9)
     The number to use instead of the colour to reset the default
     foreground colour.

fg_end_code (m)
     The end of the escape sequence for the foreground colour.

bg_start_code (\e[4)
     The start of the escape sequence for the background colour.  This
     is followed by an ASCII digit representing the colour.

bg_default_code (9)
     The number to use instead of the colour to reset the default
     background colour.

bg_end_code (m)
     The end of the escape sequence for the background colour.


The available types of highlighting are the following.  Note that not
all types of highlighting are available on all terminals:


none
     No highlighting is applied to the given context.  It is not useful
     for this to appear with other types of highlighting; it is used to
     override a default.

fg=COLOUR
     The foreground colour should be set to COLOUR, a decimal integer
     or the name of one of the eight most widely-supported colours.

     Not all terminals support this and, of those that do, not all
     provide facilities to test the support, hence the user should
     decide based on the terminal type.  Most terminals support the
     colours black, red, green, yellow, blue, magenta, cyan and white,
     which can be set by name.  In addition. default may be used to set
     the terminal's default foreground colour.  Abbreviations are
     allowed; b or bl selects black.  Some terminals may generate
     additional colours if the bold attribute is also present.

     On recent terminals and on systems with an up-to-date terminal
     database the number of colours supported may be tested by the
     command `echotc Co'; if this succeeds, it indicates a limit on the
     number of colours which will be enforced by the line editor.  The
     number of colours is in any case limited to 256 (i.e. the range 0
     to 255).

     Colour is also known as color.

bg=COLOUR
     The background colour should be set to COLOUR.  This works
     similarly to the foreground colour, except the background is not
     usually affected by the bold attribute.

bold
     The characters in the given context are shown in a bold font.

standout
     The characters in the given context are shown in the terminal's
     standout mode.  The actual effect is specific to the terminal; on
     many terminals it is inverse video.  On some such terminals, where
     the cursor does not blink it appears with standout mode negated,
     making it less than clear where the cursor actually is.  On such
     terminals one of the other effects may be preferable for
     highlighting the region and matched search string.

underline
     The characters in the given context are shown underlined.  Some
     terminals show the foreground in a different colour instead; in
     this case whitespace will not be highlighted.


The characters described above as `special' are as follows.  The
formatting described here is used irrespective of whether the characters
are highlighted:


ASCII control characters
     Control characters in the ASCII range are shown as `^' followed by
     the base character.

Unprintable multibyte characters
     This item applies to control characters not in the ASCII range,
     plus other characters as follows.  If the MULTIBYTE option is in
     effect, multibyte characters not in the ASCII character set that
     are reported as having zero width are treated as combining
     characters when the option COMBINING_CHARS is on.  If the option
     is off, or if a character appears where a combining character is
     not valid, the character is treated as unprintable.

     Unprintable multibyte characters are shown as a hexadecimal number
     between angle brackets.  The number is the code point of the
     character in the wide character set; this may or may not be
     Unicode, depending on the operating system.


If zle_highlight is not set or no value applies to a particular
context, the defaults applied are equivalent to


     zle_highlight=(region:standout special:standout
     isearch:underline)

i.e. both the region and special characters are shown in standout mode.

Within widgets, arbitrary regions may be highlighted by setting the
special array parameter region_highlight; see *note Zle Widgets::.




File: zsh.info,  Node: Completion Widgets,  Next: Completion System,  Prev: Zsh Line Editor,  Up: Top

19 Completion Widgets
*********************



19.1 Description
================

The shell's programmable completion mechanism can be manipulated in two
ways; here the low-level features supporting the newer, function-based
mechanism are defined.  A complete set of shell functions based on these
features is described in the next chapter, *note Completion System::,
and users with no interest in adding to that system (or, potentially,
writing their own -- see dictionary entry for `hubris') should skip the
current section.  The older system based on the compctl builtin command
is described in *note Completion Using compctl::.

Completion widgets are defined by the -C option to the zle builtin
command provided by the zsh/zle module (see *note The zsh/zle
Module::). For example,


     zle -C complete expand-or-complete completer

defines a widget named `complete'.  The second argument is the name of
any of the builtin widgets that handle completions: complete-word,
expand-or-complete, expand-or-complete-prefix, menu-complete,
menu-expand-or-complete, reverse-menu-complete, list-choices, or
delete-char-or-list.  Note that this will still work even if the widget
in question has been re-bound.

When this newly defined widget is bound to a key using the bindkey
builtin command defined in the zsh/zle module (*note Zsh Line
Editor::), typing that key will call the shell function `completer'.
This function is responsible for generating the possible matches using
the builtins described below.  As with other ZLE widgets, the function
is called with its standard input closed.

Once the function returns, the completion code takes over control again
and treats the matches in the same manner as the specified builtin
widget, in this case expand-or-complete.



* Menu:

* Completion Special Parameters::
* Completion Builtin Commands::
* Completion Condition Codes::
* Completion Matching Control::
* Completion Widget Example::



File: zsh.info,  Node: Completion Special Parameters,  Next: Completion Builtin Commands,  Up: Completion Widgets

19.2 Completion Special Parameters
==================================

Inside completion widgets, and any functions called from them, some
parameters have special meaning; outside these functions they are not
special to the shell in any way.  These parameters are used to pass
information between the completion code and the completion widget. Some
of the builtin commands and the condition codes use or change the
current values of these parameters.  Any existing values will be hidden
during execution of completion widgets; except for compstate, the
parameters are reset on each function exit (including nested function
calls from within the completion widget) to the values they had when
the function was entered.


CURRENT
     This is the number of the current word, i.e. the word the cursor is
     currently on in the words array.  Note that this value is only
     correct if the ksharrays option is not set.

IPREFIX
     Initially this will be set to the empty string.  This parameter
     functions like PREFIX; it contains a string which precedes the one
     in PREFIX and is not considered part of the list of matches.
     Typically, a string is transferred from the beginning of PREFIX to
     the end of IPREFIX, for example:


          IPREFIX=${PREFIX%%\=*}=
          PREFIX=${PREFIX#*=}

     causes the part of the prefix up to and including the first equal
     sign not to be treated as part of a matched string.  This can be
     done automatically by the compset builtin, see below.

ISUFFIX
     As IPREFIX, but for a suffix that should not be considered part of
     the matches; note that the ISUFFIX string follows the SUFFIX
     string.

PREFIX
     Initially this will be set to the part of the current word from the
     beginning of the word up to the position of the cursor; it may be
     altered to give a common prefix for all matches.

QIPREFIX
     This parameter is read-only and contains the quoted string up to
     the word being completed. E.g. when completing `"foo', this
     parameter contains the double quote. If the -q option of compset
     is used (see below), and the original string was `"foo bar' with
     the cursor on the `bar', this parameter contains `"foo '.

QISUFFIX
     Like QIPREFIX, but containing the suffix.

SUFFIX
     Initially this will be set to the part of the current word from the
     cursor position to the end; it may be altered to give a common
     suffix for all matches.  It is most useful when the option
     COMPLETE_IN_WORD is set, as otherwise the whole word on the
     command line is treated as a prefix.

compstate
     This is an associative array with various keys and values that the
     completion code uses to exchange information with the completion
     widget.  The keys are:


    all_quotes
          The -q option of the compset builtin command (see below)
          allows a quoted string to be broken into separate words; if
          the cursor is on one of those words, that word will be
          completed, possibly invoking `compset -q' recursively.  With
          this key it is possible to test the types of quoted strings
          which are currently broken into parts in this fashion.  Its
          value contains one character for each quoting level.  The
          characters are a single quote or a double quote for strings
          quoted with these characters, a dollars sign for strings
          quoted with $'...' and a backslash for strings not starting
          with a quote character.  The first character in the value
          always corresponds to the innermost quoting level.

    context
          This will be set by the completion code to the overall context
          in which completion is attempted. Possible values are:


         array_value
               when completing inside the value of an array parameter
               assignment; in this case the words array contains the
               words inside the parentheses.

         brace_parameter
               when completing the name of a parameter in a parameter
               expansion beginning with ${.

         assign_parameter
               when completing the name of a parameter in a parameter
               assignment.

         command
               when completing for a normal command (either in command
               position or for an argument of the command).

         condition
               when completing inside a `[[...]]' conditional
               expression; in this case the words array contains only
               the words inside the conditional expression.

         math
               when completing in a mathematical environment such as a
               `((...))' construct.

         parameter
               when completing the name of a parameter in a parameter
               expansion beginning with $ but not ${.

         redirect
               when completing after a redirection operator.

         subscript
               when completing inside a parameter subscript.

         value
               when completing the value of a parameter assignment.


    exact
          Controls the behaviour when the REC_EXACT option is set.  It
          will be set to accept if an exact match would be accepted,
          and will be unset otherwise.

          If it was set when at least one match equal to the string on
          the line was generated, the match is accepted.

    exact_string
          The string of an exact match if one was found, otherwise
          unset.

    ignored
          The number of words that were ignored because they matched
          one of the patterns given with the -F option to the compadd
          builtin command.

    insert
          This controls the manner in which a match is inserted into
          the command line.  On entry to the widget function, if it is
          unset the command line is not to be changed; if set to
          unambiguous, any prefix common to all matches is to be
          inserted; if set to automenu-unambiguous, the common prefix
          is to be inserted and the next invocation of the completion
          code may start menu completion (due to the AUTO_MENU option
          being set); if set to menu or automenu menu completion will
          be started for the matches currently generated (in the latter
          case this will happen because the AUTO_MENU is set). The
          value may also contain the string `tab' when the completion
          code would normally not really do completion, but only insert
          the TAB character.

          On exit it may be set to any of the values above (where
          setting it to the empty string is the same as unsetting it),
          or to a number, in which case the match whose number is given
          will be inserted into the command line.  Negative numbers
          count backward from the last match (with `-1' selecting the
          last match) and out-of-range values are wrapped around, so
          that a value of zero selects the last match and a value one
          more than the maximum selects the first. Unless the value of
          this key ends in a space, the match is inserted as in a menu
          completion, i.e. without automatically appending a space.

          Both menu and automenu may also specify the the number of the
          match to insert, given after a colon.  For example, `menu:2'
          says to start menu completion, beginning with the second
          match.

          Note that a value containing the substring `tab' makes the
          matches generated be ignored and only the TAB be inserted.

          Finally, it may also be set to all, which makes all matches
          generated be inserted into the line.

    insert_positions
          When the completion system inserts an unambiguous string into
          the line, there may be multiple places where characters are
          missing or where the character inserted differs from at least
          one match.  The value of this key contains a colon separated
          list of all these positions, as indexes into the command line.

    last_prompt
          If this is set to a non-empty string for every match added,
          the completion code will move the cursor back to the previous
          prompt after the list of completions has been displayed.
          Initially this is set or unset according to the
          ALWAYS_LAST_PROMPT option.

    list
          This controls whether or how the list of matches will be
          displayed.  If it is unset or empty they will never be
          listed; if its value begins with list, they will always be
          listed; if it begins with autolist or ambiguous, they will be
          listed when the AUTO_LIST or LIST_AMBIGUOUS options
          respectively would normally cause them to be.

          If the substring force appears in the value, this makes the
          list be shown even if there is only one match. Normally, the
          list would be shown only if there are at least two matches.

          The value contains the substring packed if the LIST_PACKED
          option is set. If this substring is given for all matches
          added to a group, this group will show the LIST_PACKED
          behavior. The same is done for the LIST_ROWS_FIRST option
          with the substring rows.

          Finally, if the value contains the string explanations, only
          the explanation strings, if any, will be listed and if it
          contains messages, only the messages (added with the -x
          option of compadd) will be listed.  If it contains both
          explanations and messages both kinds of explanation strings
          will be listed.  It will be set appropriately on entry to a
          completion widget and may be changed there.

    list_lines
          This gives the number of lines that are needed to display the
          full list of completions.  Note that to calculate the total
          number of lines to display you need to add the number of
          lines needed for the command line to this value, this is
          available as the value of the BUFFERLINES special parameter.

    list_max
          Initially this is set to the value of the LISTMAX parameter.
          It may be set to any other value; when the widget exits this
          value will be used in the same way as the value of LISTMAX.

    nmatches
          The number of matches generated and accepted by the
          completion code so far.

    old_insert
          On entry to the widget this will be set to the number of the
          match of an old list of completions that is currently
          inserted into the command line. If no match has been
          inserted, this is unset.

          As with old_list, the value of this key will only be used if
          it is the string keep. If it was set to this value by the
          widget and there was an old match inserted into the command
          line, this match will be kept and if the value of the insert
          key specifies that another match should be inserted, this
          will be inserted after the old one.

    old_list
          This is set to yes if there is still a valid list of
          completions from a previous completion at the time the widget
          is invoked.  This will usually be the case if and only if the
          previous editing operation was a completion widget or one of
          the builtin completion functions.  If there is a valid list
          and it is also currently shown on the screen, the value of
          this key is shown.

          After the widget has exited the value of this key is only
          used if it was set to keep.  In this case the completion code
          will continue to use this old list.  If the widget generated
          new matches, they will not be used.

    parameter
          The name of the parameter when completing in a subscript or
          in the value of a parameter assignment.

    pattern_insert
          Normally this is set to menu, which specifies that menu
          completion will be used whenever a set of matches was
          generated using pattern matching.  If it is set to any other
          non-empty string by the user and menu completion is not
          selected by other option settings, the code will instead
          insert any common prefix for the generated matches as with
          normal completion.

    pattern_match
          Locally controls the behaviour given by the GLOB_COMPLETE
          option.  Initially it is set to `*' if and only if the option
          is set.  The completion widget may set it to this value, to
          an empty string (which has the same effect as unsetting it),
          or to any other non-empty string.  If it is non-empty,
          unquoted metacharacters on the command line will be treated
          as patterns; if it is `*', then additionally a wildcard `*'
          is assumed at the cursor position; if it is empty or unset,
          metacharacters will be treated literally.

          Note that the matcher specifications given to the compadd
          builtin command are not used if this is set to a non-empty
          string.

    quote
          When completing inside quotes, this contains the quotation
          character (i.e. either a single quote, a double quote, or a
          backtick).  Otherwise it is unset.

    quoting
          When completing inside single quotes, this is set to the
          string single; inside double quotes, the string double;
          inside backticks, the string backtick.  Otherwise it is unset.

    redirect
          The redirection operator when completing in a redirection
          position, i.e. one of <, >, etc.

    restore
          This is set to auto before a function is entered, which
          forces the special parameters mentioned above (words,
          CURRENT, PREFIX, IPREFIX, SUFFIX, and ISUFFIX) to be restored
          to their previous values when the function exits.   If a
          function unsets it or sets it to any other string, they will
          not be restored.

    to_end
          Specifies the occasions on which the cursor is moved to the
          end of a string when a match is inserted.  On entry to a
          widget function, it may be single if this will happen when a
          single unambiguous match was inserted or match if it will
          happen any time a match is inserted (for example, by menu
          completion; this is likely to be the effect of the
          ALWAYS_TO_END option).

          On exit, it may be set to single as above.  It may also be
          set to always, or to the empty string or unset; in those
          cases the cursor will be moved to the end of the string
          always or never respectively.  Any other string is treated as
          match.

    unambiguous
          This key is read-only and will always be set to the common
          (unambiguous) prefix the completion code has generated for
          all matches added so far.

    unambiguous_cursor
          This gives the position the cursor would be placed at if the
          common prefix in the unambiguous key were inserted, relative
          to the value of that key. The cursor would be placed before
          the character whose index is given by this key.

    unambiguous_positions
          This contains all positions where characters in the
          unambiguous string are missing or where the character
          inserted differs from at least one of the matches.  The
          positions are given as indexes into the string given by the
          value of the unambiguous key.

    vared
          If completion is called while editing a line using the vared
          builtin, the value of this key is set to the name of the
          parameter given as an argument to vared.  This key is only
          set while a vared command is active.


words
     This array contains the words present on the command line
     currently being edited.




File: zsh.info,  Node: Completion Builtin Commands,  Next: Completion Condition Codes,  Prev: Completion Special Parameters,  Up: Completion Widgets

19.3 Completion Builtin Commands
================================


compadd [ -akqQfenUld12C ] [ -F ARRAY ]
[ -P PREFIX ] [ -S SUFFIX ]
[ -p HIDDEN-PREFIX ] [ -s HIDDEN-SUFFIX ]
[ -i IGNORED-PREFIX ] [ -I IGNORED-SUFFIX ]
[ -W FILE-PREFIX ] [ -d ARRAY ]
[ -J NAME ] [ -V NAME ] [ -X EXPLANATION ] [ -x MESSAGE ]
[ -r REMOVE-CHARS ] [ -R REMOVE-FUNC ]
[ -D ARRAY ] [ -O ARRAY ] [ -A ARRAY ]
[ -E NUMBER ]
[ -M MATCH-SPEC ] [ -- ] [ WORDS ... ]
     This builtin command can be used to add matches directly and
     control all the information the completion code stores with each
     possible match. The return status is zero if at least one match
     was added and non-zero if no matches were added.

     The completion code breaks the string to complete into seven
     fields in the order:



          <IPRE><APRE><HPRE><WORD><HSUF><ASUF><ISUF>

     The first field is an ignored prefix taken from the command line,
     the contents of the IPREFIX parameter plus the string given with
     the -i option. With the -U option, only the string from the -i
     option is used. The field <APRE> is an optional prefix string
     given with the -P option.  The <HPRE> field is a string that is
     considered part of the match but that should not be shown when
     listing completions, given with the -p option; for example,
     functions that do filename generation might specify a common path
     prefix this way.  <WORD> is the part of the match that should
     appear in the list of completions, i.e. one of the WORDS given at
     the end of the compadd command line. The suffixes <HSUF>, <ASUF>
     and <ISUF> correspond to the prefixes <HPRE>, <APRE> and <IPRE>
     and are given by the options -s, -S and -I, respectively.

     The supported flags are:


    -P PREFIX
          This gives a string to be inserted before the given WORDS.
          The string given is not considered as part of the match and
          any shell metacharacters in it will not be quoted when the
          string is inserted.

    -S SUFFIX
          Like -P, but gives a string to be inserted after the match.

    -p HIDDEN-PREFIX
          This gives a string that should be inserted into the command
          line before the match but that should not appear in the list
          of matches. Unless the -U option is given, this string must
          be matched as part of the string on the command line.

    -s HIDDEN-SUFFIX
          Like `-p', but gives a string to insert after the match.

    -i IGNORED-PREFIX
          This gives a string to insert into the command line just
          before any string given with the `-P' option.  Without `-P'
          the string is inserted before the string given with `-p' or
          directly before the match.

    -I IGNORED-SUFFIX
          Like -i, but gives an ignored suffix.

    -a
          With this flag the WORDS are taken as names of arrays and the
          possible matches are their values.  If only some elements of
          the arrays are needed, the WORDS may also contain subscripts,
          as in `foo[2,-1]'.

    -k
          With this flag the WORDS are taken as names of associative
          arrays and the possible matches are their keys.  As for -a,
          the WORDS may also contain subscripts, as in `foo[(R)*bar*]'.

    -d ARRAY
          This adds per-match display strings. The ARRAY should contain
          one element per WORD given. The completion code will then
          display the first element instead of the first WORD, and so
          on. The ARRAY may be given as the name of an array parameter
          or directly as a space-separated list of words in parentheses.

          If there are fewer display strings than WORDS, the leftover
          WORDS will be displayed unchanged and if there are more
          display strings than WORDS, the leftover display strings will
          be silently ignored.

    -l
          This option only has an effect if used together with the -d
          option. If it is given, the display strings are listed one
          per line, not arrayed in columns.

    -o
          This option only has an effect if used together with the -d
          option.  If it is given, the order of the output is
          determined by the match strings;  otherwise it is determined
          by the display strings (i.e. the strings given by the -d
          option).

    -J NAME
          Gives the name of the group of matches the words should be
          stored in.

    -V NAME
          Like -J but naming a unsorted group. These are in a different
          name space than groups created with the -J flag.

    -1
          If given together with the -V option, makes only consecutive
          duplicates in the group be removed. If combined with the -J
          option, this has no visible effect. Note that groups with and
          without this flag are in different name spaces.

    -2
          If given together with the -J or -V option, makes all
          duplicates be kept. Again, groups with and without this flag
          are in different name spaces.

    -X EXPLANATION
          The EXPLANATION string will be printed with the list of
          matches, above the group currently selected.

    -x MESSAGE
          Like -X, but the MESSAGE will be printed even if there are no
          matches in the group.

    -q
          The suffix given with -S will be automatically removed if the
          next character typed is a blank or does not insert anything,
          or if the suffix consists of only one character and the next
          character typed is the same character.

    -r REMOVE-CHARS
          This is a more versatile form of the -q option.  The suffix
          given with -S or the slash automatically added after
          completing directories will be automatically removed if the
          next character typed inserts one of the characters given in
          the REMOVE-CHARS.  This string is parsed as a characters
          class and understands the backslash sequences used by the
          print command.  For example, `-r "a-z\t"' removes the suffix
          if the next character typed inserts a lower case character or
          a TAB, and `-r "^0-9"' removes the suffix if the next
          character typed inserts anything but a digit. One extra
          backslash sequence is understood in this string: `\-' stands
          for all characters that insert nothing. Thus `-S "=" -q' is
          the same as `-S "=" -r "= \t\n\-"'.

          This option may also be used without the -S option; then any
          automatically added space will be removed when one of the
          characters in the list is typed.

    -R REMOVE-FUNC
          This is another form of the -r option. When a suffix has been
          inserted and the completion accepted, the function
          REMOVE-FUNC will be called after the next character typed.
          It is passed the length of the suffix as an argument and can
          use the special parameters available in ordinary
          (non-completion) zle widgets (see *note Zsh Line Editor::) to
          analyse and modify the command line.

    -f
          If this flag is given, all of the matches built from WORDS are
          marked as being the names of files.  They are not required to
          be actual filenames, but if they are, and the option
          LIST_TYPES is set, the characters describing the types of the
          files in the completion lists will be shown. This also forces
          a slash to be added when the name of a directory is completed.

    -e
          This flag can be used to tell the completion code that the
          matches added are parameter names for a parameter expansion.
          This will make the AUTO_PARAM_SLASH and AUTO_PARAM_KEYS
          options be used for the matches.

    -W FILE-PREFIX
          This string is a pathname that will be prepended to each of
          the matches formed by the given WORDS together with any
          prefix specified by the -p option to form a complete filename
          for testing.  Hence it is only useful if combined with the -f
          flag, as the tests will not otherwise be performed.

    -F ARRAY
          Specifies an array containing patterns. Words matching one of
          these patterns are ignored, i.e. not considered to be
          possible matches.

          The ARRAY may be the name of an array parameter or a list of
          literal patterns enclosed in parentheses and quoted, as in
          `-F "(*?.o *?.h)"'. If the name of an array is given, the
          elements of the array are taken as the patterns.

    -Q
          This flag instructs the completion code not to quote any
          metacharacters in the words when inserting them into the
          command line.

    -M MATCH-SPEC
          This gives local match specifications as described below in
          *note Completion Matching Control::. This option may be given
          more than once.  In this case all MATCH-SPECs given are
          concatenated with spaces between them to form the
          specification string to use.  Note that they will only be
          used if the -U option is not given.

    -n
          Specifies that the words added are to be used as possible
          matches, but are not to appear in the completion listing.

    -U
          If this flag is given, all words given will be accepted and
          no matching will be done by the completion code. Normally
          this is used in functions that do the matching themselves.

    -O ARRAY
          If this option is given, the WORDS are _not_ added to the set
          of possible completions.  Instead, matching is done as usual
          and all of the WORDS given as arguments that match the string
          on the command line will be stored in the array parameter
          whose name is given as ARRAY.

    -A ARRAY
          As the -O option, except that instead of those of the WORDS
          which match being stored in ARRAY, the strings generated
          internally by the completion code are stored. For example,
          with a matching specification of `-M "L:|no="', the string
          `nof' on the command line and the string `foo' as one of the
          WORDS, this option stores the string `nofoo' in the array,
          whereas the -O option stores the `foo' originally given.

    -D ARRAY
          As with -O, the WORDS are not added to the set of possible
          completions.  Instead, the completion code tests whether each
          WORD in turn matches what is on the line.  If the N'th WORD
          does not match, the N'th element of the ARRAY is removed.
          Elements for which the corresponding WORD is matched are
          retained.

    -C
          This option adds a special match which expands to all other
          matches when inserted into the line, even those that are
          added after this option is used.  Together with the -d option
          it is possible to specify a string that should be displayed
          in the list for this special match.  If no string is given,
          it will be shown as a string containing the strings that
          would be inserted for the other matches, truncated to the
          width of the screen.

    -E
          This option adds NUMBER empty matches after the WORDS have
          been added.  An empty match takes up space in completion
          listings but will never be inserted in the line and can't be
          selected with menu completion or menu selection.  This makes
          empty matches only useful to format completion lists and to
          make explanatory string be shown in completion lists (since
          empty matches can be given display strings with the -d
          option).  And because all but one empty string would
          otherwise be removed, this option implies the -V and -2
          options (even if an explicit -J option is given).

    -
    --
          This flag ends the list of flags and options. All arguments
          after it will be taken as the words to use as matches even if
          they begin with hyphens.


     Except for the -M flag, if any of these flags is given more than
     once, the first one (and its argument) will be used.

compset -p NUMBER
compset -P [ NUMBER ] PATTERN
compset -s NUMBER
compset -S [ NUMBER ] PATTERN
compset -n BEGIN [ END ]
compset -N BEG-PAT [ END-PAT ]
compset -q
     This command simplifies modification of the special parameters,
     while its return status allows tests on them to be carried out.

     The options are:


    -p NUMBER
          If the contents of the PREFIX parameter is longer than NUMBER
          characters, the first NUMBER characters are removed from it
          and appended to the contents of the IPREFIX parameter.

    -P [ NUMBER ] PATTERN
          If the value of the PREFIX parameter begins with anything that
          matches the PATTERN, the matched portion is removed from
          PREFIX and appended to IPREFIX.

          Without the optional NUMBER, the longest match is taken, but
          if NUMBER is given, anything up to the NUMBER'th match is
          moved.  If the NUMBER is negative, the NUMBER'th longest
          match is moved. For example, if PREFIX contains the string
          `a=b=c', then compset -P '*\=' will move the string `a=b='
          into the IPREFIX parameter, but compset -P 1 '*\=' will move
          only the string `a='.

    -s NUMBER
          As -p, but transfer the last NUMBER characters from the value
          of SUFFIX to the front of the value of ISUFFIX.

    -S [ NUMBER ] PATTERN
          As -P, but match the last portion of SUFFIX and transfer the
          matched portion to the front of the value of ISUFFIX.

    -n BEGIN [ END ]
          If the current word position as specified by the parameter
          CURRENT is greater than or equal to BEGIN, anything up to the
          BEGIN'th word is removed from the words array and the value
          of the parameter CURRENT is decremented by BEGIN.

          If the optional END is given, the modification is done only if
          the current word position is also less than or equal to END.
          In this case, the words from position END onwards are also
          removed from the words array.

          Both BEGIN and END may be negative to count backwards from
          the last element of the words array.

    -N BEG-PAT [ END-PAT ]
          If one of the elements of the words array before the one at
          the index given by the value of the parameter CURRENT matches
          the pattern BEG-PAT, all elements up to and including the
          matching one are removed from the words array and the value
          of CURRENT is changed to point to the same word in the
          changed array.

          If the optional pattern END-PAT is also given, and there is an
          element in the words array matching this pattern, the
          parameters are modified only if the index of this word is
          higher than the one given by the CURRENT parameter (so that
          the matching word has to be after the cursor). In this case,
          the words starting with the one matching end-pat are also
          removed from the words array. If words contains no word
          matching END-PAT, the testing and modification is performed
          as if it were not given.

    -q
          The word currently being completed is split on spaces into
          separate words, respecting the usual shell quoting
          conventions.  The resulting words are stored in the words
          array, and CURRENT, PREFIX, SUFFIX, QIPREFIX, and QISUFFIX
          are modified to reflect the word part that is completed.


     In all the above cases the return status is zero if the test
     succeeded and the parameters were modified and non-zero otherwise.
     This allows one to use this builtin in tests such as:


          if compset -P '*\='; then ...

     This forces anything up to and including the last equal sign to be
     ignored by the completion code.

compcall [ -TD ]
     This allows the use of completions defined with the compctl builtin
     from within completion widgets.  The list of matches will be
     generated as if one of the non-widget completion function
     (complete-word, etc.)  had been called, except that only compctls
     given for specific commands are used. To force the code to try
     completions defined with the -T option of compctl and/or the
     default completion (whether defined by compctl -D or the builtin
     default) in the appropriate places, the -T and/or -D flags can be
     passed to compcall.

     The return status can be used to test if a matching compctl
     definition was found. It is non-zero if a compctl was found and
     zero otherwise.

     Note that this builtin is defined by the zsh/compctl module.




File: zsh.info,  Node: Completion Condition Codes,  Next: Completion Matching Control,  Prev: Completion Builtin Commands,  Up: Completion Widgets

19.4 Completion Condition Codes
===============================



The following additional condition codes for use within the [[ ... ]]
construct are available in completion widgets.  These work on the
special parameters.  All of these tests can also be performed by the
compset builtin, but in the case of the condition codes the contents of
the special parameters are not modified.


-prefix [ NUMBER ] PATTERN
     true if the test for the -P option of compset would succeed.

-suffix [ NUMBER ] PATTERN
     true if the test for the -S option of compset would succeed.

-after BEG-PAT
     true if the test of the -N option with only the BEG-PAT given
     would succeed.

-between BEG-PAT END-PAT
     true if the test for the -N option with both patterns would
     succeed.




File: zsh.info,  Node: Completion Matching Control,  Next: Completion Widget Example,  Prev: Completion Condition Codes,  Up: Completion Widgets

19.5 Completion Matching Control
================================

It is possible by use of the -M option of the compadd builtin command
to specify how the characters in the string to be completed (referred
to here as the command line) map onto the characters in the list of
matches produced by the completion code (referred to here as the trial
completions). Note that this is not used if the command line contains a
glob pattern and the GLOB_COMPLETE option is set or the pattern_match
of the compstate special association is set to a non-empty string.

The MATCH-SPEC given as the argument to the -M option (see *note
Completion Builtin Commands::) consists of one or more matching
descriptions separated by whitespace.  Each description consists of a
letter followed by a colon and then the patterns describing which
character sequences on the line match which character sequences in the
trial completion.  Any sequence of characters not handled in this
fashion must match exactly, as usual.

The forms of MATCH-SPEC understood are as follows. In each case, the
form with an upper case initial character retains the string already
typed on the command line as the final result of completion, while with
a lower case initial character the string on the command line is changed
into the corresponding part of the trial completion.


m:LPAT=TPAT
M:LPAT=TPAT
     Here, LPAT is a pattern that matches on the command line,
     corresponding to TPAT which matches in the trial completion.

l:LANCHOR|LPAT=TPAT
L:LANCHOR|LPAT=TPAT
l:LANCHOR||RANCHOR=TPAT
L:LANCHOR||RANCHOR=TPAT
b:LPAT=TPAT
B:LPAT=TPAT
     These letters are for patterns that are anchored by another
     pattern on the left side. Matching for LPAT and TPAT is as for m
     and M, but the pattern LPAT matched on the command line must be
     preceded by the pattern LANCHOR.  The LANCHOR can be blank to
     anchor the match to the start of the command line string;
     otherwise the anchor can occur anywhere, but must match in both
     the command line and trial completion strings.

     If no LPAT is given but a RANCHOR is, this matches the gap between
     substrings matched by LANCHOR and RANCHOR. Unlike LANCHOR, the
     RANCHOR only needs to match the trial completion string.

     The b and B forms are similar to l and L with an empty anchor, but
     need to match only the beginning of the trial completion or the
     word on the command line, respectively.

r:LPAT|RANCHOR=TPAT
R:LPAT|RANCHOR=TPAT
r:LANCHOR||RANCHOR=TPAT
R:LANCHOR||RANCHOR=TPAT
e:LPAT=TPAT
E:LPAT=TPAT
     As l, L, b and B, with the difference that the command line and
     trial completion patterns are anchored on the right side.  Here an
     empty RANCHOR and the e and E forms force the match to the end of
     the trial completion or command line string.


Each LPAT, TPAT or ANCHOR is either an empty string or consists of a
sequence of literal characters (which may be quoted with a backslash),
question marks, character classes, and correspondence classes; ordinary
shell patterns are not used.  Literal characters match only themselves,
question marks match any character, and character classes are formed as
for globbing and match any character in the given set.

Correspondence classes are defined like character classes, but with two
differences: they are delimited by a pair of braces, and negated classes
are not allowed, so the characters ! and ^ have no special meaning
directly after the opening brace.  They indicate that a range of
characters on the line match a range of characters in the trial
completion, but (unlike ordinary character classes) paired according to
the corresponding position in the sequence.  For example, to make any
ASCII lower case letter on the line match the corresponding upper case
letter in the trial completion, you can use `m:{a-z}={A-Z}' (however,
see below for the recommended form for this).  More than one pair of
classes can occur, in which case the first class before the =
corresponds to the first after it, and so on.  If one side has more
such classes than the other side, the superfluous classes behave like
normal character classes.  In anchor patterns correspondence classes
also behave like normal character classes.

The standard `[:NAME:]' forms described for standard shell patterns,
*note Filename Generation::, may appear in correspondence classes as
well as normal character classes.  The only special behaviour in
correspondence classes is if the form on the left and the form on the
right are each one of [:upper:], [:lower:].  In these cases the
character in the word and the character on the line must be the same up
to a difference in case.  Hence to make any lower case character on the
line match the corresponding upper case character in the trial
completion you can use `m:{[:lower:]}={[:upper:]}'.  Although the
matching system does not yet handle multibyte characters, this is likely
to be a future extension, at which point this syntax will handle
arbitrary alphabets; hence this form, rather than the use of explicit
ranges, is the recommended form.  In other cases `[:NAME:]' forms are
allowed.  If the two forms on the left and right are the same, the
characters must match exactly.  In remaining cases, the corresponding
tests are applied to both characters, but they are not otherwise
constrained; any matching character in one set goes with any matching
character in the other set:  this is equivalent to the behaviour of
ordinary character classes.

The pattern TPAT may also be one or two stars, `*' or `**'. This means
that the pattern on the command line can match any number of characters
in the trial completion. In this case the pattern must be anchored (on
either side); in the case of a single star, the ANCHOR then determines
how much of the trial completion is to be included -- only the
characters up to the next appearance of the anchor will be matched.
With two stars, substrings matched by the anchor can be matched, too.

Examples:

The keys of the options association defined by the parameter module are
the option names in all-lower-case form, without underscores, and
without the optional no at the beginning even though the builtins
setopt and unsetopt understand option names with upper case letters,
underscores, and the optional no.  The following alters the matching
rules so that the prefix no and any underscore are ignored when trying
to match the trial completions generated and upper case letters on the
line match the corresponding lower case letters in the words:


     compadd -M 'L:|[nN][oO]= M:_= M:{[:upper:]}={[:lower:]}' - \
       ${(k)options}

The first part says that the pattern `[nN][oO]' at the beginning (the
empty anchor before the pipe symbol) of the string on the line matches
the empty string in the list of words generated by completion, so it
will be ignored if present. The second part does the same for an
underscore anywhere in the command line string, and the third part uses
correspondence classes so that any upper case letter on the line
matches the corresponding lower case letter in the word. The use of the
upper case forms of the specification characters (L and M) guarantees
that what has already been typed on the command line (in particular the
prefix no) will not be deleted.

Note that the use of L in the first part means that it matches only
when at the beginning of both the command line string and the trial
completion. I.e., the string `_NO_f' would not be completed to
`_NO_foo', nor would `NONO_f' be completed to `NONO_foo' because of the
leading underscore or the second `NO' on the line which makes the
pattern fail even though they are otherwise ignored. To fix this, one
would use `B:[nN][oO]=' instead of the first part. As described above,
this matches at the beginning of the trial completion, independent of
other characters or substrings at the beginning of the command line
word which are ignored by the same or other MATCH-SPECs.

The second example makes completion case insensitive.  This is just the
same as in the option example, except here we wish to retain the
characters in the list of completions:


     compadd -M 'm:{[:lower:]}={[:upper:]}' ...

This makes lower case letters match their upper case counterparts.  To
make upper case letters match the lower case forms as well:


     compadd -M 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' ...

A nice example for the use of * patterns is partial word completion.
Sometimes you would like to make strings like `c.s.u' complete to
strings like `comp.source.unix', i.e. the word on the command line
consists of multiple parts, separated by a dot in this example, where
each part should be completed separately -- note, however, that the
case where each part of the word, i.e. `comp', `source' and `unix' in
this example, is to be completed from separate sets of matches is a
different problem to be solved by the implementation of the completion
widget.  The example can be handled by:


     compadd -M 'r:|.=* r:|=*' \
       - comp.sources.unix comp.sources.misc ...

The first specification says that LPAT is the empty string, while
ANCHOR is a dot; TPAT is *, so this can match anything except for the
`.' from the anchor in the trial completion word.  So in `c.s.u', the
matcher sees `c', followed by the empty string, followed by the anchor
`.', and likewise for the second dot, and replaces the empty strings
before the anchors, giving `c[omp].s[ources].u[nix]', where the last
part of the completion is just as normal.

With the pattern shown above, the string `c.u' could not be completed
to `comp.sources.unix' because the single star means that no dot
(matched by the anchor) can be skipped. By using two stars as in
`r:|.=**', however, `c.u' could be completed to `comp.sources.unix'.
This also shows that in some cases, especially if the anchor is a real
pattern, like a character class, the form with two stars may result in
more matches than one would like.

The second specification is needed to make this work when the cursor is
in the middle of the string on the command line and the option
COMPLETE_IN_WORD is set. In this case the completion code would
normally try to match trial completions that end with the string as
typed so far, i.e. it will only insert new characters at the cursor
position rather then at the end.  However in our example we would like
the code to recognise matches which contain extra characters after the
string on the line (the `nix' in the example).  Hence we say that the
empty string at the end of the string on the line matches any characters
at the end of the trial completion.

More generally, the specification


     compadd -M 'r:|[.,_-]=* r:|=*' ...

allows one to complete words with abbreviations before any of the
characters in the square brackets.  For example, to complete
veryverylongfile.c rather than veryverylongheader.h with the above in
effect, you can just type very.c before attempting completion.

The specifications with both a left and a right anchor are useful to
complete partial words whose parts are not separated by some special
character. For example, in some places strings have to be completed
that are formed `LikeThis' (i.e. the separate parts are determined by a
leading upper case letter) or maybe one has to complete strings with
trailing numbers. Here one could use the simple form with only one
anchor as in:


     compadd -M 'r:|[[:upper:]0-9]=* r:|=*' LikeTHIS FooHoo 5foo123 5bar234

But with this, the string `H' would neither complete to `FooHoo' nor to
`LikeTHIS' because in each case there is an upper case letter before
the `H' and that is matched by the anchor. Likewise, a `2' would not be
completed. In both cases this could be changed by using
`r:|[[:upper:]0-9]=**', but then `H' completes to both `LikeTHIS' and
`FooHoo' and a `2' matches the other strings because characters can be
inserted before every upper case letter and digit. To avoid this one
would use:


     compadd -M 'r:[^[:upper:]0-9]||[[:upper:]0-9]=** r:|=*' \
         LikeTHIS FooHoo foo123 bar234

By using these two anchors, a `H' matches only upper case `H's that are
immediately preceded by something matching the left anchor
`[^[:upper:]0-9]'. The effect is, of course, that `H' matches only the
string `FooHoo', a `2' matches only `bar234' and so on.

When using the completion system (see *note Completion System::), users
can define match specifications that are to be used for specific
contexts by using the matcher and matcher-list styles. The values for
the latter will be used everywhere.




File: zsh.info,  Node: Completion Widget Example,  Prev: Completion Matching Control,  Up: Completion Widgets

19.6 Completion Widget Example
==============================



The first step is to define the widget:


     zle -C complete complete-word complete-files

Then the widget can be bound to a key using the bindkey builtin command:


     bindkey '^X\t' complete

After that the shell function complete-files will be invoked after
typing control-X and TAB. The function should then generate the
matches, e.g.:


     complete-files () { compadd - * }

This function will complete files in the current directory matching the
current word.


File: zsh.info,  Node: Completion System,  Next: Completion Using compctl,  Prev: Completion Widgets,  Up: Top

20 Completion System
********************



20.1 Description
================

This describes the shell code for the `new' completion system, referred
to as compsys.  It is written in shell functions based on the features
described in the previous chapter, *note Completion Widgets::.

The features are contextual, sensitive to the point at which completion
is started.  Many completions are already provided.  For this reason, a
user can perform a great many tasks without knowing any details beyond
how to initialize the system, which is described in *note
Initialization::.

The context that decides what completion is to be performed may be
   * an argument or option position: these describe the position on the
     command line at which completion is requested.  For example `first
     argument to rmdir, the word being completed names a directory';

   * a special context, denoting an element in the shell's syntax.  For
     example `a word in command position' or `an array subscript'.


A full context specification contains other elements, as we shall
describe.

Besides commands names and contexts, the system employs two more
concepts, _styles_ and _tags_.  These provide ways for the user to
configure the system's behaviour.

Tags play a dual role.  They serve as a classification system for the
matches, typically indicating a class of object that the user may need
to distinguish.  For example, when completing arguments of the ls
command the user may prefer to try files before directories, so both of
these are tags.  They also appear as the rightmost element in a context
specification.

Styles modify various operations of the completion system, such as
output formatting, but also what kinds of completers are used (and in
what order), or which tags are examined.  Styles may accept arguments
and are manipulated using the zstyle command described in *note The
zsh/zutil Module::.

In summary, tags describe _what_ the completion objects are, and style
how they are to be completed.  At various points of execution, the
completion system checks what styles and/or tags are defined for the
current context, and uses that to modify its behavior.  The full
description of context handling, which determines how tags and other
elements of the context influence the behaviour of styles, is described
in *note Completion System Configuration::.

When a completion is requested, a dispatcher function is called; see
the description of _main_complete in the list of control functions
below. This dispatcher decides which function should be called to
produce the completions, and calls it. The result is passed to one or
more _completers_, functions that implement individual completion
strategies: simple completion, error correction, completion with error
correction, menu selection, etc.

More generally, the shell functions contained in the completion system
are of two types:
   * those beginning `comp' are to be called directly; there are only a
     few of these;

   * those beginning `_' are called by the completion code.  The shell
     functions of this set, which implement completion behaviour and
     may be bound to keystrokes, are referred to as `widgets'.  These
     proliferate as new completions are required.



* Menu:

* Initialization::
* Completion System Configuration::
* Control Functions::
* Bindable Commands::
* Completion Functions::
* Completion Directories::



File: zsh.info,  Node: Initialization,  Next: Completion System Configuration,  Up: Completion System

20.2 Initialization
===================



If the system was installed completely, it should be enough to call the
shell function compinit from your initialization file; see the next
section.  However, the function compinstall can be run by a user to
configure various aspects of the completion system.

Usually, compinstall will insert code into .zshrc, although if that is
not writable it will save it in another file and tell you that file's
location.  Note that it is up to you to make sure that the lines added
to .zshrc are actually run; you may, for example, need to move them to
an earlier place in the file if .zshrc usually returns early.  So long
as you keep them all together (including the comment lines at the start
and finish), you can rerun compinstall and it will correctly locate and
modify these lines.  Note, however, that any code you add to this
section by hand is likely to be lost if you rerun compinstall, although
lines using the command `zstyle' should be gracefully handled.

The new code will take effect next time you start the shell, or run
.zshrc by hand; there is also an option to make them take effect
immediately.  However, if compinstall has removed definitions, you will
need to restart the shell to see the changes.

To run compinstall you will need to make sure it is in a directory
mentioned in your fpath parameter, which should already be the case if
zsh was properly configured as long as your startup files do not remove
the appropriate directories from fpath.  Then it must be autoloaded
(`autoload -U compinstall' is recommended).  You can abort the
installation any time you are being prompted for information, and your
.zshrc will not be altered at all; changes only take place right at the
end, where you are specifically asked for confirmation.



20.2.1 Use of compinit
----------------------



This section describes the use of compinit to initialize completion for
the current session when called directly; if you have run compinstall
it will be called automatically from your .zshrc.

To initialize the system, the function compinit should be in a
directory mentioned in the fpath parameter, and should be autoloaded
(`autoload -U compinit' is recommended), and then run simply as
`compinit'.  This will define a few utility functions, arrange for all
the necessary shell functions to be autoloaded, and will then re-define
all widgets that do completion to use the new system.  If you use the
menu-select widget, which is part of the zsh/complist module, you
should make sure that that module is loaded before the call to compinit
so that that widget is also re-defined.  If completion styles (see
below) are set up to perform expansion as well as completion by
default, and the TAB key is bound to expand-or-complete, compinit will
rebind it to complete-word; this is necessary to use the correct form
of expansion.

Should you need to use the original completion commands, you can still
bind keys to the old widgets by putting a `.' in front of the widget
name, e.g. `.expand-or-complete'.

To speed up the running of compinit, it can be made to produce a dumped
configuration that will be read in on future invocations; this is the
default, but can be turned off by calling compinit with the option -D.
The dumped file is .zcompdump in the same directory as the startup
files (i.e. $ZDOTDIR or $HOME); alternatively, an explicit file name
can be given by `compinit -d DUMPFILE'.  The next invocation of
compinit will read the dumped file instead of performing a full
initialization.

If the number of completion files changes, compinit will recognise this
and produce a new dump file.  However, if the name of a function or the
arguments in the first line of a #compdef function (as described below)
change, it is easiest to delete the dump file by hand so that compinit
will re-create it the next time it is run.  The check performed to see
if there are new functions can be omitted by giving the option -C.  In
this case the dump file will only be created if there isn't one already.

The dumping is actually done by another function, compdump, but you
will only need to run this yourself if you change the configuration
(e.g. using compdef) and then want to dump the new one.  The name of
the old dumped file will be remembered for this purpose.

If the parameter _compdir is set, compinit uses it as a directory where
completion functions can be found; this is only necessary if they are
not already in the function search path.

For security reasons compinit also checks if the completion system
would use files not owned by root or by the current user, or files in
directories that are world- or group-writable or that are not owned by
root or by the current user.  If such files or directories are found,
compinit will ask if the completion system should really be used.  To
avoid these tests and make all files found be used without asking, use
the option -u, and to make compinit silently ignore all insecure files
and directories use the option -i.  This security check is skipped
entirely when the -C option is given.

The security check can be retried at any time by running the function
compaudit.  This is the same check used by compinit, but when it is
executed directly any changes to fpath are made local to the function
so they do not persist.  The directories to be checked may be passed as
arguments; if none are given, compaudit uses fpath and _compdir to find
completion system directories, adding missing ones to fpath as
necessary.  To force a check of exactly the directories currently named
in fpath, set _compdir to an empty string before calling compaudit or
compinit.



20.2.2 Autoloaded files
-----------------------



The convention for autoloaded functions used in completion is that they
start with an underscore; as already mentioned, the fpath/FPATH
parameter must contain the directory in which they are stored.  If zsh
was properly installed on your system, then fpath/FPATH automatically
contains the required directories for the standard functions.

For incomplete installations, if compinit does not find enough files
beginning with an underscore (fewer than twenty) in the search path, it
will try to find more by adding the directory _compdir to the search
path.  If that directory has a subdirectory named Base, all
subdirectories will be added to the path.  Furthermore, if the
subdirectory Base has a subdirectory named Core, compinit will add all
subdirectories of the subdirectories is to the path: this allows the
functions to be in the same format as in the zsh source distribution.

When compinit is run, it searches all such files accessible via
fpath/FPATH and reads the first line of each of them.  This line should
contain one of the tags described below.  Files whose first line does
not start with one of these tags are not considered to be part of the
completion system and will not be treated specially.

The tags are:


#compdef NAMES... [ -[pP] PATTERNS... [ -N NAMES... ] ]
     The file will be made autoloadable and the function defined in it
     will be called when completing NAMES, each of which is either the
     name of a command whose arguments are to be completed or one of a
     number of special contexts in the form -CONTEXT- described below.

     Each NAME may also be of the form `CMD=SERVICE'.  When completing
     the command CMD, the function typically behaves as if the command
     (or special context) SERVICE was being completed instead.  This
     provides a way of altering the behaviour of functions that can
     perform many different completions.  It is implemented by setting
     the parameter $service when calling the function; the function may
     choose to interpret this how it wishes, and simpler functions will
     probably ignore it.

     If the #compdef line contains one of the options -p or -P, the
     words following are taken to be patterns.  The function will be
     called when completion is attempted for a command or context that
     matches one of the patterns.  The options -p and -P are used to
     specify patterns to be tried before or after other completions
     respectively.  Hence -P may be used to specify default actions.

     The option -N is used after a list following -p or -P; it
     specifies that remaining words no longer define patterns.  It is
     possible to toggle between the three options as many times as
     necessary.

#compdef -k STYLE KEY-SEQUENCES...
     This option creates a widget behaving like the builtin widget
     STYLE and binds it to the given KEY-SEQUENCES, if any.  The STYLE
     must be one of the builtin widgets that perform completion, namely
     complete-word, delete-char-or-list, expand-or-complete,
     expand-or-complete-prefix, list-choices, menu-complete,
     menu-expand-or-complete, or reverse-menu-complete.  If the
     zsh/complist module is loaded (see *note The zsh/complist
     Module::) the widget menu-select is also available.

     When one of the KEY-SEQUENCES is typed, the function in the file
     will be invoked to generate the matches.  Note that a key will not
     be re-bound if if it already was (that is, was bound to something
     other than undefined-key).  The widget created has the same name
     as the file and can be bound to any other keys using bindkey as
     usual.

#compdef -K WIDGET-NAME STYLE KEY-SEQUENCES ...
     This is similar to -k except that only one KEY-SEQUENCES argument
     may be given for each WIDGET-NAME STYLE pair.  However, the entire
     set of three arguments may be repeated with a different set of
     arguments.  Note in particular that the WIDGET-NAME must be
     distinct in each set.  If it does not begin with `_' this will be
     added.  The WIDGET-NAME should not clash with the name of any
     existing widget: names based on the name of the function are most
     useful.  For example,


          #compdef -K _foo_complete complete-word "^X^C" \
            _foo_list list-choices "^X^D"

     (all on one line) defines a widget _foo_complete for completion,
     bound to `^X^C', and a widget _foo_list for listing, bound to
     `^X^D'.

#autoload [ OPTIONS ]
     Functions with the #autoload tag are marked for autoloading but
     are not otherwise treated specially.  Typically they are to be
     called from within one of the completion functions.  Any OPTIONS
     supplied will be passed to the autoload builtin; a typical use is
     +X to force the function to be loaded immediately.  Note that the
     -U and -z flags are always added implicitly.


The # is part of the tag name and no white space is allowed after it.
The #compdef tags use the compdef function described below; the main
difference is that the name of the function is supplied implicitly.

The special contexts for which completion functions can be defined are:


-array-value-
     The right hand side of an array-assignment (`foo=(...)')

-brace-parameter-
     The name of a parameter expansion within braces (`${...}')

-assign-parameter-
     The name of a parameter in an assignment, i.e. on the left hand
     side of an `='

-command-
     A word in command position

-condition-
     A word inside a condition (`[[...]]')

-default-
     Any word for which no other completion is defined

-equal-
     A word beginning with an equals sign

-first-
     This is tried before any other completion function.  The function
     called may set the _compskip parameter to one of various values:
     all: no further completion is attempted; a string containing the
     substring patterns: no pattern completion functions will be
     called; a string containing default: the function for the
     `-default-' context will not be called, but functions defined for
     commands will

-math-
     Inside mathematical contexts, such as `((...))'

-parameter-
     The name of a parameter expansion (`$...')

-redirect-
     The word after a redirection operator.

-subscript-
     The contents of a parameter subscript.

-tilde-
     After an initial tilde (`~'), but before the first slash in the
     word.

-value-
     On the right hand side of an assignment.


Default implementations are supplied for each of these contexts.  In
most cases the context -CONTEXT- is implemented by a corresponding
function _CONTEXT, for example the context `-tilde-' and the function
`_tilde').

The contexts -redirect- and -value- allow extra context-specific
information.  (Internally, this is handled by the functions for each
context calling the function _dispatch.)  The extra information is
added separated by commas.

For the -redirect- context, the extra information is in the form
`-redirect-,OP,COMMAND', where OP is the redirection operator and
COMMAND is the name of the command on the line.  If there is no command
on the line yet, the COMMAND field will be empty.

For the -value- context, the form is `-value-,NAME,COMMAND', where NAME
is the name of the parameter.  In the case of elements of an
associative array, for example `assoc=(key <TAB>', NAME is expanded to
`NAME-KEY'.  In certain special contexts, such as completing after
`make CFLAGS=', the COMMAND part gives the name of the command, here
make; otherwise it is empty.

It is not necessary to define fully specific completions as the
functions provided will try to generate completions by progressively
replacing the elements with `-default-'.  For example, when completing
after `foo=<TAB>', _value will try the names `-value-,foo,' (note the
empty COMMAND part), `-value-,foo,-default-'
and`-value-,-default-,-default-', in that order, until it finds a
function to handle the context.

As an example:


     compdef '_files -g "*.log"' '-redirect-,2>,-default-'

completes files matching `*.log' after `2> <TAB>' for any command with
no more specific handler defined.

Also:


     compdef _foo -value-,-default-,-default-

specifies that _foo provides completions for the values of parameters
for which no special function has been defined.  This is usually
handled by the function _value itself.

The same lookup rules are used when looking up styles (as described
below); for example


     zstyle ':completion:*:*:-redirect-,2>,*:*' file-patterns '*.log'

is another way to make completion after `2> <TAB>' complete files
matching `*.log'.



20.2.3 Functions
----------------

The following function is defined by compinit and may be called
directly.


compdef [ -an ] FUNCTION NAMES... [ -[pP] PATTERNS... [ -N NAMES... ] ]
compdef -d NAMES...
compdef -k [ -an ] FUNCTION STYLE KEY-SEQUENCES...
compdef -K [ -an ] FUNCTION NAME STYLE KEY-SEQUENCES ...
     The first form defines the FUNCTION to call for completion in the
     given contexts as described for the #compdef tag above.

     Alternatively, all the arguments may have the form `CMD=SERVICE'.
     Here SERVICE should already have been defined by `CMD1=SERVICE'
     lines in #compdef files, as described above.  The argument for CMD
     will be completed in the same way as SERVICE.

     The FUNCTION argument may alternatively be a string containing any
     shell code.  The string will be executed using the eval builtin
     command to generate completions.  This provides a way of avoiding
     having to define a new completion function.  For example, to
     complete files ending in `.h' as arguments to the command foo:


          compdef '_files -g "*.h"' foo

     The option -n prevents any completions already defined for the
     command or context from being overwritten.

     The option -d deletes any completion defined for the command or
     contexts listed.

     The NAMES may also contain -p, -P and -N options as described for
     the #compdef tag.  The effect on the argument list is identical,
     switching between definitions of patterns tried initially,
     patterns tried finally, and normal commands and contexts.

     The parameter $_compskip may be set by any function defined for a
     pattern context.  If it is set to a value containing the substring
     `patterns' none of the pattern-functions will be called; if it is
     set to a value containing the substring `all', no other function
     will be called.

     The form with -k defines a widget with the same name as the
     FUNCTION that will be called for each of the KEY-SEQUENCES; this
     is like the #compdef -k tag.  The function should generate the
     completions needed and will otherwise behave like the builtin
     widget whose name is given as the STYLE argument.  The widgets
     usable for this are: complete-word, delete-char-or-list,
     expand-or-complete, expand-or-complete-prefix, list-choices,
     menu-complete, menu-expand-or-complete, and reverse-menu-complete,
     as well as menu-select if the zsh/complist module is loaded.  The
     option -n prevents the key being bound if it is already to bound
     to something other than undefined-key.

     The form with -K is similar and defines multiple widgets based on
     the same FUNCTION, each of which requires the set of three
     arguments NAME, STYLE and KEY-SEQUENCES, where the latter two are
     as for -k and the first must be a unique widget name beginning
     with an underscore.

     Wherever applicable, the -a option makes the FUNCTION
     autoloadable, equivalent to autoload -U FUNCTION.


The function compdef can be used to associate existing completion
functions with new commands.  For example,


     compdef _pids foo

uses the function _pids to complete process IDs for the command foo.

Note also the _gnu_generic function described below, which can be used
to complete options for commands that understand the `--help' option.




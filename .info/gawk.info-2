This is gawk.info, produced by makeinfo version 4.13 from
/d/home/arnold/Gnu/gawk/gendocs/gawk-4.0.0/doc/gawk.texi.

INFO-DIR-SECTION Text creation and manipulation
START-INFO-DIR-ENTRY
* Gawk: (gawk).                 A text scanning and processing language.
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* awk: (gawk)Invoking gawk.                     Text scanning and processing.
END-INFO-DIR-ENTRY

   Copyright (C) 1989, 1991, 1992, 1993, 1996, 1997, 1998, 1999, 2000,
2001, 2002, 2003, 2004, 2005, 2007, 2009, 2010, 2011 Free Software
Foundation, Inc.


   This is Edition 4 of `GAWK: Effective AWK Programming: A User's
Guide for GNU Awk', for the 4.0.0 (or later) version of the GNU
implementation of AWK.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", the Front-Cover
texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

  a. "A GNU Manual"

  b. "You have the freedom to copy and modify this GNU manual.  Buying
     copies from the FSF supports it in developing GNU and promoting
     software freedom."


File: gawk.info,  Node: Concatenation,  Next: Assignment Ops,  Prev: Arithmetic Ops,  Up: All Operators

6.2.2 String Concatenation
--------------------------

     It seemed like a good idea at the time.
     Brian Kernighan

   There is only one string operation: concatenation.  It does not have
a specific operator to represent it.  Instead, concatenation is
performed by writing expressions next to one another, with no operator.
For example:

     $ awk '{ print "Field number one: " $1 }' BBS-list
     -| Field number one: aardvark
     -| Field number one: alpo-net
     ...

   Without the space in the string constant after the `:', the line
runs together.  For example:

     $ awk '{ print "Field number one:" $1 }' BBS-list
     -| Field number one:aardvark
     -| Field number one:alpo-net
     ...

   Because string concatenation does not have an explicit operator, it
is often necessary to insure that it happens at the right time by using
parentheses to enclose the items to concatenate.  For example, you
might expect that the following code fragment concatenates `file' and
`name':

     file = "file"
     name = "name"
     print "something meaningful" > file name

This produces a syntax error with some versions of Unix `awk'.(1) It is
necessary to use the following:

     print "something meaningful" > (file name)

   Parentheses should be used around concatenation in all but the most
common contexts, such as on the righthand side of `='.  Be careful
about the kinds of expressions used in string concatenation.  In
particular, the order of evaluation of expressions used for
concatenation is undefined in the `awk' language.  Consider this
example:

     BEGIN {
         a = "don't"
         print (a " " (a = "panic"))
     }

It is not defined whether the assignment to `a' happens before or after
the value of `a' is retrieved for producing the concatenated value.
The result could be either `don't panic', or `panic panic'.

   The precedence of concatenation, when mixed with other operators, is
often counter-intuitive.  Consider this example:

     $ awk 'BEGIN { print -12 " " -24 }'
     -| -12-24

   This "obviously" is concatenating -12, a space, and -24.  But where
did the space disappear to?  The answer lies in the combination of
operator precedences and `awk''s automatic conversion rules.  To get
the desired result, write the program this way:

     $ awk 'BEGIN { print -12 " " (-24) }'
     -| -12 -24

   This forces `awk' to treat the `-' on the `-24' as unary.
Otherwise, it's parsed as follows:

         -12 (`" "' - 24)
     => -12 (0 - 24)
     => -12 (-24)
     => -12-24

   As mentioned earlier, when doing concatenation, _parenthesize_.
Otherwise, you're never quite sure what you'll get.

   ---------- Footnotes ----------

   (1) It happens that Brian Kernighan's `awk', `gawk' and `mawk' all
"get it right," but you should not rely on this.


File: gawk.info,  Node: Assignment Ops,  Next: Increment Ops,  Prev: Concatenation,  Up: All Operators

6.2.3 Assignment Expressions
----------------------------

An "assignment" is an expression that stores a (usually different)
value into a variable.  For example, let's assign the value one to the
variable `z':

     z = 1

   After this expression is executed, the variable `z' has the value
one.  Whatever old value `z' had before the assignment is forgotten.

   Assignments can also store string values.  For example, the
following stores the value `"this food is good"' in the variable
`message':

     thing = "food"
     predicate = "good"
     message = "this " thing " is " predicate

This also illustrates string concatenation.  The `=' sign is called an
"assignment operator".  It is the simplest assignment operator because
the value of the righthand operand is stored unchanged.  Most operators
(addition, concatenation, and so on) have no effect except to compute a
value.  If the value isn't used, there's no reason to use the operator.
An assignment operator is different; it does produce a value, but even
if you ignore it, the assignment still makes itself felt through the
alteration of the variable.  We call this a "side effect".

   The lefthand operand of an assignment need not be a variable (*note
Variables::); it can also be a field (*note Changing Fields::) or an
array element (*note Arrays::).  These are all called "lvalues", which
means they can appear on the lefthand side of an assignment operator.
The righthand operand may be any expression; it produces the new value
that the assignment stores in the specified variable, field, or array
element. (Such values are called "rvalues".)

   It is important to note that variables do _not_ have permanent types.
A variable's type is simply the type of whatever value it happens to
hold at the moment.  In the following program fragment, the variable
`foo' has a numeric value at first, and a string value later on:

     foo = 1
     print foo
     foo = "bar"
     print foo

When the second assignment gives `foo' a string value, the fact that it
previously had a numeric value is forgotten.

   String values that do not begin with a digit have a numeric value of
zero. After executing the following code, the value of `foo' is five:

     foo = "a string"
     foo = foo + 5

     NOTE: Using a variable as a number and then later as a string can
     be confusing and is poor programming style.  The previous two
     examples illustrate how `awk' works, _not_ how you should write
     your programs!

   An assignment is an expression, so it has a value--the same value
that is assigned.  Thus, `z = 1' is an expression with the value one.
One consequence of this is that you can write multiple assignments
together, such as:

     x = y = z = 5

This example stores the value five in all three variables (`x', `y',
and `z').  It does so because the value of `z = 5', which is five, is
stored into `y' and then the value of `y = z = 5', which is five, is
stored into `x'.

   Assignments may be used anywhere an expression is called for.  For
example, it is valid to write `x != (y = 1)' to set `y' to one, and
then test whether `x' equals one.  But this style tends to make
programs hard to read; such nesting of assignments should be avoided,
except perhaps in a one-shot program.

   Aside from `=', there are several other assignment operators that do
arithmetic with the old value of the variable.  For example, the
operator `+=' computes a new value by adding the righthand value to the
old value of the variable.  Thus, the following assignment adds five to
the value of `foo':

     foo += 5

This is equivalent to the following:

     foo = foo + 5

Use whichever makes the meaning of your program clearer.

   There are situations where using `+=' (or any assignment operator)
is _not_ the same as simply repeating the lefthand operand in the
righthand expression.  For example:

     # Thanks to Pat Rankin for this example
     BEGIN  {
         foo[rand()] += 5
         for (x in foo)
            print x, foo[x]

         bar[rand()] = bar[rand()] + 5
         for (x in bar)
            print x, bar[x]
     }

The indices of `bar' are practically guaranteed to be different, because
`rand()' returns different values each time it is called.  (Arrays and
the `rand()' function haven't been covered yet.  *Note Arrays::, and
see *note Numeric Functions::, for more information).  This example
illustrates an important fact about assignment operators: the lefthand
expression is only evaluated _once_.  It is up to the implementation as
to which expression is evaluated first, the lefthand or the righthand.
Consider this example:

     i = 1
     a[i += 2] = i + 1

The value of `a[3]' could be either two or four.

   *note table-assign-ops:: lists the arithmetic assignment operators.
In each case, the righthand operand is an expression whose value is
converted to a number.

Operator               Effect
-------------------------------------------------------------------------- 
LVALUE `+=' INCREMENT  Adds INCREMENT to the value of LVALUE.
LVALUE `-=' DECREMENT  Subtracts DECREMENT from the value of LVALUE.
LVALUE `*='            Multiplies the value of LVALUE by COEFFICIENT.
COEFFICIENT            
LVALUE `/=' DIVISOR    Divides the value of LVALUE by DIVISOR.
LVALUE `%=' MODULUS    Sets LVALUE to its remainder by MODULUS.
LVALUE `^=' POWER      
LVALUE `**=' POWER     Raises LVALUE to the power POWER. (c.e.)

Table 6.2: Arithmetic Assignment Operators

     NOTE: Only the `^=' operator is specified by POSIX.  For maximum
     portability, do not use the `**=' operator.

Advanced Notes: Syntactic Ambiguities Between `/=' and Regular Expressions
--------------------------------------------------------------------------

There is a syntactic ambiguity between the `/=' assignment operator and
regexp constants whose first character is an `='.  (d.c.)  This is most
notable in commercial `awk' versions.  For example:

     $ awk /==/ /dev/null
     error--> awk: syntax error at source line 1
     error-->  context is
     error-->         >>> /= <<<
     error--> awk: bailing out at source line 1

A workaround is:

     awk '/[=]=/' /dev/null

   `gawk' does not have this problem, nor do the other freely available
versions described in *note Other Versions::.


File: gawk.info,  Node: Increment Ops,  Prev: Assignment Ops,  Up: All Operators

6.2.4 Increment and Decrement Operators
---------------------------------------

"Increment" and "decrement operators" increase or decrease the value of
a variable by one.  An assignment operator can do the same thing, so
the increment operators add no power to the `awk' language; however,
they are convenient abbreviations for very common operations.

   The operator used for adding one is written `++'.  It can be used to
increment a variable either before or after taking its value.  To
pre-increment a variable `v', write `++v'.  This adds one to the value
of `v'--that new value is also the value of the expression. (The
assignment expression `v += 1' is completely equivalent.)  Writing the
`++' after the variable specifies post-increment.  This increments the
variable value just the same; the difference is that the value of the
increment expression itself is the variable's _old_ value.  Thus, if
`foo' has the value four, then the expression `foo++' has the value
four, but it changes the value of `foo' to five.  In other words, the
operator returns the old value of the variable, but with the side
effect of incrementing it.

   The post-increment `foo++' is nearly the same as writing `(foo += 1)
- 1'.  It is not perfectly equivalent because all numbers in `awk' are
floating-point--in floating-point, `foo + 1 - 1' does not necessarily
equal `foo'.  But the difference is minute as long as you stick to
numbers that are fairly small (less than 10e12).

   Fields and array elements are incremented just like variables.  (Use
`$(i++)' when you want to do a field reference and a variable increment
at the same time.  The parentheses are necessary because of the
precedence of the field reference operator `$'.)

   The decrement operator `--' works just like `++', except that it
subtracts one instead of adding it.  As with `++', it can be used before
the lvalue to pre-decrement or after it to post-decrement.  Following
is a summary of increment and decrement expressions:

`++LVALUE'
     Increment LVALUE, returning the new value as the value of the
     expression.

`LVALUE++'
     Increment LVALUE, returning the _old_ value of LVALUE as the value
     of the expression.

`--LVALUE'
     Decrement LVALUE, returning the new value as the value of the
     expression.  (This expression is like `++LVALUE', but instead of
     adding, it subtracts.)

`LVALUE--'
     Decrement LVALUE, returning the _old_ value of LVALUE as the value
     of the expression.  (This expression is like `LVALUE++', but
     instead of adding, it subtracts.)

Advanced Notes: Operator Evaluation Order
-----------------------------------------

     Doctor, doctor!  It hurts when I do this!
     So don't do that!
     Groucho Marx

What happens for something like the following?

     b = 6
     print b += b++

Or something even stranger?

     b = 6
     b += ++b + b++
     print b

   In other words, when do the various side effects prescribed by the
postfix operators (`b++') take effect?  When side effects happen is
"implementation defined".  In other words, it is up to the particular
version of `awk'.  The result for the first example may be 12 or 13,
and for the second, it may be 22 or 23.

   In short, doing things like this is not recommended and definitely
not anything that you can rely upon for portability.  You should avoid
such things in your own programs.


File: gawk.info,  Node: Truth Values and Conditions,  Next: Function Calls,  Prev: All Operators,  Up: Expressions

6.3 Truth Values and Conditions
===============================

In certain contexts, expression values also serve as "truth values;"
i.e., they determine what should happen next as the program runs. This
minor node describes how `awk' defines "true" and "false" and how
values are compared.

* Menu:

* Truth Values::                What is ``true'' and what is ``false''.
* Typing and Comparison::       How variables acquire types and how this
                                affects comparison of numbers and strings with
                                `<', etc.
* Boolean Ops::                 Combining comparison expressions using boolean
                                operators `||' (``or''), `&&'
                                (``and'') and `!' (``not'').
* Conditional Exp::             Conditional expressions select between two
                                subexpressions under control of a third
                                subexpression.


File: gawk.info,  Node: Truth Values,  Next: Typing and Comparison,  Up: Truth Values and Conditions

6.3.1 True and False in `awk'
-----------------------------

Many programming languages have a special representation for the
concepts of "true" and "false."  Such languages usually use the special
constants `true' and `false', or perhaps their uppercase equivalents.
However, `awk' is different.  It borrows a very simple concept of true
and false from C.  In `awk', any nonzero numeric value _or_ any
nonempty string value is true.  Any other value (zero or the null
string, `""') is false.  The following program prints `A strange truth
value' three times:

     BEGIN {
        if (3.1415927)
            print "A strange truth value"
        if ("Four Score And Seven Years Ago")
            print "A strange truth value"
        if (j = 57)
            print "A strange truth value"
     }

   There is a surprising consequence of the "nonzero or non-null" rule:
the string constant `"0"' is actually true, because it is non-null.
(d.c.)


File: gawk.info,  Node: Typing and Comparison,  Next: Boolean Ops,  Prev: Truth Values,  Up: Truth Values and Conditions

6.3.2 Variable Typing and Comparison Expressions
------------------------------------------------

     The Guide is definitive. Reality is frequently inaccurate.
     The Hitchhiker's Guide to the Galaxy

   Unlike other programming languages, `awk' variables do not have a
fixed type. Instead, they can be either a number or a string, depending
upon the value that is assigned to them.  We look now at how variables
are typed, and how `awk' compares variables.

* Menu:

* Variable Typing::             String type versus numeric type.
* Comparison Operators::        The comparison operators.
* POSIX String Comparison::     String comparison with POSIX rules.


File: gawk.info,  Node: Variable Typing,  Next: Comparison Operators,  Up: Typing and Comparison

6.3.2.1 String Type Versus Numeric Type
.......................................

The 1992 POSIX standard introduced the concept of a "numeric string",
which is simply a string that looks like a number--for example,
`" +2"'.  This concept is used for determining the type of a variable.
The type of the variable is important because the types of two variables
determine how they are compared.  The various versions of the POSIX
standard did not get the rules quite right for several editions.
Fortunately, as of at least the 2008 standard (and possibly earlier),
the standard has been fixed, and variable typing follows these rules:(1)

   * A numeric constant or the result of a numeric operation has the
     NUMERIC attribute.

   * A string constant or the result of a string operation has the
     STRING attribute.

   * Fields, `getline' input, `FILENAME', `ARGV' elements, `ENVIRON'
     elements, and the elements of an array created by `patsplit()',
     `split()' and `match()' that are numeric strings have the STRNUM
     attribute.  Otherwise, they have the STRING attribute.
     Uninitialized variables also have the STRNUM attribute.

   * Attributes propagate across assignments but are not changed by any
     use.

   The last rule is particularly important. In the following program,
`a' has numeric type, even though it is later used in a string
operation:

     BEGIN {
          a = 12.345
          b = a " is a cute number"
          print b
     }

   When two operands are compared, either string comparison or numeric
comparison may be used. This depends upon the attributes of the
operands, according to the following symmetric matrix:

             +---------------------------------------------
             |       STRING          NUMERIC         STRNUM
     -------+---------------------------------------------
             |
     STRING  |       string          string          string
             |
     NUMERIC |       string          numeric         numeric
             |
     STRNUM  |       string          numeric         numeric
     -------+---------------------------------------------

   The basic idea is that user input that looks numeric--and _only_
user input--should be treated as numeric, even though it is actually
made of characters and is therefore also a string.  Thus, for example,
the string constant `" +3.14"', when it appears in program source code,
is a string--even though it looks numeric--and is _never_ treated as
number for comparison purposes.

   In short, when one operand is a "pure" string, such as a string
constant, then a string comparison is performed.  Otherwise, a numeric
comparison is performed.

   This point bears additional emphasis: All user input is made of
characters, and so is first and foremost of STRING type; input strings
that look numeric are additionally given the STRNUM attribute.  Thus,
the six-character input string ` +3.14' receives the STRNUM attribute.
In contrast, the eight-character literal `" +3.14"' appearing in
program text is a string constant.  The following examples print `1'
when the comparison between the two different constants is true, `0'
otherwise:

     $ echo ' +3.14' | gawk '{ print $0 == " +3.14" }'    True
     -| 1
     $ echo ' +3.14' | gawk '{ print $0 == "+3.14" }'     False
     -| 0
     $ echo ' +3.14' | gawk '{ print $0 == "3.14" }'      False
     -| 0
     $ echo ' +3.14' | gawk '{ print $0 == 3.14 }'        True
     -| 1
     $ echo ' +3.14' | gawk '{ print $1 == " +3.14" }'    False
     -| 0
     $ echo ' +3.14' | gawk '{ print $1 == "+3.14" }'     True
     -| 1
     $ echo ' +3.14' | gawk '{ print $1 == "3.14" }'      False
     -| 0
     $ echo ' +3.14' | gawk '{ print $1 == 3.14 }'        True
     -| 1

   ---------- Footnotes ----------

   (1) `gawk' has followed these rules for many years, and it is
gratifying that the POSIX standard is also now correct.


File: gawk.info,  Node: Comparison Operators,  Next: POSIX String Comparison,  Prev: Variable Typing,  Up: Typing and Comparison

6.3.2.2 Comparison Operators
............................

"Comparison expressions" compare strings or numbers for relationships
such as equality.  They are written using "relational operators", which
are a superset of those in C.  *note table-relational-ops:: describes
them.

Expression         Result
-------------------------------------------------------------------------- 
X `<' Y            True if X is less than Y.
X `<=' Y           True if X is less than or equal to Y.
X `>' Y            True if X is greater than Y.
X `>=' Y           True if X is greater than or equal to Y.
X `==' Y           True if X is equal to Y.
X `!=' Y           True if X is not equal to Y.
X `~' Y            True if the string X matches the regexp denoted by Y.
X `!~' Y           True if the string X does not match the regexp
                   denoted by Y.
SUBSCRIPT `in'     True if the array ARRAY has an element with the
ARRAY              subscript SUBSCRIPT.

Table 6.3: Relational Operators

   Comparison expressions have the value one if true and zero if false.
When comparing operands of mixed types, numeric operands are converted
to strings using the value of `CONVFMT' (*note Conversion::).

   Strings are compared by comparing the first character of each, then
the second character of each, and so on.  Thus, `"10"' is less than
`"9"'.  If there are two strings where one is a prefix of the other,
the shorter string is less than the longer one.  Thus, `"abc"' is less
than `"abcd"'.

   It is very easy to accidentally mistype the `==' operator and leave
off one of the `=' characters.  The result is still valid `awk' code,
but the program does not do what is intended:

     if (a = b)   # oops! should be a == b
        ...
     else
        ...

Unless `b' happens to be zero or the null string, the `if' part of the
test always succeeds.  Because the operators are so similar, this kind
of error is very difficult to spot when scanning the source code.

   The following table of expressions illustrates the kind of comparison
`gawk' performs, as well as what the result of the comparison is:

`1.5 <= 2.0'
     numeric comparison (true)

`"abc" >= "xyz"'
     string comparison (false)

`1.5 != " +2"'
     string comparison (true)

`"1e2" < "3"'
     string comparison (true)

`a = 2; b = "2"'
`a == b'
     string comparison (true)

`a = 2; b = " +2"'

`a == b'
     string comparison (false)

   In this example:

     $ echo 1e2 3 | awk '{ print ($1 < $2) ? "true" : "false" }'
     -| false

the result is `false' because both `$1' and `$2' are user input.  They
are numeric strings--therefore both have the STRNUM attribute,
dictating a numeric comparison.  The purpose of the comparison rules
and the use of numeric strings is to attempt to produce the behavior
that is "least surprising," while still "doing the right thing."

   String comparisons and regular expression comparisons are very
different.  For example:

     x == "foo"

has the value one, or is true if the variable `x' is precisely `foo'.
By contrast:

     x ~ /foo/

has the value one if `x' contains `foo', such as `"Oh, what a fool am
I!"'.

   The righthand operand of the `~' and `!~' operators may be either a
regexp constant (`/.../') or an ordinary expression. In the latter
case, the value of the expression as a string is used as a dynamic
regexp (*note Regexp Usage::; also *note Computed Regexps::).

   In modern implementations of `awk', a constant regular expression in
slashes by itself is also an expression.  The regexp `/REGEXP/' is an
abbreviation for the following comparison expression:

     $0 ~ /REGEXP/

   One special place where `/foo/' is _not_ an abbreviation for `$0 ~
/foo/' is when it is the righthand operand of `~' or `!~'.  *Note Using
Constant Regexps::, where this is discussed in more detail.


File: gawk.info,  Node: POSIX String Comparison,  Prev: Comparison Operators,  Up: Typing and Comparison

6.3.2.3 String Comparison With POSIX Rules
..........................................

The POSIX standard says that string comparison is performed based on
the locale's collating order.  This is usually very different from the
results obtained when doing straight character-by-character
comparison.(1)

   Because this behavior differs considerably from existing practice,
`gawk' only implements it when in POSIX mode (*note Options::).  Here
is an example to illustrate the difference, in an `en_US.UTF-8' locale:

     $ gawk 'BEGIN { printf("ABC < abc = %s\n",
     >                     ("ABC" < "abc" ? "TRUE" : "FALSE")) }'
     -| ABC < abc = TRUE
     $ gawk --posix 'BEGIN { printf("ABC < abc = %s\n",
     >                             ("ABC" < "abc" ? "TRUE" : "FALSE")) }'
     -| ABC < abc = FALSE

   ---------- Footnotes ----------

   (1) Technically, string comparison is supposed to behave the same
way as if the strings are compared with the C `strcoll()' function.


File: gawk.info,  Node: Boolean Ops,  Next: Conditional Exp,  Prev: Typing and Comparison,  Up: Truth Values and Conditions

6.3.3 Boolean Expressions
-------------------------

A "Boolean expression" is a combination of comparison expressions or
matching expressions, using the Boolean operators "or" (`||'), "and"
(`&&'), and "not" (`!'), along with parentheses to control nesting.
The truth value of the Boolean expression is computed by combining the
truth values of the component expressions.  Boolean expressions are
also referred to as "logical expressions".  The terms are equivalent.

   Boolean expressions can be used wherever comparison and matching
expressions can be used.  They can be used in `if', `while', `do', and
`for' statements (*note Statements::).  They have numeric values (one
if true, zero if false) that come into play if the result of the
Boolean expression is stored in a variable or used in arithmetic.

   In addition, every Boolean expression is also a valid pattern, so
you can use one as a pattern to control the execution of rules.  The
Boolean operators are:

`BOOLEAN1 && BOOLEAN2'
     True if both BOOLEAN1 and BOOLEAN2 are true.  For example, the
     following statement prints the current input record if it contains
     both `2400' and `foo':

          if ($0 ~ /2400/ && $0 ~ /foo/) print

     The subexpression BOOLEAN2 is evaluated only if BOOLEAN1 is true.
     This can make a difference when BOOLEAN2 contains expressions that
     have side effects. In the case of `$0 ~ /foo/ && ($2 == bar++)',
     the variable `bar' is not incremented if there is no substring
     `foo' in the record.

`BOOLEAN1 || BOOLEAN2'
     True if at least one of BOOLEAN1 or BOOLEAN2 is true.  For
     example, the following statement prints all records in the input
     that contain _either_ `2400' or `foo' or both:

          if ($0 ~ /2400/ || $0 ~ /foo/) print

     The subexpression BOOLEAN2 is evaluated only if BOOLEAN1 is false.
     This can make a difference when BOOLEAN2 contains expressions that
     have side effects.

`! BOOLEAN'
     True if BOOLEAN is false.  For example, the following program
     prints `no home!' in the unusual event that the `HOME' environment
     variable is not defined:

          BEGIN { if (! ("HOME" in ENVIRON))
                         print "no home!" }

     (The `in' operator is described in *note Reference to Elements::.)

   The `&&' and `||' operators are called "short-circuit" operators
because of the way they work.  Evaluation of the full expression is
"short-circuited" if the result can be determined part way through its
evaluation.

   Statements that use `&&' or `||' can be continued simply by putting
a newline after them.  But you cannot put a newline in front of either
of these operators without using backslash continuation (*note
Statements/Lines::).

   The actual value of an expression using the `!' operator is either
one or zero, depending upon the truth value of the expression it is
applied to.  The `!' operator is often useful for changing the sense of
a flag variable from false to true and back again. For example, the
following program is one way to print lines in between special
bracketing lines:

     $1 == "START"   { interested = ! interested; next }
     interested == 1 { print }
     $1 == "END"     { interested = ! interested; next }

The variable `interested', as with all `awk' variables, starts out
initialized to zero, which is also false.  When a line is seen whose
first field is `START', the value of `interested' is toggled to true,
using `!'. The next rule prints lines as long as `interested' is true.
When a line is seen whose first field is `END', `interested' is toggled
back to false.(1)

     NOTE: The `next' statement is discussed in *note Next Statement::.
     `next' tells `awk' to skip the rest of the rules, get the next
     record, and start processing the rules over again at the top.  The
     reason it's there is to avoid printing the bracketing `START' and
     `END' lines.

   ---------- Footnotes ----------

   (1) This program has a bug; it prints lines starting with `END'. How
would you fix it?


File: gawk.info,  Node: Conditional Exp,  Prev: Boolean Ops,  Up: Truth Values and Conditions

6.3.4 Conditional Expressions
-----------------------------

A "conditional expression" is a special kind of expression that has
three operands.  It allows you to use one expression's value to select
one of two other expressions.  The conditional expression is the same
as in the C language, as shown here:

     SELECTOR ? IF-TRUE-EXP : IF-FALSE-EXP

There are three subexpressions.  The first, SELECTOR, is always
computed first.  If it is "true" (not zero or not null), then
IF-TRUE-EXP is computed next and its value becomes the value of the
whole expression.  Otherwise, IF-FALSE-EXP is computed next and its
value becomes the value of the whole expression.  For example, the
following expression produces the absolute value of `x':

     x >= 0 ? x : -x

   Each time the conditional expression is computed, only one of
IF-TRUE-EXP and IF-FALSE-EXP is used; the other is ignored.  This is
important when the expressions have side effects.  For example, this
conditional expression examines element `i' of either array `a' or
array `b', and increments `i':

     x == y ? a[i++] : b[i++]

This is guaranteed to increment `i' exactly once, because each time
only one of the two increment expressions is executed and the other is
not.  *Note Arrays::, for more information about arrays.

   As a minor `gawk' extension, a statement that uses `?:' can be
continued simply by putting a newline after either character.  However,
putting a newline in front of either character does not work without
using backslash continuation (*note Statements/Lines::).  If `--posix'
is specified (*note Options::), then this extension is disabled.


File: gawk.info,  Node: Function Calls,  Next: Precedence,  Prev: Truth Values and Conditions,  Up: Expressions

6.4 Function Calls
==================

A "function" is a name for a particular calculation.  This enables you
to ask for it by name at any point in the program.  For example, the
function `sqrt()' computes the square root of a number.

   A fixed set of functions are "built-in", which means they are
available in every `awk' program.  The `sqrt()' function is one of
these.  *Note Built-in::, for a list of built-in functions and their
descriptions.  In addition, you can define functions for use in your
program.  *Note User-defined::, for instructions on how to do this.

   The way to use a function is with a "function call" expression,
which consists of the function name followed immediately by a list of
"arguments" in parentheses.  The arguments are expressions that provide
the raw materials for the function's calculations.  When there is more
than one argument, they are separated by commas.  If there are no
arguments, just write `()' after the function name.  The following
examples show function calls with and without arguments:

     sqrt(x^2 + y^2)        one argument
     atan2(y, x)            two arguments
     rand()                 no arguments

     CAUTION: Do not put any space between the function name and the
     open-parenthesis!  A user-defined function name looks just like
     the name of a variable--a space would make the expression look
     like concatenation of a variable with an expression inside
     parentheses.  With built-in functions, space before the
     parenthesis is harmless, but it is best not to get into the habit
     of using space to avoid mistakes with user-defined functions.

   Each function expects a particular number of arguments.  For
example, the `sqrt()' function must be called with a single argument,
the number of which to take the square root:

     sqrt(ARGUMENT)

   Some of the built-in functions have one or more optional arguments.
If those arguments are not supplied, the functions use a reasonable
default value.  *Note Built-in::, for full details.  If arguments are
omitted in calls to user-defined functions, then those arguments are
treated as local variables and initialized to the empty string (*note
User-defined::).

   As an advanced feature, `gawk' provides indirect function calls,
which is a way to choose the function to call at runtime, instead of
when you write the source code to your program. We defer discussion of
this feature until later; see *note Indirect Calls::.

   Like every other expression, the function call has a value, which is
computed by the function based on the arguments you give it.  In this
example, the value of `sqrt(ARGUMENT)' is the square root of ARGUMENT.
The following program reads numbers, one number per line, and prints the
square root of each one:

     $ awk '{ print "The square root of", $1, "is", sqrt($1) }'
     1
     -| The square root of 1 is 1
     3
     -| The square root of 3 is 1.73205
     5
     -| The square root of 5 is 2.23607
     Ctrl-d

   A function can also have side effects, such as assigning values to
certain variables or doing I/O.  This program shows how the `match()'
function (*note String Functions::) changes the variables `RSTART' and
`RLENGTH':

     {
         if (match($1, $2))
             print RSTART, RLENGTH
         else
             print "no match"
     }

Here is a sample run:

     $ awk -f matchit.awk
     aaccdd  c+
     -| 3 2
     foo     bar
     -| no match
     abcdefg e
     -| 5 1


File: gawk.info,  Node: Precedence,  Next: Locales,  Prev: Function Calls,  Up: Expressions

6.5 Operator Precedence (How Operators Nest)
============================================

"Operator precedence" determines how operators are grouped when
different operators appear close by in one expression.  For example,
`*' has higher precedence than `+'; thus, `a + b * c' means to multiply
`b' and `c', and then add `a' to the product (i.e., `a + (b * c)').

   The normal precedence of the operators can be overruled by using
parentheses.  Think of the precedence rules as saying where the
parentheses are assumed to be.  In fact, it is wise to always use
parentheses whenever there is an unusual combination of operators,
because other people who read the program may not remember what the
precedence is in this case.  Even experienced programmers occasionally
forget the exact rules, which leads to mistakes.  Explicit parentheses
help prevent any such mistakes.

   When operators of equal precedence are used together, the leftmost
operator groups first, except for the assignment, conditional, and
exponentiation operators, which group in the opposite order.  Thus, `a
- b + c' groups as `(a - b) + c' and `a = b = c' groups as `a = (b =
c)'.

   Normally the precedence of prefix unary operators does not matter,
because there is only one way to interpret them: innermost first.
Thus, `$++i' means `$(++i)' and `++$x' means `++($x)'.  However, when
another operator follows the operand, then the precedence of the unary
operators can matter.  `$x^2' means `($x)^2', but `-x^2' means
`-(x^2)', because `-' has lower precedence than `^', whereas `$' has
higher precedence.  Also, operators cannot be combined in a way that
violates the precedence rules; for example, `$$0++--' is not a valid
expression because the first `$' has higher precedence than the `++';
to avoid the problem the expression can be rewritten as `$($0++)--'.

   This table presents `awk''s operators, in order of highest to lowest
precedence:

`(...)'
     Grouping.

`$'
     Field reference.

`++ --'
     Increment, decrement.

`^ **'
     Exponentiation.  These operators group right-to-left.

`+ - !'
     Unary plus, minus, logical "not."

`* / %'
     Multiplication, division, remainder.

`+ -'
     Addition, subtraction.

`String Concatenation'
     There is no special symbol for concatenation.  The operands are
     simply written side by side (*note Concatenation::).

`< <= == != > >= >> | |&'
     Relational and redirection.  The relational operators and the
     redirections have the same precedence level.  Characters such as
     `>' serve both as relationals and as redirections; the context
     distinguishes between the two meanings.

     Note that the I/O redirection operators in `print' and `printf'
     statements belong to the statement level, not to expressions.  The
     redirection does not produce an expression that could be the
     operand of another operator.  As a result, it does not make sense
     to use a redirection operator near another operator of lower
     precedence without parentheses.  Such combinations (for example,
     `print foo > a ? b : c'), result in syntax errors.  The correct
     way to write this statement is `print foo > (a ? b : c)'.

`~ !~'
     Matching, nonmatching.

`in'
     Array membership.

`&&'
     Logical "and".

`||'
     Logical "or".

`?:'
     Conditional.  This operator groups right-to-left.

`= += -= *= /= %= ^= **='
     Assignment.  These operators group right-to-left.

     NOTE: The `|&', `**', and `**=' operators are not specified by
     POSIX.  For maximum portability, do not use them.


File: gawk.info,  Node: Locales,  Prev: Precedence,  Up: Expressions

6.6 Where You Are Makes A Difference
====================================

Modern systems support the notion of "locales": a way to tell the
system about the local character set and language.

   Once upon a time, the locale setting used to affect regexp matching
(*note Ranges and Locales::), but this is no longer true.

   Locales can affect record splitting.  For the normal case of `RS =
"\n"', the locale is largely irrelevant.  For other single-character
record separators, setting `LC_ALL=C' in the environment will give you
much better performance when reading records.  Otherwise, `gawk' has to
make several function calls, _per input character_, to find the record
terminator.

   According to POSIX, string comparison is also affected by locales
(similar to regular expressions).  The details are presented in *note
POSIX String Comparison::.

   Finally, the locale affects the value of the decimal point character
used when `gawk' parses input data.  This is discussed in detail in
*note Conversion::.


File: gawk.info,  Node: Patterns and Actions,  Next: Arrays,  Prev: Expressions,  Up: Top

7 Patterns, Actions, and Variables
**********************************

As you have already seen, each `awk' statement consists of a pattern
with an associated action.  This major node describes how you build
patterns and actions, what kinds of things you can do within actions,
and `awk''s built-in variables.

   The pattern-action rules and the statements available for use within
actions form the core of `awk' programming.  In a sense, everything
covered up to here has been the foundation that programs are built on
top of.  Now it's time to start building something useful.

* Menu:

* Pattern Overview::            What goes into a pattern.
* Using Shell Variables::       How to use shell variables with `awk'.
* Action Overview::             What goes into an action.
* Statements::                  Describes the various control statements in
                                detail.
* Built-in Variables::          Summarizes the built-in variables.


File: gawk.info,  Node: Pattern Overview,  Next: Using Shell Variables,  Up: Patterns and Actions

7.1 Pattern Elements
====================

* Menu:

* Regexp Patterns::             Using regexps as patterns.
* Expression Patterns::         Any expression can be used as a pattern.
* Ranges::                      Pairs of patterns specify record ranges.
* BEGIN/END::                   Specifying initialization and cleanup rules.
* BEGINFILE/ENDFILE::           Two special patterns for advanced control.
* Empty::                       The empty pattern, which matches every record.

   Patterns in `awk' control the execution of rules--a rule is executed
when its pattern matches the current input record.  The following is a
summary of the types of `awk' patterns:

`/REGULAR EXPRESSION/'
     A regular expression. It matches when the text of the input record
     fits the regular expression.  (*Note Regexp::.)

`EXPRESSION'
     A single expression.  It matches when its value is nonzero (if a
     number) or non-null (if a string).  (*Note Expression Patterns::.)

`PAT1, PAT2'
     A pair of patterns separated by a comma, specifying a range of
     records.  The range includes both the initial record that matches
     PAT1 and the final record that matches PAT2.  (*Note Ranges::.)

`BEGIN'
`END'
     Special patterns for you to supply startup or cleanup actions for
     your `awk' program.  (*Note BEGIN/END::.)

`BEGINFILE'
`ENDFILE'
     Special patterns for you to supply startup or cleanup actions to
     done on a per file basis.  (*Note BEGINFILE/ENDFILE::.)

`EMPTY'
     The empty pattern matches every input record.  (*Note Empty::.)


File: gawk.info,  Node: Regexp Patterns,  Next: Expression Patterns,  Up: Pattern Overview

7.1.1 Regular Expressions as Patterns
-------------------------------------

Regular expressions are one of the first kinds of patterns presented in
this book.  This kind of pattern is simply a regexp constant in the
pattern part of a rule.  Its  meaning is `$0 ~ /PATTERN/'.  The pattern
matches when the input record matches the regexp.  For example:

     /foo|bar|baz/  { buzzwords++ }
     END            { print buzzwords, "buzzwords seen" }


File: gawk.info,  Node: Expression Patterns,  Next: Ranges,  Prev: Regexp Patterns,  Up: Pattern Overview

7.1.2 Expressions as Patterns
-----------------------------

Any `awk' expression is valid as an `awk' pattern.  The pattern matches
if the expression's value is nonzero (if a number) or non-null (if a
string).  The expression is reevaluated each time the rule is tested
against a new input record.  If the expression uses fields such as
`$1', the value depends directly on the new input record's text;
otherwise, it depends on only what has happened so far in the execution
of the `awk' program.

   Comparison expressions, using the comparison operators described in
*note Typing and Comparison::, are a very common kind of pattern.
Regexp matching and nonmatching are also very common expressions.  The
left operand of the `~' and `!~' operators is a string.  The right
operand is either a constant regular expression enclosed in slashes
(`/REGEXP/'), or any expression whose string value is used as a dynamic
regular expression (*note Computed Regexps::).  The following example
prints the second field of each input record whose first field is
precisely `foo':

     $ awk '$1 == "foo" { print $2 }' BBS-list

(There is no output, because there is no BBS site with the exact name
`foo'.)  Contrast this with the following regular expression match,
which accepts any record with a first field that contains `foo':

     $ awk '$1 ~ /foo/ { print $2 }' BBS-list
     -| 555-1234
     -| 555-6699
     -| 555-6480
     -| 555-2127

   A regexp constant as a pattern is also a special case of an
expression pattern.  The expression `/foo/' has the value one if `foo'
appears in the current input record. Thus, as a pattern, `/foo/'
matches any record containing `foo'.

   Boolean expressions are also commonly used as patterns.  Whether the
pattern matches an input record depends on whether its subexpressions
match.  For example, the following command prints all the records in
`BBS-list' that contain both `2400' and `foo':

     $ awk '/2400/ && /foo/' BBS-list
     -| fooey        555-1234     2400/1200/300     B

   The following command prints all records in `BBS-list' that contain
_either_ `2400' or `foo' (or both, of course):

     $ awk '/2400/ || /foo/' BBS-list
     -| alpo-net     555-3412     2400/1200/300     A
     -| bites        555-1675     2400/1200/300     A
     -| fooey        555-1234     2400/1200/300     B
     -| foot         555-6699     1200/300          B
     -| macfoo       555-6480     1200/300          A
     -| sdace        555-3430     2400/1200/300     A
     -| sabafoo      555-2127     1200/300          C

   The following command prints all records in `BBS-list' that do _not_
contain the string `foo':

     $ awk '! /foo/' BBS-list
     -| aardvark     555-5553     1200/300          B
     -| alpo-net     555-3412     2400/1200/300     A
     -| barfly       555-7685     1200/300          A
     -| bites        555-1675     2400/1200/300     A
     -| camelot      555-0542     300               C
     -| core         555-2912     1200/300          C
     -| sdace        555-3430     2400/1200/300     A

   The subexpressions of a Boolean operator in a pattern can be
constant regular expressions, comparisons, or any other `awk'
expressions.  Range patterns are not expressions, so they cannot appear
inside Boolean patterns.  Likewise, the special patterns `BEGIN', `END',
`BEGINFILE' and `ENDFILE', which never match any input record, are not
expressions and cannot appear inside Boolean patterns.


File: gawk.info,  Node: Ranges,  Next: BEGIN/END,  Prev: Expression Patterns,  Up: Pattern Overview

7.1.3 Specifying Record Ranges with Patterns
--------------------------------------------

A "range pattern" is made of two patterns separated by a comma, in the
form `BEGPAT, ENDPAT'.  It is used to match ranges of consecutive input
records.  The first pattern, BEGPAT, controls where the range begins,
while ENDPAT controls where the pattern ends.  For example, the
following:

     awk '$1 == "on", $1 == "off"' myfile

prints every record in `myfile' between `on'/`off' pairs, inclusive.

   A range pattern starts out by matching BEGPAT against every input
record.  When a record matches BEGPAT, the range pattern is "turned on"
and the range pattern matches this record as well.  As long as the
range pattern stays turned on, it automatically matches every input
record read.  The range pattern also matches ENDPAT against every input
record; when this succeeds, the range pattern is turned off again for
the following record.  Then the range pattern goes back to checking
BEGPAT against each record.

   The record that turns on the range pattern and the one that turns it
off both match the range pattern.  If you don't want to operate on
these records, you can write `if' statements in the rule's action to
distinguish them from the records you are interested in.

   It is possible for a pattern to be turned on and off by the same
record. If the record satisfies both conditions, then the action is
executed for just that record.  For example, suppose there is text
between two identical markers (e.g., the `%' symbol), each on its own
line, that should be ignored.  A first attempt would be to combine a
range pattern that describes the delimited text with the `next'
statement (not discussed yet, *note Next Statement::).  This causes
`awk' to skip any further processing of the current record and start
over again with the next input record. Such a program looks like this:

     /^%$/,/^%$/    { next }
                    { print }

This program fails because the range pattern is both turned on and
turned off by the first line, which just has a `%' on it.  To
accomplish this task, write the program in the following manner, using
a flag:

     /^%$/     { skip = ! skip; next }
     skip == 1 { next } # skip lines with `skip' set

   In a range pattern, the comma (`,') has the lowest precedence of all
the operators (i.e., it is evaluated last).  Thus, the following
program attempts to combine a range pattern with another, simpler test:

     echo Yes | awk '/1/,/2/ || /Yes/'

   The intent of this program is `(/1/,/2/) || /Yes/'.  However, `awk'
interprets this as `/1/, (/2/ || /Yes/)'.  This cannot be changed or
worked around; range patterns do not combine with other patterns:

     $ echo Yes | gawk '(/1/,/2/) || /Yes/'
     error--> gawk: cmd. line:1: (/1/,/2/) || /Yes/
     error--> gawk: cmd. line:1:           ^ syntax error


File: gawk.info,  Node: BEGIN/END,  Next: BEGINFILE/ENDFILE,  Prev: Ranges,  Up: Pattern Overview

7.1.4 The `BEGIN' and `END' Special Patterns
--------------------------------------------

All the patterns described so far are for matching input records.  The
`BEGIN' and `END' special patterns are different.  They supply startup
and cleanup actions for `awk' programs.  `BEGIN' and `END' rules must
have actions; there is no default action for these rules because there
is no current record when they run.  `BEGIN' and `END' rules are often
referred to as "`BEGIN' and `END' blocks" by long-time `awk'
programmers.

* Menu:

* Using BEGIN/END::             How and why to use BEGIN/END rules.
* I/O And BEGIN/END::           I/O issues in BEGIN/END rules.


File: gawk.info,  Node: Using BEGIN/END,  Next: I/O And BEGIN/END,  Up: BEGIN/END

7.1.4.1 Startup and Cleanup Actions
...................................

A `BEGIN' rule is executed once only, before the first input record is
read. Likewise, an `END' rule is executed once only, after all the
input is read.  For example:

     $ awk '
     > BEGIN { print "Analysis of \"foo\"" }
     > /foo/ { ++n }
     > END   { print "\"foo\" appears", n, "times." }' BBS-list
     -| Analysis of "foo"
     -| "foo" appears 4 times.

   This program finds the number of records in the input file `BBS-list'
that contain the string `foo'.  The `BEGIN' rule prints a title for the
report.  There is no need to use the `BEGIN' rule to initialize the
counter `n' to zero, since `awk' does this automatically (*note
Variables::).  The second rule increments the variable `n' every time a
record containing the pattern `foo' is read.  The `END' rule prints the
value of `n' at the end of the run.

   The special patterns `BEGIN' and `END' cannot be used in ranges or
with Boolean operators (indeed, they cannot be used with any operators).
An `awk' program may have multiple `BEGIN' and/or `END' rules.  They
are executed in the order in which they appear: all the `BEGIN' rules
at startup and all the `END' rules at termination.  `BEGIN' and `END'
rules may be intermixed with other rules.  This feature was added in
the 1987 version of `awk' and is included in the POSIX standard.  The
original (1978) version of `awk' required the `BEGIN' rule to be placed
at the beginning of the program, the `END' rule to be placed at the
end, and only allowed one of each.  This is no longer required, but it
is a good idea to follow this template in terms of program organization
and readability.

   Multiple `BEGIN' and `END' rules are useful for writing library
functions, because each library file can have its own `BEGIN' and/or
`END' rule to do its own initialization and/or cleanup.  The order in
which library functions are named on the command line controls the
order in which their `BEGIN' and `END' rules are executed.  Therefore,
you have to be careful when writing such rules in library files so that
the order in which they are executed doesn't matter.  *Note Options::,
for more information on using library functions.  *Note Library
Functions::, for a number of useful library functions.

   If an `awk' program has only `BEGIN' rules and no other rules, then
the program exits after the `BEGIN' rule is run.(1)  However, if an
`END' rule exists, then the input is read, even if there are no other
rules in the program.  This is necessary in case the `END' rule checks
the `FNR' and `NR' variables.

   ---------- Footnotes ----------

   (1) The original version of `awk' kept reading and ignoring input
until the end of the file was seen.


File: gawk.info,  Node: I/O And BEGIN/END,  Prev: Using BEGIN/END,  Up: BEGIN/END

7.1.4.2 Input/Output from `BEGIN' and `END' Rules
.................................................

There are several (sometimes subtle) points to remember when doing I/O
from a `BEGIN' or `END' rule.  The first has to do with the value of
`$0' in a `BEGIN' rule.  Because `BEGIN' rules are executed before any
input is read, there simply is no input record, and therefore no
fields, when executing `BEGIN' rules.  References to `$0' and the fields
yield a null string or zero, depending upon the context.  One way to
give `$0' a real value is to execute a `getline' command without a
variable (*note Getline::).  Another way is simply to assign a value to
`$0'.

   The second point is similar to the first but from the other
direction.  Traditionally, due largely to implementation issues, `$0'
and `NF' were _undefined_ inside an `END' rule.  The POSIX standard
specifies that `NF' is available in an `END' rule. It contains the
number of fields from the last input record.  Most probably due to an
oversight, the standard does not say that `$0' is also preserved,
although logically one would think that it should be.  In fact, `gawk'
does preserve the value of `$0' for use in `END' rules.  Be aware,
however, that Brian Kernighan's `awk', and possibly other
implementations, do not.

   The third point follows from the first two.  The meaning of `print'
inside a `BEGIN' or `END' rule is the same as always: `print $0'.  If
`$0' is the null string, then this prints an empty record.  Many long
time `awk' programmers use an unadorned `print' in `BEGIN' and `END'
rules, to mean `print ""', relying on `$0' being null.  Although one
might generally get away with this in `BEGIN' rules, it is a very bad
idea in `END' rules, at least in `gawk'.  It is also poor style, since
if an empty line is needed in the output, the program should print one
explicitly.

   Finally, the `next' and `nextfile' statements are not allowed in a
`BEGIN' rule, because the implicit
read-a-record-and-match-against-the-rules loop has not started yet.
Similarly, those statements are not valid in an `END' rule, since all
the input has been read.  (*Note Next Statement::, and see *note
Nextfile Statement::.)


File: gawk.info,  Node: BEGINFILE/ENDFILE,  Next: Empty,  Prev: BEGIN/END,  Up: Pattern Overview

7.1.5 The `BEGINFILE' and `ENDFILE' Special Patterns
----------------------------------------------------

This minor node describes a `gawk'-specific feature.

   Two special kinds of rule, `BEGINFILE' and `ENDFILE', give you
"hooks" into `gawk''s command-line file processing loop.  As with the
`BEGIN' and `END' rules (*note BEGIN/END::), all `BEGINFILE' rules in a
program are merged, in the order they are read by `gawk', and all
`ENDFILE' rules are merged as well.

   The body of the `BEGINFILE' rules is executed just before `gawk'
reads the first record from a file.  `FILENAME' is set to the name of
the current file, and `FNR' is set to zero.

   The `BEGINFILE' rule provides you the opportunity for two tasks that
would otherwise be difficult or impossible to perform:

   * You can test if the file is readable.  Normally, it is a fatal
     error if a file named on the command line cannot be opened for
     reading.  However, you can bypass the fatal error and move on to
     the next file on the command line.

     You do this by checking if the `ERRNO' variable is not the empty
     string; if so, then `gawk' was not able to open the file. In this
     case, your program can execute the `nextfile' statement (*note
     Nextfile Statement::).  This causes `gawk' to skip the file
     entirely.  Otherwise, `gawk' exits with the usual fatal error.

   * If you have written extensions that modify the record handling (by
     inserting an "open hook"), you can invoke them at this point,
     before `gawk' has started processing the file.  (This is a _very_
     advanced feature, currently used only by the XMLgawk project
     (http://xmlgawk.sourceforge.net).)

   The `ENDFILE' rule is called when `gawk' has finished processing the
last record in an input file.  For the last input file, it will be
called before any `END' rules.

   Normally, when an error occurs when reading input in the normal input
processing loop, the error is fatal.  However, if an `ENDFILE' rule is
present, the error becomes non-fatal, and instead `ERRNO' is set.  This
makes it possible to catch and process I/O errors at the level of the
`awk' program.

   The `next' statement (*note Next Statement::) is not allowed inside
either a `BEGINFILE' or and `ENDFILE' rule.  The `nextfile' statement
(*note Nextfile Statement::) is allowed only inside a `BEGINFILE' rule,
but not inside an `ENDFILE' rule.

   The `getline' statement (*note Getline::) is restricted inside both
`BEGINFILE' and `ENDFILE'.  Only the `getline VARIABLE < FILE' form is
allowed.

   `BEGINFILE' and `ENDFILE' are `gawk' extensions.  In most other
`awk' implementations, or if `gawk' is in compatibility mode (*note
Options::), they are not special.


File: gawk.info,  Node: Empty,  Prev: BEGINFILE/ENDFILE,  Up: Pattern Overview

7.1.6 The Empty Pattern
-----------------------

An empty (i.e., nonexistent) pattern is considered to match _every_
input record.  For example, the program:

     awk '{ print $1 }' BBS-list

prints the first field of every record.


File: gawk.info,  Node: Using Shell Variables,  Next: Action Overview,  Prev: Pattern Overview,  Up: Patterns and Actions

7.2 Using Shell Variables in Programs
=====================================

`awk' programs are often used as components in larger programs written
in shell.  For example, it is very common to use a shell variable to
hold a pattern that the `awk' program searches for.  There are two ways
to get the value of the shell variable into the body of the `awk'
program.

   The most common method is to use shell quoting to substitute the
variable's value into the program inside the script.  For example, in
the following program:

     printf "Enter search pattern: "
     read pattern
     awk "/$pattern/ "'{ nmatches++ }
          END { print nmatches, "found" }' /path/to/data

the `awk' program consists of two pieces of quoted text that are
concatenated together to form the program.  The first part is
double-quoted, which allows substitution of the `pattern' shell
variable inside the quotes.  The second part is single-quoted.

   Variable substitution via quoting works, but can be potentially
messy.  It requires a good understanding of the shell's quoting rules
(*note Quoting::), and it's often difficult to correctly match up the
quotes when reading the program.

   A better method is to use `awk''s variable assignment feature (*note
Assignment Options::) to assign the shell variable's value to an `awk'
variable's value.  Then use dynamic regexps to match the pattern (*note
Computed Regexps::).  The following shows how to redo the previous
example using this technique:

     printf "Enter search pattern: "
     read pattern
     awk -v pat="$pattern" '$0 ~ pat { nmatches++ }
            END { print nmatches, "found" }' /path/to/data

Now, the `awk' program is just one single-quoted string.  The
assignment `-v pat="$pattern"' still requires double quotes, in case
there is whitespace in the value of `$pattern'.  The `awk' variable
`pat' could be named `pattern' too, but that would be more confusing.
Using a variable also provides more flexibility, since the variable can
be used anywhere inside the program--for printing, as an array
subscript, or for any other use--without requiring the quoting tricks
at every point in the program.


File: gawk.info,  Node: Action Overview,  Next: Statements,  Prev: Using Shell Variables,  Up: Patterns and Actions

7.3 Actions
===========

An `awk' program or script consists of a series of rules and function
definitions interspersed.  (Functions are described later.  *Note
User-defined::.)  A rule contains a pattern and an action, either of
which (but not both) may be omitted.  The purpose of the "action" is to
tell `awk' what to do once a match for the pattern is found.  Thus, in
outline, an `awk' program generally looks like this:

     [PATTERN]  { ACTION }
      PATTERN  [{ ACTION }]
     ...
     function NAME(ARGS) { ... }
     ...

   An action consists of one or more `awk' "statements", enclosed in
curly braces (`{...}').  Each statement specifies one thing to do.  The
statements are separated by newlines or semicolons.  The curly braces
around an action must be used even if the action contains only one
statement, or if it contains no statements at all.  However, if you
omit the action entirely, omit the curly braces as well.  An omitted
action is equivalent to `{ print $0 }':

     /foo/  { }     match `foo', do nothing -- empty action
     /foo/          match `foo', print the record -- omitted action

   The following types of statements are supported in `awk':

Expressions
     Call functions or assign values to variables (*note
     Expressions::).  Executing this kind of statement simply computes
     the value of the expression.  This is useful when the expression
     has side effects (*note Assignment Ops::).

Control statements
     Specify the control flow of `awk' programs.  The `awk' language
     gives you C-like constructs (`if', `for', `while', and `do') as
     well as a few special ones (*note Statements::).

Compound statements
     Consist of one or more statements enclosed in curly braces.  A
     compound statement is used in order to put several statements
     together in the body of an `if', `while', `do', or `for' statement.

Input statements
     Use the `getline' command (*note Getline::).  Also supplied in
     `awk' are the `next' statement (*note Next Statement::), and the
     `nextfile' statement (*note Nextfile Statement::).

Output statements
     Such as `print' and `printf'.  *Note Printing::.

Deletion statements
     For deleting array elements.  *Note Delete::.


File: gawk.info,  Node: Statements,  Next: Built-in Variables,  Prev: Action Overview,  Up: Patterns and Actions

7.4 Control Statements in Actions
=================================

"Control statements", such as `if', `while', and so on, control the
flow of execution in `awk' programs.  Most of `awk''s control
statements are patterned after similar statements in C.

   All the control statements start with special keywords, such as `if'
and `while', to distinguish them from simple expressions.  Many control
statements contain other statements.  For example, the `if' statement
contains another statement that may or may not be executed.  The
contained statement is called the "body".  To include more than one
statement in the body, group them into a single "compound statement"
with curly braces, separating them with newlines or semicolons.

* Menu:

* If Statement::                Conditionally execute some `awk'
                                statements.
* While Statement::             Loop until some condition is satisfied.
* Do Statement::                Do specified action while looping until some
                                condition is satisfied.
* For Statement::               Another looping statement, that provides
                                initialization and increment clauses.
* Switch Statement::            Switch/case evaluation for conditional
                                execution of statements based on a value.
* Break Statement::             Immediately exit the innermost enclosing loop.
* Continue Statement::          Skip to the end of the innermost enclosing
                                loop.
* Next Statement::              Stop processing the current input record.
* Nextfile Statement::          Stop processing the current file.
* Exit Statement::              Stop execution of `awk'.


File: gawk.info,  Node: If Statement,  Next: While Statement,  Up: Statements

7.4.1 The `if'-`else' Statement
-------------------------------

The `if'-`else' statement is `awk''s decision-making statement.  It
looks like this:

     if (CONDITION) THEN-BODY [else ELSE-BODY]

The CONDITION is an expression that controls what the rest of the
statement does.  If the CONDITION is true, THEN-BODY is executed;
otherwise, ELSE-BODY is executed.  The `else' part of the statement is
optional.  The condition is considered false if its value is zero or
the null string; otherwise, the condition is true.  Refer to the
following:

     if (x % 2 == 0)
         print "x is even"
     else
         print "x is odd"

   In this example, if the expression `x % 2 == 0' is true (that is, if
the value of `x' is evenly divisible by two), then the first `print'
statement is executed; otherwise, the second `print' statement is
executed.  If the `else' keyword appears on the same line as THEN-BODY
and THEN-BODY is not a compound statement (i.e., not surrounded by
curly braces), then a semicolon must separate THEN-BODY from the `else'.
To illustrate this, the previous example can be rewritten as:

     if (x % 2 == 0) print "x is even"; else
             print "x is odd"

If the `;' is left out, `awk' can't interpret the statement and it
produces a syntax error.  Don't actually write programs this way,
because a human reader might fail to see the `else' if it is not the
first thing on its line.


File: gawk.info,  Node: While Statement,  Next: Do Statement,  Prev: If Statement,  Up: Statements

7.4.2 The `while' Statement
---------------------------

In programming, a "loop" is a part of a program that can be executed
two or more times in succession.  The `while' statement is the simplest
looping statement in `awk'.  It repeatedly executes a statement as long
as a condition is true.  For example:

     while (CONDITION)
       BODY

BODY is a statement called the "body" of the loop, and CONDITION is an
expression that controls how long the loop keeps running.  The first
thing the `while' statement does is test the CONDITION.  If the
CONDITION is true, it executes the statement BODY.  (The CONDITION is
true when the value is not zero and not a null string.)  After BODY has
been executed, CONDITION is tested again, and if it is still true, BODY
is executed again.  This process repeats until the CONDITION is no
longer true.  If the CONDITION is initially false, the body of the loop
is never executed and `awk' continues with the statement following the
loop.  This example prints the first three fields of each record, one
per line:

     awk '{
            i = 1
            while (i <= 3) {
                print $i
                i++
            }
     }' inventory-shipped

The body of this loop is a compound statement enclosed in braces,
containing two statements.  The loop works in the following manner:
first, the value of `i' is set to one.  Then, the `while' statement
tests whether `i' is less than or equal to three.  This is true when
`i' equals one, so the `i'-th field is printed.  Then the `i++'
increments the value of `i' and the loop repeats.  The loop terminates
when `i' reaches four.

   A newline is not required between the condition and the body;
however using one makes the program clearer unless the body is a
compound statement or else is very simple.  The newline after the
open-brace that begins the compound statement is not required either,
but the program is harder to read without it.


File: gawk.info,  Node: Do Statement,  Next: For Statement,  Prev: While Statement,  Up: Statements

7.4.3 The `do'-`while' Statement
--------------------------------

The `do' loop is a variation of the `while' looping statement.  The
`do' loop executes the BODY once and then repeats the BODY as long as
the CONDITION is true.  It looks like this:

     do
       BODY
     while (CONDITION)

   Even if the CONDITION is false at the start, the BODY is executed at
least once (and only once, unless executing BODY makes CONDITION true).
Contrast this with the corresponding `while' statement:

     while (CONDITION)
       BODY

This statement does not execute BODY even once if the CONDITION is
false to begin with.  The following is an example of a `do' statement:

     {
            i = 1
            do {
               print $0
               i++
            } while (i <= 10)
     }

This program prints each input record 10 times.  However, it isn't a
very realistic example, since in this case an ordinary `while' would do
just as well.  This situation reflects actual experience; only
occasionally is there a real use for a `do' statement.


File: gawk.info,  Node: For Statement,  Next: Switch Statement,  Prev: Do Statement,  Up: Statements

7.4.4 The `for' Statement
-------------------------

The `for' statement makes it more convenient to count iterations of a
loop.  The general form of the `for' statement looks like this:

     for (INITIALIZATION; CONDITION; INCREMENT)
       BODY

The INITIALIZATION, CONDITION, and INCREMENT parts are arbitrary `awk'
expressions, and BODY stands for any `awk' statement.

   The `for' statement starts by executing INITIALIZATION.  Then, as
long as the CONDITION is true, it repeatedly executes BODY and then
INCREMENT.  Typically, INITIALIZATION sets a variable to either zero or
one, INCREMENT adds one to it, and CONDITION compares it against the
desired number of iterations.  For example:

     awk '{
            for (i = 1; i <= 3; i++)
               print $i
     }' inventory-shipped

This prints the first three fields of each input record, with one field
per line.

   It isn't possible to set more than one variable in the
INITIALIZATION part without using a multiple assignment statement such
as `x = y = 0'. This makes sense only if all the initial values are
equal.  (But it is possible to initialize additional variables by
writing their assignments as separate statements preceding the `for'
loop.)

   The same is true of the INCREMENT part. Incrementing additional
variables requires separate statements at the end of the loop.  The C
compound expression, using C's comma operator, is useful in this
context but it is not supported in `awk'.

   Most often, INCREMENT is an increment expression, as in the previous
example.  But this is not required; it can be any expression
whatsoever.  For example, the following statement prints all the powers
of two between 1 and 100:

     for (i = 1; i <= 100; i *= 2)
       print i

   If there is nothing to be done, any of the three expressions in the
parentheses following the `for' keyword may be omitted.  Thus,
`for (; x > 0;)' is equivalent to `while (x > 0)'.  If the CONDITION is
omitted, it is treated as true, effectively yielding an "infinite loop"
(i.e., a loop that never terminates).

   In most cases, a `for' loop is an abbreviation for a `while' loop,
as shown here:

     INITIALIZATION
     while (CONDITION) {
       BODY
       INCREMENT
     }

The only exception is when the `continue' statement (*note Continue
Statement::) is used inside the loop. Changing a `for' statement to a
`while' statement in this way can change the effect of the `continue'
statement inside the loop.

   The `awk' language has a `for' statement in addition to a `while'
statement because a `for' loop is often both less work to type and more
natural to think of.  Counting the number of iterations is very common
in loops.  It can be easier to think of this counting as part of
looping rather than as something to do inside the loop.

   There is an alternate version of the `for' loop, for iterating over
all the indices of an array:

     for (i in array)
         DO SOMETHING WITH array[i]

*Note Scanning an Array::, for more information on this version of the
`for' loop.


File: gawk.info,  Node: Switch Statement,  Next: Break Statement,  Prev: For Statement,  Up: Statements

7.4.5 The `switch' Statement
----------------------------

The `switch' statement allows the evaluation of an expression and the
execution of statements based on a `case' match. Case statements are
checked for a match in the order they are defined.  If no suitable
`case' is found, the `default' section is executed, if supplied.

   Each `case' contains a single constant, be it numeric, string, or
regexp.  The `switch' expression is evaluated, and then each `case''s
constant is compared against the result in turn. The type of constant
determines the comparison: numeric or string do the usual comparisons.
A regexp constant does a regular expression match against the string
value of the original expression.  The general form of the `switch'
statement looks like this:

     switch (EXPRESSION) {
     case VALUE OR REGULAR EXPRESSION:
         CASE-BODY
     default:
         DEFAULT-BODY
     }

   Control flow in the `switch' statement works as it does in C. Once a
match to a given case is made, the case statement bodies execute until
a `break', `continue', `next', `nextfile'  or `exit' is encountered, or
the end of the `switch' statement itself. For example:

     switch (NR * 2 + 1) {
     case 3:
     case "11":
         print NR - 1
         break

     case /2[[:digit:]]+/:
         print NR

     default:
         print NR + 1

     case -1:
         print NR * -1
     }

   Note that if none of the statements specified above halt execution
of a matched `case' statement, execution falls through to the next
`case' until execution halts. In the above example, for any case value
starting with `2' followed by one or more digits, the `print' statement
is executed and then falls through into the `default' section,
executing its `print' statement. In turn, the -1 case will also be
executed since the `default' does not halt execution.

   This `switch' statement is a `gawk' extension.  If `gawk' is in
compatibility mode (*note Options::), it is not available.


File: gawk.info,  Node: Break Statement,  Next: Continue Statement,  Prev: Switch Statement,  Up: Statements

7.4.6 The `break' Statement
---------------------------

The `break' statement jumps out of the innermost `for', `while', or
`do' loop that encloses it.  The following example finds the smallest
divisor of any integer, and also identifies prime numbers:

     # find smallest divisor of num
     {
        num = $1
        for (div = 2; div * div <= num; div++) {
          if (num % div == 0)
            break
        }
        if (num % div == 0)
          printf "Smallest divisor of %d is %d\n", num, div
        else
          printf "%d is prime\n", num
     }

   When the remainder is zero in the first `if' statement, `awk'
immediately "breaks out" of the containing `for' loop.  This means that
`awk' proceeds immediately to the statement following the loop and
continues processing.  (This is very different from the `exit'
statement, which stops the entire `awk' program.  *Note Exit
Statement::.)

   The following program illustrates how the CONDITION of a `for' or
`while' statement could be replaced with a `break' inside an `if':

     # find smallest divisor of num
     {
       num = $1
       for (div = 2; ; div++) {
         if (num % div == 0) {
           printf "Smallest divisor of %d is %d\n", num, div
           break
         }
         if (div * div > num) {
           printf "%d is prime\n", num
           break
         }
       }
     }

   The `break' statement is also used to break out of the `switch'
statement.  This is discussed in *note Switch Statement::.

   The `break' statement has no meaning when used outside the body of a
loop or `switch'.  However, although it was never documented,
historical implementations of `awk' treated the `break' statement
outside of a loop as if it were a `next' statement (*note Next
Statement::).  (d.c.)  Recent versions of Brian Kernighan's `awk' no
longer allow this usage, nor does `gawk'.


File: gawk.info,  Node: Continue Statement,  Next: Next Statement,  Prev: Break Statement,  Up: Statements

7.4.7 The `continue' Statement
------------------------------

Similar to `break', the `continue' statement is used only inside `for',
`while', and `do' loops.  It skips over the rest of the loop body,
causing the next cycle around the loop to begin immediately.  Contrast
this with `break', which jumps out of the loop altogether.

   The `continue' statement in a `for' loop directs `awk' to skip the
rest of the body of the loop and resume execution with the
increment-expression of the `for' statement.  The following program
illustrates this fact:

     BEGIN {
          for (x = 0; x <= 20; x++) {
              if (x == 5)
                  continue
              printf "%d ", x
          }
          print ""
     }

This program prints all the numbers from 0 to 20--except for 5, for
which the `printf' is skipped.  Because the increment `x++' is not
skipped, `x' does not remain stuck at 5.  Contrast the `for' loop from
the previous example with the following `while' loop:

     BEGIN {
          x = 0
          while (x <= 20) {
              if (x == 5)
                  continue
              printf "%d ", x
              x++
          }
          print ""
     }

This program loops forever once `x' reaches 5.

   The `continue' statement has no special meaning with respect to the
`switch' statement, nor does it any meaning when used outside the body
of a loop.  Historical versions of `awk' treated a `continue' statement
outside a loop the same way they treated a `break' statement outside a
loop: as if it were a `next' statement (*note Next Statement::).
(d.c.)  Recent versions of Brian Kernighan's `awk' no longer work this
way, nor does `gawk'.


File: gawk.info,  Node: Next Statement,  Next: Nextfile Statement,  Prev: Continue Statement,  Up: Statements

7.4.8 The `next' Statement
--------------------------

The `next' statement forces `awk' to immediately stop processing the
current record and go on to the next record.  This means that no
further rules are executed for the current record, and the rest of the
current rule's action isn't executed.

   Contrast this with the effect of the `getline' function (*note
Getline::).  That also causes `awk' to read the next record
immediately, but it does not alter the flow of control in any way
(i.e., the rest of the current action executes with a new input record).

   At the highest level, `awk' program execution is a loop that reads
an input record and then tests each rule's pattern against it.  If you
think of this loop as a `for' statement whose body contains the rules,
then the `next' statement is analogous to a `continue' statement. It
skips to the end of the body of this implicit loop and executes the
increment (which reads another record).

   For example, suppose an `awk' program works only on records with
four fields, and it shouldn't fail when given bad input.  To avoid
complicating the rest of the program, write a "weed out" rule near the
beginning, in the following manner:

     NF != 4 {
       err = sprintf("%s:%d: skipped: NF != 4\n", FILENAME, FNR)
       print err > "/dev/stderr"
       next
     }

Because of the `next' statement, the program's subsequent rules won't
see the bad record.  The error message is redirected to the standard
error output stream, as error messages should be.  For more detail see
*note Special Files::.

   If the `next' statement causes the end of the input to be reached,
then the code in any `END' rules is executed.  *Note BEGIN/END::.

   The `next' statement is not allowed inside `BEGINFILE' and `ENDFILE'
rules. *Note BEGINFILE/ENDFILE::.

   According to the POSIX standard, the behavior is undefined if the
`next' statement is used in a `BEGIN' or `END' rule.  `gawk' treats it
as a syntax error.  Although POSIX permits it, some other `awk'
implementations don't allow the `next' statement inside function bodies
(*note User-defined::).  Just as with any other `next' statement, a
`next' statement inside a function body reads the next record and
starts processing it with the first rule in the program.


File: gawk.info,  Node: Nextfile Statement,  Next: Exit Statement,  Prev: Next Statement,  Up: Statements

7.4.9 Using `gawk''s `nextfile' Statement
-----------------------------------------

`gawk' provides the `nextfile' statement, which is similar to the
`next' statement. (c.e.)  However, instead of abandoning processing of
the current record, the `nextfile' statement instructs `gawk' to stop
processing the current data file.

   The `nextfile' statement is a `gawk' extension.  In most other `awk'
implementations, or if `gawk' is in compatibility mode (*note
Options::), `nextfile' is not special.

   Upon execution of the `nextfile' statement, any `ENDFILE' rules are
executed, `FILENAME' is updated to the name of the next data file
listed on the command line, `FNR' is reset to one, `ARGIND' is
incremented, any `BEGINFILE' rules are executed, and processing starts
over with the first rule in the program.  (`ARGIND' hasn't been
introduced yet. *Note Built-in Variables::.)  If the `nextfile'
statement causes the end of the input to be reached, then the code in
any `END' rules is executed.  *Note BEGIN/END::.

   The `nextfile' statement is useful when there are many data files to
process but it isn't necessary to process every record in every file.
Normally, in order to move on to the next data file, a program has to
continue scanning the unwanted records.  The `nextfile' statement
accomplishes this much more efficiently.

   In addition, `nextfile' is useful inside a `BEGINFILE' rule to skip
over a file that would otherwise cause `gawk' to exit with a fatal
error. *Note BEGINFILE/ENDFILE::.

   While one might think that `close(FILENAME)' would accomplish the
same as `nextfile', this isn't true.  `close()' is reserved for closing
files, pipes, and coprocesses that are opened with redirections.  It is
not related to the main processing that `awk' does with the files
listed in `ARGV'.

   The current version of the Brian Kernighan's `awk' (*note Other
Versions::) also supports `nextfile'.  However, it doesn't allow the
`nextfile' statement inside function bodies (*note User-defined::).
`gawk' does; a `nextfile' inside a function body reads the next record
and starts processing it with the first rule in the program, just as
any other `nextfile' statement.


File: gawk.info,  Node: Exit Statement,  Prev: Nextfile Statement,  Up: Statements

7.4.10 The `exit' Statement
---------------------------

The `exit' statement causes `awk' to immediately stop executing the
current rule and to stop processing input; any remaining input is
ignored.  The `exit' statement is written as follows:

     exit [RETURN CODE]

   When an `exit' statement is executed from a `BEGIN' rule, the
program stops processing everything immediately.  No input records are
read.  However, if an `END' rule is present, as part of executing the
`exit' statement, the `END' rule is executed (*note BEGIN/END::).  If
`exit' is used in the body of an `END' rule, it causes the program to
stop immediately.

   An `exit' statement that is not part of a `BEGIN' or `END' rule
stops the execution of any further automatic rules for the current
record, skips reading any remaining input records, and executes the
`END' rule if there is one.  Any `ENDFILE' rules are also skipped; they
are not executed.

   In such a case, if you don't want the `END' rule to do its job, set
a variable to nonzero before the `exit' statement and check that
variable in the `END' rule.  *Note Assert Function::, for an example
that does this.

   If an argument is supplied to `exit', its value is used as the exit
status code for the `awk' process.  If no argument is supplied, `exit'
causes `awk' to return a "success" status.  In the case where an
argument is supplied to a first `exit' statement, and then `exit' is
called a second time from an `END' rule with no argument, `awk' uses
the previously supplied exit value.  (d.c.)  *Note Exit Status::, for
more information.

   For example, suppose an error condition occurs that is difficult or
impossible to handle.  Conventionally, programs report this by exiting
with a nonzero status.  An `awk' program can do this using an `exit'
statement with a nonzero argument, as shown in the following example:

     BEGIN {
            if (("date" | getline date_now) <= 0) {
              print "Can't get system date" > "/dev/stderr"
              exit 1
            }
            print "current date is", date_now
            close("date")
     }

     NOTE: For full portability, exit values should be between zero and
     126, inclusive.  Negative values, and values of 127 or greater,
     may not produce consistent results across different operating
     systems.


File: gawk.info,  Node: Built-in Variables,  Prev: Statements,  Up: Patterns and Actions

7.5 Built-in Variables
======================

Most `awk' variables are available to use for your own purposes; they
never change unless your program assigns values to them, and they never
affect anything unless your program examines them.  However, a few
variables in `awk' have special built-in meanings.  `awk' examines some
of these automatically, so that they enable you to tell `awk' how to do
certain things.  Others are set automatically by `awk', so that they
carry information from the internal workings of `awk' to your program.

   This minor node documents all the built-in variables of `gawk', most
of which are also documented in the chapters describing their areas of
activity.

* Menu:

* User-modified::               Built-in variables that you change to control
                                `awk'.
* Auto-set::                    Built-in variables where `awk' gives
                                you information.
* ARGC and ARGV::               Ways to use `ARGC' and `ARGV'.


File: gawk.info,  Node: User-modified,  Next: Auto-set,  Up: Built-in Variables

7.5.1 Built-in Variables That Control `awk'
-------------------------------------------

The following is an alphabetical list of variables that you can change
to control how `awk' does certain things. The variables that are
specific to `gawk' are marked with a pound sign (`#').

`BINMODE #'
     On non-POSIX systems, this variable specifies use of binary mode
     for all I/O.  Numeric values of one, two, or three specify that
     input files, output files, or all files, respectively, should use
     binary I/O.  A numeric value less than zero is treated as zero,
     and a numeric value greater than three is treated as three.
     Alternatively, string values of `"r"' or `"w"' specify that input
     files and output files, respectively, should use binary I/O.  A
     string value of `"rw"' or `"wr"' indicates that all files should
     use binary I/O.  Any other string value is treated the same as
     `"rw"', but causes `gawk' to generate a warning message.
     `BINMODE' is described in more detail in *note PC Using::.

     This variable is a `gawk' extension.  In other `awk'
     implementations (except `mawk', *note Other Versions::), or if
     `gawk' is in compatibility mode (*note Options::), it is not
     special.

`CONVFMT'
     This string controls conversion of numbers to strings (*note
     Conversion::).  It works by being passed, in effect, as the first
     argument to the `sprintf()' function (*note String Functions::).
     Its default value is `"%.6g"'.  `CONVFMT' was introduced by the
     POSIX standard.

`FIELDWIDTHS #'
     This is a space-separated list of columns that tells `gawk' how to
     split input with fixed columnar boundaries.  Assigning a value to
     `FIELDWIDTHS' overrides the use of `FS' and `FPAT' for field
     splitting.  *Note Constant Size::, for more information.

     If `gawk' is in compatibility mode (*note Options::), then
     `FIELDWIDTHS' has no special meaning, and field-splitting
     operations occur based exclusively on the value of `FS'.

`FPAT #'
     This is a regular expression (as a string) that tells `gawk' to
     create the fields based on text that matches the regular
     expression.  Assigning a value to `FPAT' overrides the use of `FS'
     and `FIELDWIDTHS' for field splitting.  *Note Splitting By
     Content::, for more information.

     If `gawk' is in compatibility mode (*note Options::), then `FPAT'
     has no special meaning, and field-splitting operations occur based
     exclusively on the value of `FS'.

`FS'
     This is the input field separator (*note Field Separators::).  The
     value is a single-character string or a multi-character regular
     expression that matches the separations between fields in an input
     record.  If the value is the null string (`""'), then each
     character in the record becomes a separate field.  (This behavior
     is a `gawk' extension. POSIX `awk' does not specify the behavior
     when `FS' is the null string.  Nonetheless, some other versions of
     `awk' also treat `""' specially.)

     The default value is `" "', a string consisting of a single space.
     As a special exception, this value means that any sequence of
     spaces, TABs, and/or newlines is a single separator.(1)  It also
     causes spaces, TABs, and newlines at the beginning and end of a
     record to be ignored.

     You can set the value of `FS' on the command line using the `-F'
     option:

          awk -F, 'PROGRAM' INPUT-FILES

     If `gawk' is using `FIELDWIDTHS' or `FPAT' for field splitting,
     assigning a value to `FS' causes `gawk' to return to the normal,
     `FS'-based field splitting. An easy way to do this is to simply
     say `FS = FS', perhaps with an explanatory comment.

`IGNORECASE #'
     If `IGNORECASE' is nonzero or non-null, then all string comparisons
     and all regular expression matching are case independent.  Thus,
     regexp matching with `~' and `!~', as well as the `gensub()',
     `gsub()', `index()', `match()', `patsplit()', `split()', and
     `sub()' functions, record termination with `RS', and field
     splitting with `FS' and `FPAT', all ignore case when doing their
     particular regexp operations.  However, the value of `IGNORECASE'
     does _not_ affect array subscripting and it does not affect field
     splitting when using a single-character field separator.  *Note
     Case-sensitivity::.

     If `gawk' is in compatibility mode (*note Options::), then
     `IGNORECASE' has no special meaning.  Thus, string and regexp
     operations are always case-sensitive.

`LINT #'
     When this variable is true (nonzero or non-null), `gawk' behaves
     as if the `--lint' command-line option is in effect.  (*note
     Options::).  With a value of `"fatal"', lint warnings become fatal
     errors.  With a value of `"invalid"', only warnings about things
     that are actually invalid are issued. (This is not fully
     implemented yet.)  Any other true value prints nonfatal warnings.
     Assigning a false value to `LINT' turns off the lint warnings.

     This variable is a `gawk' extension.  It is not special in other
     `awk' implementations.  Unlike the other special variables,
     changing `LINT' does affect the production of lint warnings, even
     if `gawk' is in compatibility mode.  Much as the `--lint' and
     `--traditional' options independently control different aspects of
     `gawk''s behavior, the control of lint warnings during program
     execution is independent of the flavor of `awk' being executed.

`OFMT'
     This string controls conversion of numbers to strings (*note
     Conversion::) for printing with the `print' statement.  It works
     by being passed as the first argument to the `sprintf()' function
     (*note String Functions::).  Its default value is `"%.6g"'.
     Earlier versions of `awk' also used `OFMT' to specify the format
     for converting numbers to strings in general expressions; this is
     now done by `CONVFMT'.

`OFS'
     This is the output field separator (*note Output Separators::).
     It is output between the fields printed by a `print' statement.
     Its default value is `" "', a string consisting of a single space.

`ORS'
     This is the output record separator.  It is output at the end of
     every `print' statement.  Its default value is `"\n"', the newline
     character.  (*Note Output Separators::.)

`RS'
     This is `awk''s input record separator.  Its default value is a
     string containing a single newline character, which means that an
     input record consists of a single line of text.  It can also be
     the null string, in which case records are separated by runs of
     blank lines.  If it is a regexp, records are separated by matches
     of the regexp in the input text.  (*Note Records::.)

     The ability for `RS' to be a regular expression is a `gawk'
     extension.  In most other `awk' implementations, or if `gawk' is
     in compatibility mode (*note Options::), just the first character
     of `RS''s value is used.

`SUBSEP'
     This is the subscript separator.  It has the default value of
     `"\034"' and is used to separate the parts of the indices of a
     multidimensional array.  Thus, the expression `foo["A", "B"]'
     really accesses `foo["A\034B"]' (*note Multi-dimensional::).

`TEXTDOMAIN #'
     This variable is used for internationalization of programs at the
     `awk' level.  It sets the default text domain for specially marked
     string constants in the source text, as well as for the
     `dcgettext()', `dcngettext()' and `bindtextdomain()' functions
     (*note Internationalization::).  The default value of `TEXTDOMAIN'
     is `"messages"'.

     This variable is a `gawk' extension.  In other `awk'
     implementations, or if `gawk' is in compatibility mode (*note
     Options::), it is not special.

   ---------- Footnotes ----------

   (1) In POSIX `awk', newline does not count as whitespace.


File: gawk.info,  Node: Auto-set,  Next: ARGC and ARGV,  Prev: User-modified,  Up: Built-in Variables

7.5.2 Built-in Variables That Convey Information
------------------------------------------------

The following is an alphabetical list of variables that `awk' sets
automatically on certain occasions in order to provide information to
your program.  The variables that are specific to `gawk' are marked
with a pound sign (`#').

`ARGC, ARGV'
     The command-line arguments available to `awk' programs are stored
     in an array called `ARGV'.  `ARGC' is the number of command-line
     arguments present.  *Note Other Arguments::.  Unlike most `awk'
     arrays, `ARGV' is indexed from 0 to `ARGC' - 1.  In the following
     example:

          $ awk 'BEGIN {
          >         for (i = 0; i < ARGC; i++)
          >             print ARGV[i]
          >      }' inventory-shipped BBS-list
          -| awk
          -| inventory-shipped
          -| BBS-list

     `ARGV[0]' contains `awk', `ARGV[1]' contains `inventory-shipped',
     and `ARGV[2]' contains `BBS-list'.  The value of `ARGC' is three,
     one more than the index of the last element in `ARGV', because the
     elements are numbered from zero.

     The names `ARGC' and `ARGV', as well as the convention of indexing
     the array from 0 to `ARGC' - 1, are derived from the C language's
     method of accessing command-line arguments.

     The value of `ARGV[0]' can vary from system to system.  Also, you
     should note that the program text is _not_ included in `ARGV', nor
     are any of `awk''s command-line options.  *Note ARGC and ARGV::,
     for information about how `awk' uses these variables.  (d.c.)

`ARGIND #'
     The index in `ARGV' of the current file being processed.  Every
     time `gawk' opens a new data file for processing, it sets `ARGIND'
     to the index in `ARGV' of the file name.  When `gawk' is
     processing the input files, `FILENAME == ARGV[ARGIND]' is always
     true.

     This variable is useful in file processing; it allows you to tell
     how far along you are in the list of data files as well as to
     distinguish between successive instances of the same file name on
     the command line.

     While you can change the value of `ARGIND' within your `awk'
     program, `gawk' automatically sets it to a new value when the next
     file is opened.

     This variable is a `gawk' extension.  In other `awk'
     implementations, or if `gawk' is in compatibility mode (*note
     Options::), it is not special.

`ENVIRON'
     An associative array containing the values of the environment.
     The array indices are the environment variable names; the elements
     are the values of the particular environment variables.  For
     example, `ENVIRON["HOME"]' might be `/home/arnold'.  Changing this
     array does not affect the environment passed on to any programs
     that `awk' may spawn via redirection or the `system()' function.

     Some operating systems may not have environment variables.  On
     such systems, the `ENVIRON' array is empty (except for
     `ENVIRON["AWKPATH"]', *note AWKPATH Variable::).

`ERRNO #'
     If a system error occurs during a redirection for `getline',
     during a read for `getline', or during a `close()' operation, then
     `ERRNO' contains a string describing the error.

     In addition, `gawk' clears `ERRNO' before opening each
     command-line input file. This enables checking if the file is
     readable inside a `BEGINFILE' pattern (*note BEGINFILE/ENDFILE::).

     Otherwise, `ERRNO' works similarly to the C variable `errno'.
     Except for the case just mentioned, `gawk' _never_ clears it (sets
     it to zero or `""').  Thus, you should only expect its value to be
     meaningful when an I/O operation returns a failure value, such as
     `getline' returning -1.  You are, of course, free to clear it
     yourself before doing an I/O operation.

     This variable is a `gawk' extension.  In other `awk'
     implementations, or if `gawk' is in compatibility mode (*note
     Options::), it is not special.

`FILENAME'
     The name of the file that `awk' is currently reading.  When no
     data files are listed on the command line, `awk' reads from the
     standard input and `FILENAME' is set to `"-"'.  `FILENAME' is
     changed each time a new file is read (*note Reading Files::).
     Inside a `BEGIN' rule, the value of `FILENAME' is `""', since
     there are no input files being processed yet.(1) (d.c.)  Note,
     though, that using `getline' (*note Getline::) inside a `BEGIN'
     rule can give `FILENAME' a value.

`FNR'
     The current record number in the current file.  `FNR' is
     incremented each time a new record is read (*note Records::).  It
     is reinitialized to zero each time a new input file is started.

`NF'
     The number of fields in the current input record.  `NF' is set
     each time a new record is read, when a new field is created or
     when `$0' changes (*note Fields::).

     Unlike most of the variables described in this node, assigning a
     value to `NF' has the potential to affect `awk''s internal
     workings.  In particular, assignments to `NF' can be used to
     create or remove fields from the current record. *Note Changing
     Fields::.

`NR'
     The number of input records `awk' has processed since the
     beginning of the program's execution (*note Records::).  `NR' is
     incremented each time a new record is read.

`PROCINFO #'
     The elements of this array provide access to information about the
     running `awk' program.  The following elements (listed
     alphabetically) are guaranteed to be available:

    `PROCINFO["egid"]'
          The value of the `getegid()' system call.

    `PROCINFO["euid"]'
          The value of the `geteuid()' system call.

    `PROCINFO["FS"]'
          This is `"FS"' if field splitting with `FS' is in effect,
          `"FIELDWIDTHS"' if field splitting with `FIELDWIDTHS' is in
          effect, or `"FPAT"' if field matching with `FPAT' is in
          effect.

    `PROCINFO["gid"]'
          The value of the `getgid()' system call.

    `PROCINFO["pgrpid"]'
          The process group ID of the current process.

    `PROCINFO["pid"]'
          The process ID of the current process.

    `PROCINFO["ppid"]'
          The parent process ID of the current process.

    `PROCINFO["sorted_in"]'
          If this element exists in `PROCINFO', its value controls the
          order in which array indices will be processed by `for (index
          in array) ...' loops.  Since this is an advanced feature, we
          defer the full description until later; see *note Scanning an
          Array::.

    `PROCINFO["strftime"]'
          The default time format string for `strftime()'.  Assigning a
          new value to this element changes the default.  *Note Time
          Functions::.

    `PROCINFO["uid"]'
          The value of the `getuid()' system call.

    `PROCINFO["version"]'
          The version of `gawk'.

     On some systems, there may be elements in the array, `"group1"'
     through `"groupN"' for some N. N is the number of supplementary
     groups that the process has.  Use the `in' operator to test for
     these elements (*note Reference to Elements::).

     The `PROCINFO' array is also used to cause coprocesses to
     communicate over pseudo-ttys instead of through two-way pipes;
     this is discussed further in *note Two-way I/O::.

     This array is a `gawk' extension.  In other `awk' implementations,
     or if `gawk' is in compatibility mode (*note Options::), it is not
     special.

`RLENGTH'
     The length of the substring matched by the `match()' function
     (*note String Functions::).  `RLENGTH' is set by invoking the
     `match()' function.  Its value is the length of the matched
     string, or -1 if no match is found.

`RSTART'
     The start-index in characters of the substring that is matched by
     the `match()' function (*note String Functions::).  `RSTART' is
     set by invoking the `match()' function.  Its value is the position
     of the string where the matched substring starts, or zero if no
     match was found.

`RT #'
     This is set each time a record is read. It contains the input text
     that matched the text denoted by `RS', the record separator.

     This variable is a `gawk' extension.  In other `awk'
     implementations, or if `gawk' is in compatibility mode (*note
     Options::), it is not special.

Advanced Notes: Changing `NR' and `FNR'
---------------------------------------

`awk' increments `NR' and `FNR' each time it reads a record, instead of
setting them to the absolute value of the number of records read.  This
means that a program can change these variables and their new values
are incremented for each record.  (d.c.)  The following example shows
this:

     $ echo '1
     > 2
     > 3
     > 4' | awk 'NR == 2 { NR = 17 }
     > { print NR }'
     -| 1
     -| 17
     -| 18
     -| 19

Before `FNR' was added to the `awk' language (*note V7/SVR3.1::), many
`awk' programs used this feature to track the number of records in a
file by resetting `NR' to zero when `FILENAME' changed.

   ---------- Footnotes ----------

   (1) Some early implementations of Unix `awk' initialized `FILENAME'
to `"-"', even if there were data files to be processed. This behavior
was incorrect and should not be relied upon in your programs.


File: gawk.info,  Node: ARGC and ARGV,  Prev: Auto-set,  Up: Built-in Variables

7.5.3 Using `ARGC' and `ARGV'
-----------------------------

*note Auto-set::, presented the following program describing the
information contained in `ARGC' and `ARGV':

     $ awk 'BEGIN {
     >        for (i = 0; i < ARGC; i++)
     >            print ARGV[i]
     >      }' inventory-shipped BBS-list
     -| awk
     -| inventory-shipped
     -| BBS-list

In this example, `ARGV[0]' contains `awk', `ARGV[1]' contains
`inventory-shipped', and `ARGV[2]' contains `BBS-list'.  Notice that
the `awk' program is not entered in `ARGV'.  The other command-line
options, with their arguments, are also not entered.  This includes
variable assignments done with the `-v' option (*note Options::).
Normal variable assignments on the command line _are_ treated as
arguments and do show up in the `ARGV' array.  Given the following
program in a file named `showargs.awk':

     BEGIN {
         printf "A=%d, B=%d\n", A, B
         for (i = 0; i < ARGC; i++)
             printf "\tARGV[%d] = %s\n", i, ARGV[i]
     }
     END   { printf "A=%d, B=%d\n", A, B }

Running it produces the following:

     $ awk -v A=1 -f showargs.awk B=2 /dev/null
     -| A=1, B=0
     -|        ARGV[0] = awk
     -|        ARGV[1] = B=2
     -|        ARGV[2] = /dev/null
     -| A=1, B=2

   A program can alter `ARGC' and the elements of `ARGV'.  Each time
`awk' reaches the end of an input file, it uses the next element of
`ARGV' as the name of the next input file.  By storing a different
string there, a program can change which files are read.  Use `"-"' to
represent the standard input.  Storing additional elements and
incrementing `ARGC' causes additional files to be read.

   If the value of `ARGC' is decreased, that eliminates input files
from the end of the list.  By recording the old value of `ARGC'
elsewhere, a program can treat the eliminated arguments as something
other than file names.

   To eliminate a file from the middle of the list, store the null
string (`""') into `ARGV' in place of the file's name.  As a special
feature, `awk' ignores file names that have been replaced with the null
string.  Another option is to use the `delete' statement to remove
elements from `ARGV' (*note Delete::).

   All of these actions are typically done in the `BEGIN' rule, before
actual processing of the input begins.  *Note Split Program::, and see
*note Tee Program::, for examples of each way of removing elements from
`ARGV'.  The following fragment processes `ARGV' in order to examine,
and then remove, command-line options:

     BEGIN {
         for (i = 1; i < ARGC; i++) {
             if (ARGV[i] == "-v")
                 verbose = 1
             else if (ARGV[i] == "-q")
                 debug = 1
             else if (ARGV[i] ~ /^-./) {
                 e = sprintf("%s: unrecognized option -- %c",
                         ARGV[0], substr(ARGV[i], 2, 1))
                 print e > "/dev/stderr"
             } else
                 break
             delete ARGV[i]
         }
     }

   To actually get the options into the `awk' program, end the `awk'
options with `--' and then supply the `awk' program's options, in the
following manner:

     awk -f myprog -- -v -q file1 file2 ...

   This is not necessary in `gawk'. Unless `--posix' has been
specified, `gawk' silently puts any unrecognized options into `ARGV'
for the `awk' program to deal with.  As soon as it sees an unknown
option, `gawk' stops looking for other options that it might otherwise
recognize.  The previous example with `gawk' would be:

     gawk -f myprog -q -v file1 file2 ...

Because `-q' is not a valid `gawk' option, it and the following `-v'
are passed on to the `awk' program.  (*Note Getopt Function::, for an
`awk' library function that parses command-line options.)


File: gawk.info,  Node: Arrays,  Next: Functions,  Prev: Patterns and Actions,  Up: Top

8 Arrays in `awk'
*****************

An "array" is a table of values called "elements".  The elements of an
array are distinguished by their "indices".  Indices may be either
numbers or strings.

   This major node describes how arrays work in `awk', how to use array
elements, how to scan through every element in an array, and how to
remove array elements.  It also describes how `awk' simulates
multidimensional arrays, as well as some of the less obvious points
about array usage.  The major node moves on to discuss `gawk''s facility
for sorting arrays, and ends with a brief description of `gawk''s
ability to support true multidimensional arrays.

   `awk' maintains a single set of names that may be used for naming
variables, arrays, and functions (*note User-defined::).  Thus, you
cannot have a variable and an array with the same name in the same
`awk' program.

* Menu:

* Array Basics::                The basics of arrays.
* Delete::                      The `delete' statement removes an element
                                from an array.
* Numeric Array Subscripts::    How to use numbers as subscripts in
                                `awk'.
* Uninitialized Subscripts::    Using Uninitialized variables as subscripts.
* Multi-dimensional::           Emulating multidimensional arrays in
                                `awk'.
* Arrays of Arrays::            True multidimensional arrays.


File: gawk.info,  Node: Array Basics,  Next: Delete,  Up: Arrays

8.1 The Basics of Arrays
========================

This minor node presents the basics: working with elements in arrays
one at a time, and traversing all of the elements in an array.

* Menu:

* Array Intro::                 Introduction to Arrays
* Reference to Elements::       How to examine one element of an array.
* Assigning Elements::          How to change an element of an array.
* Array Example::               Basic Example of an Array
* Scanning an Array::           A variation of the `for' statement. It
                                loops through the indices of an array's
                                existing elements.


File: gawk.info,  Node: Array Intro,  Next: Reference to Elements,  Up: Array Basics

8.1.1 Introduction to Arrays
----------------------------

     Doing linear scans over an associative array is like trying to
     club someone to death with a loaded Uzi.
     Larry Wall

   The `awk' language provides one-dimensional arrays for storing
groups of related strings or numbers.  Every `awk' array must have a
name.  Array names have the same syntax as variable names; any valid
variable name would also be a valid array name.  But one name cannot be
used in both ways (as an array and as a variable) in the same `awk'
program.

   Arrays in `awk' superficially resemble arrays in other programming
languages, but there are fundamental differences.  In `awk', it isn't
necessary to specify the size of an array before starting to use it.
Additionally, any number or string in `awk', not just consecutive
integers, may be used as an array index.

   In most other languages, arrays must be "declared" before use,
including a specification of how many elements or components they
contain.  In such languages, the declaration causes a contiguous block
of memory to be allocated for that many elements.  Usually, an index in
the array must be a positive integer.  For example, the index zero
specifies the first element in the array, which is actually stored at
the beginning of the block of memory.  Index one specifies the second
element, which is stored in memory right after the first element, and
so on.  It is impossible to add more elements to the array, because it
has room only for as many elements as given in the declaration.  (Some
languages allow arbitrary starting and ending indices--e.g., `15 ..
27'--but the size of the array is still fixed when the array is
declared.)

   A contiguous array of four elements might look like the following
example, conceptually, if the element values are 8, `"foo"', `""', and
30:

     +---------+---------+--------+---------+
     |    8    |  "foo"  |   ""   |    30   |    Value
     +---------+---------+--------+---------+
          0         1         2         3        Index

Only the values are stored; the indices are implicit from the order of
the values. Here, 8 is the value at index zero, because 8 appears in the
position with zero elements before it.

   Arrays in `awk' are different--they are "associative".  This means
that each array is a collection of pairs: an index and its corresponding
array element value:

     Index 3     Value 30
     Index 1     Value "foo"
     Index 0     Value 8
     Index 2     Value ""

The pairs are shown in jumbled order because their order is irrelevant.

   One advantage of associative arrays is that new pairs can be added
at any time.  For example, suppose a tenth element is added to the array
whose value is `"number ten"'.  The result is:

     Index 10    Value "number ten"
     Index 3     Value 30
     Index 1     Value "foo"
     Index 0     Value 8
     Index 2     Value ""

Now the array is "sparse", which just means some indices are missing.
It has elements 0-3 and 10, but doesn't have elements 4, 5, 6, 7, 8, or
9.

   Another consequence of associative arrays is that the indices don't
have to be positive integers.  Any number, or even a string, can be an
index.  For example, the following is an array that translates words
from English to French:

     Index "dog" Value "chien"
     Index "cat" Value "chat"
     Index "one" Value "un"
     Index 1     Value "un"

Here we decided to translate the number one in both spelled-out and
numeric form--thus illustrating that a single array can have both
numbers and strings as indices.  In fact, array subscripts are always
strings; this is discussed in more detail in *note Numeric Array
Subscripts::.  Here, the number `1' isn't double-quoted, since `awk'
automatically converts it to a string.

   The value of `IGNORECASE' has no effect upon array subscripting.
The identical string value used to store an array element must be used
to retrieve it.  When `awk' creates an array (e.g., with the `split()'
built-in function), that array's indices are consecutive integers
starting at one.  (*Note String Functions::.)

   `awk''s arrays are efficient--the time to access an element is
independent of the number of elements in the array.


File: gawk.info,  Node: Reference to Elements,  Next: Assigning Elements,  Prev: Array Intro,  Up: Array Basics

8.1.2 Referring to an Array Element
-----------------------------------

The principal way to use an array is to refer to one of its elements.
An array reference is an expression as follows:

     ARRAY[INDEX-EXPRESSION]

Here, ARRAY is the name of an array.  The expression INDEX-EXPRESSION is
the index of the desired element of the array.

   The value of the array reference is the current value of that array
element.  For example, `foo[4.3]' is an expression for the element of
array `foo' at index `4.3'.

   A reference to an array element that has no recorded value yields a
value of `""', the null string.  This includes elements that have not
been assigned any value as well as elements that have been deleted
(*note Delete::).

     NOTE: A reference to an element that does not exist
     _automatically_ creates that array element, with the null string
     as its value.  (In some cases, this is unfortunate, because it
     might waste memory inside `awk'.)

     Novice `awk' programmers often make the mistake of checking if an
     element exists by checking if the value is empty:

          # Check if "foo" exists in a:         Incorrect!
          if (a["foo"] != "") ...

     This is incorrect, since this will _create_ `a["foo"]' if it
     didn't exist before!

   To determine whether an element exists in an array at a certain
index, use the following expression:

     IND in ARRAY

This expression tests whether the particular index IND exists, without
the side effect of creating that element if it is not present.  The
expression has the value one (true) if `ARRAY[IND]' exists and zero
(false) if it does not exist.  For example, this statement tests
whether the array `frequencies' contains the index `2':

     if (2 in frequencies)
         print "Subscript 2 is present."

   Note that this is _not_ a test of whether the array `frequencies'
contains an element whose _value_ is two.  There is no way to do that
except to scan all the elements.  Also, this _does not_ create
`frequencies[2]', while the following (incorrect) alternative does:

     if (frequencies[2] != "")
         print "Subscript 2 is present."


File: gawk.info,  Node: Assigning Elements,  Next: Array Example,  Prev: Reference to Elements,  Up: Array Basics

8.1.3 Assigning Array Elements
------------------------------

Array elements can be assigned values just like `awk' variables:

     ARRAY[INDEX-EXPRESSION] = VALUE

ARRAY is the name of an array.  The expression INDEX-EXPRESSION is the
index of the element of the array that is assigned a value.  The
expression VALUE is the value to assign to that element of the array.


File: gawk.info,  Node: Array Example,  Next: Scanning an Array,  Prev: Assigning Elements,  Up: Array Basics

8.1.4 Basic Array Example
-------------------------

The following program takes a list of lines, each beginning with a line
number, and prints them out in order of line number.  The line numbers
are not in order when they are first read--instead they are scrambled.
This program sorts the lines by making an array using the line numbers
as subscripts.  The program then prints out the lines in sorted order
of their numbers.  It is a very simple program and gets confused upon
encountering repeated numbers, gaps, or lines that don't begin with a
number:

     {
       if ($1 > max)
         max = $1
       arr[$1] = $0
     }

     END {
       for (x = 1; x <= max; x++)
         print arr[x]
     }

   The first rule keeps track of the largest line number seen so far;
it also stores each line into the array `arr', at an index that is the
line's number.  The second rule runs after all the input has been read,
to print out all the lines.  When this program is run with the
following input:

     5  I am the Five man
     2  Who are you?  The new number two!
     4  . . . And four on the floor
     1  Who is number one?
     3  I three you.

Its output is:

     1  Who is number one?
     2  Who are you?  The new number two!
     3  I three you.
     4  . . . And four on the floor
     5  I am the Five man

   If a line number is repeated, the last line with a given number
overrides the others.  Gaps in the line numbers can be handled with an
easy improvement to the program's `END' rule, as follows:

     END {
       for (x = 1; x <= max; x++)
         if (x in arr)
           print arr[x]
     }


File: gawk.info,  Node: Scanning an Array,  Prev: Array Example,  Up: Array Basics

8.1.5 Scanning All Elements of an Array
---------------------------------------

In programs that use arrays, it is often necessary to use a loop that
executes once for each element of an array.  In other languages, where
arrays are contiguous and indices are limited to positive integers,
this is easy: all the valid indices can be found by counting from the
lowest index up to the highest.  This technique won't do the job in
`awk', because any number or string can be an array index.  So `awk'
has a special kind of `for' statement for scanning an array:

     for (VAR in ARRAY)
       BODY

This loop executes BODY once for each index in ARRAY that the program
has previously used, with the variable VAR set to that index.

   The following program uses this form of the `for' statement.  The
first rule scans the input records and notes which words appear (at
least once) in the input, by storing a one into the array `used' with
the word as index.  The second rule scans the elements of `used' to
find all the distinct words that appear in the input.  It prints each
word that is more than 10 characters long and also prints the number of
such words.  *Note String Functions::, for more information on the
built-in function `length()'.

     # Record a 1 for each word that is used at least once
     {
         for (i = 1; i <= NF; i++)
             used[$i] = 1
     }

     # Find number of distinct words more than 10 characters long
     END {
         for (x in used) {
             if (length(x) > 10) {
                 ++num_long_words
                 print x
             }
         }
         print num_long_words, "words longer than 10 characters"
     }

*Note Word Sorting::, for a more detailed example of this type.

   The order in which elements of the array are accessed by this
statement is determined by the internal arrangement of the array
elements within `awk' and normally cannot be controlled or changed.
This can lead to problems if new elements are added to ARRAY by
statements in the loop body; it is not predictable whether the `for'
loop will reach them.  Similarly, changing VAR inside the loop may
produce strange results.  It is best to avoid such things.

   As an extension, `gawk' makes it possible for you to loop over the
elements of an array in order, based on the value of
`PROCINFO["sorted_in"]' (*note Auto-set::).  This is an advanced
feature, so discussion of it is delayed until *note Controlling Array
Traversal::.

   In addition, `gawk' provides built-in functions for sorting arrays;
see *note Array Sorting Functions::.


File: gawk.info,  Node: Delete,  Next: Numeric Array Subscripts,  Prev: Array Basics,  Up: Arrays

8.2 The `delete' Statement
==========================

To remove an individual element of an array, use the `delete' statement:

     delete ARRAY[INDEX-EXPRESSION]

   Once an array element has been deleted, any value the element once
had is no longer available. It is as if the element had never been
referred to or been given a value.  The following is an example of
deleting elements in an array:

     for (i in frequencies)
       delete frequencies[i]

This example removes all the elements from the array `frequencies'.
Once an element is deleted, a subsequent `for' statement to scan the
array does not report that element and the `in' operator to check for
the presence of that element returns zero (i.e., false):

     delete foo[4]
     if (4 in foo)
         print "This will never be printed"

   It is important to note that deleting an element is _not_ the same
as assigning it a null value (the empty string, `""').  For example:

     foo[4] = ""
     if (4 in foo)
       print "This is printed, even though foo[4] is empty"

   It is not an error to delete an element that does not exist.
However, if `--lint' is provided on the command line (*note Options::),
`gawk' issues a warning message when an element that is not in the
array is deleted.

   All the elements of an array may be deleted with a single statement
(c.e.)  by leaving off the subscript in the `delete' statement, as
follows:

     delete ARRAY

   This ability is a `gawk' extension; it is not available in
compatibility mode (*note Options::).

   Using this version of the `delete' statement is about three times
more efficient than the equivalent loop that deletes each element one
at a time.

   The following statement provides a portable but nonobvious way to
clear out an array:(1)

     split("", array)

   The `split()' function (*note String Functions::) clears out the
target array first. This call asks it to split apart the null string.
Because there is no data to split out, the function simply clears the
array and then returns.

     CAUTION: Deleting an array does not change its type; you cannot
     delete an array and then use the array's name as a scalar (i.e., a
     regular variable). For example, the following does not work:

          a[1] = 3
          delete a
          a = 3

   ---------- Footnotes ----------

   (1) Thanks to Michael Brennan for pointing this out.


File: gawk.info,  Node: Numeric Array Subscripts,  Next: Uninitialized Subscripts,  Prev: Delete,  Up: Arrays

8.3 Using Numbers to Subscript Arrays
=====================================

An important aspect to remember about arrays is that _array subscripts
are always strings_.  When a numeric value is used as a subscript, it
is converted to a string value before being used for subscripting
(*note Conversion::).  This means that the value of the built-in
variable `CONVFMT' can affect how your program accesses elements of an
array.  For example:

     xyz = 12.153
     data[xyz] = 1
     CONVFMT = "%2.2f"
     if (xyz in data)
         printf "%s is in data\n", xyz
     else
         printf "%s is not in data\n", xyz

This prints `12.15 is not in data'.  The first statement gives `xyz' a
numeric value.  Assigning to `data[xyz]' subscripts `data' with the
string value `"12.153"' (using the default conversion value of
`CONVFMT', `"%.6g"').  Thus, the array element `data["12.153"]' is
assigned the value one.  The program then changes the value of
`CONVFMT'.  The test `(xyz in data)' generates a new string value from
`xyz'--this time `"12.15"'--because the value of `CONVFMT' only allows
two significant digits.  This test fails, since `"12.15"' is different
from `"12.153"'.

   According to the rules for conversions (*note Conversion::), integer
values are always converted to strings as integers, no matter what the
value of `CONVFMT' may happen to be.  So the usual case of the
following works:

     for (i = 1; i <= maxsub; i++)
         do something with array[i]

   The "integer values always convert to strings as integers" rule has
an additional consequence for array indexing.  Octal and hexadecimal
constants (*note Nondecimal-numbers::) are converted internally into
numbers, and their original form is forgotten.  This means, for
example, that `array[17]', `array[021]', and `array[0x11]' all refer to
the same element!

   As with many things in `awk', the majority of the time things work
as one would expect them to.  But it is useful to have a precise
knowledge of the actual rules since they can sometimes have a subtle
effect on your programs.


File: gawk.info,  Node: Uninitialized Subscripts,  Next: Multi-dimensional,  Prev: Numeric Array Subscripts,  Up: Arrays

8.4 Using Uninitialized Variables as Subscripts
===============================================

Suppose it's necessary to write a program to print the input data in
reverse order.  A reasonable attempt to do so (with some test data)
might look like this:

     $ echo 'line 1
     > line 2
     > line 3' | awk '{ l[lines] = $0; ++lines }
     > END {
     >     for (i = lines-1; i >= 0; --i)
     >        print l[i]
     > }'
     -| line 3
     -| line 2

   Unfortunately, the very first line of input data did not come out in
the output!

   Upon first glance, we would think that this program should have
worked.  The variable `lines' is uninitialized, and uninitialized
variables have the numeric value zero.  So, `awk' should have printed
the value of `l[0]'.

   The issue here is that subscripts for `awk' arrays are _always_
strings. Uninitialized variables, when used as strings, have the value
`""', not zero.  Thus, `line 1' ends up stored in `l[""]'.  The
following version of the program works correctly:

     { l[lines++] = $0 }
     END {
         for (i = lines - 1; i >= 0; --i)
            print l[i]
     }

   Here, the `++' forces `lines' to be numeric, thus making the "old
value" numeric zero. This is then converted to `"0"' as the array
subscript.

   Even though it is somewhat unusual, the null string (`""') is a
valid array subscript.  (d.c.)  `gawk' warns about the use of the null
string as a subscript if `--lint' is provided on the command line
(*note Options::).


File: gawk.info,  Node: Multi-dimensional,  Next: Arrays of Arrays,  Prev: Uninitialized Subscripts,  Up: Arrays

8.5 Multidimensional Arrays
===========================

* Menu:

* Multi-scanning::              Scanning multidimensional arrays.

   A multidimensional array is an array in which an element is
identified by a sequence of indices instead of a single index.  For
example, a two-dimensional array requires two indices.  The usual way
(in most languages, including `awk') to refer to an element of a
two-dimensional array named `grid' is with `grid[X,Y]'.

   Multidimensional arrays are supported in `awk' through concatenation
of indices into one string.  `awk' converts the indices into strings
(*note Conversion::) and concatenates them together, with a separator
between them.  This creates a single string that describes the values
of the separate indices.  The combined string is used as a single index
into an ordinary, one-dimensional array.  The separator used is the
value of the built-in variable `SUBSEP'.

   For example, suppose we evaluate the expression `foo[5,12] = "value"'
when the value of `SUBSEP' is `"@"'.  The numbers 5 and 12 are
converted to strings and concatenated with an `@' between them,
yielding `"5@12"'; thus, the array element `foo["5@12"]' is set to
`"value"'.

   Once the element's value is stored, `awk' has no record of whether
it was stored with a single index or a sequence of indices.  The two
expressions `foo[5,12]' and `foo[5 SUBSEP 12]' are always equivalent.

   The default value of `SUBSEP' is the string `"\034"', which contains
a nonprinting character that is unlikely to appear in an `awk' program
or in most input data.  The usefulness of choosing an unlikely
character comes from the fact that index values that contain a string
matching `SUBSEP' can lead to combined strings that are ambiguous.
Suppose that `SUBSEP' is `"@"'; then `foo["a@b", "c"]' and
`foo["a", "b@c"]' are indistinguishable because both are actually
stored as `foo["a@b@c"]'.

   To test whether a particular index sequence exists in a
multidimensional array, use the same operator (`in') that is used for
single dimensional arrays.  Write the whole sequence of indices in
parentheses, separated by commas, as the left operand:

     (SUBSCRIPT1, SUBSCRIPT2, ...) in ARRAY

   The following example treats its input as a two-dimensional array of
fields; it rotates this array 90 degrees clockwise and prints the
result.  It assumes that all lines have the same number of elements:

     {
          if (max_nf < NF)
               max_nf = NF
          max_nr = NR
          for (x = 1; x <= NF; x++)
               vector[x, NR] = $x
     }

     END {
          for (x = 1; x <= max_nf; x++) {
               for (y = max_nr; y >= 1; --y)
                    printf("%s ", vector[x, y])
               printf("\n")
          }
     }

When given the input:

     1 2 3 4 5 6
     2 3 4 5 6 1
     3 4 5 6 1 2
     4 5 6 1 2 3

the program produces the following output:

     4 3 2 1
     5 4 3 2
     6 5 4 3
     1 6 5 4
     2 1 6 5
     3 2 1 6


File: gawk.info,  Node: Multi-scanning,  Up: Multi-dimensional

8.5.1 Scanning Multidimensional Arrays
--------------------------------------

There is no special `for' statement for scanning a "multidimensional"
array. There cannot be one, because, in truth, there are no
multidimensional arrays or elements--there is only a multidimensional
_way of accessing_ an array.

   However, if your program has an array that is always accessed as
multidimensional, you can get the effect of scanning it by combining
the scanning `for' statement (*note Scanning an Array::) with the
built-in `split()' function (*note String Functions::).  It works in
the following manner:

     for (combined in array) {
         split(combined, separate, SUBSEP)
         ...
     }

This sets the variable `combined' to each concatenated combined index
in the array, and splits it into the individual indices by breaking it
apart where the value of `SUBSEP' appears.  The individual indices then
become the elements of the array `separate'.

   Thus, if a value is previously stored in `array[1, "foo"]'; then an
element with index `"1\034foo"' exists in `array'.  (Recall that the
default value of `SUBSEP' is the character with code 034.)  Sooner or
later, the `for' statement finds that index and does an iteration with
the variable `combined' set to `"1\034foo"'.  Then the `split()'
function is called as follows:

     split("1\034foo", separate, "\034")

The result is to set `separate[1]' to `"1"' and `separate[2]' to
`"foo"'.  Presto! The original sequence of separate indices is
recovered.


File: gawk.info,  Node: Arrays of Arrays,  Prev: Multi-dimensional,  Up: Arrays

8.6 Arrays of Arrays
====================

`gawk' supports arrays of arrays. Elements of a subarray are referred
to by their own indices enclosed in square brackets, just like the
elements of the main array.  For example, the following creates a
two-element subarray at index `1' of the main array `a':

     a[1][1] = 1
     a[1][2] = 2

   This simulates a true two-dimensional array. Each subarray element
can contain another subarray as a value, which in turn can hold other
arrays as well. In this way, you can create arrays of three or more
dimensions.  The indices can be any `awk' expression, including scalars
separated by commas (that is, a regular `awk' simulated
multidimensional subscript). So the following is valid in `gawk':

     a[1][3][1, "name"] = "barney"

   Each subarray and the main array can be of different length. In
fact, the elements of an array or its subarray do not all have to have
the same type. This means that the main array and any of its subarrays
can be non-rectangular, or jagged in structure. One can assign a scalar
value to the index `4' of the main array `a':

     a[4] = "An element in a jagged array"

   The terms "dimension", "row" and "column" are meaningless when
applied to such an array, but we will use "dimension" henceforth to
imply the maximum number of indices needed to refer to an existing
element. The type of any element that has already been assigned cannot
be changed by assigning a value of a different type. You have to first
delete the current element, which effectively makes `gawk' forget about
the element at that index:

     delete a[4]
     a[4][5][6][7] = "An element in a four-dimensional array"

This removes the scalar value from index `4' and then inserts a
subarray of subarray of subarray containing a scalar. You can also
delete an entire subarray or subarray of subarrays:

     delete a[4][5]
     a[4][5] = "An element in subarray a[4]"

   But recall that you can not delete the main array `a' and then use it
as a scalar.

   The built-in functions which take array arguments can also be used
with subarrays. For example, the following code fragment uses `length()'
(*note String Functions::) to determine the number of elements in the
main array `a' and its subarrays:

     print length(a), length(a[1]), length(a[1][3])

This results in the following output for our main array `a':

     2, 3, 1

The `SUBSCRIPT in ARRAY' expression (*note Reference to Elements::)
works similarly for both regular `awk'-style arrays and arrays of
arrays. For example, the tests `1 in a', `3 in a[1]', and `(1, "name")
in a[1][3]' all evaluate to one (true) for our array `a'.

   The `for (item in array)' statement (*note Scanning an Array::) can
be nested to scan all the elements of an array of arrays if it is
rectangular in structure. In order to print the contents (scalar
values) of a two-dimensional array of arrays (i.e., in which each
first-level element is itself an array, not necessarily of the same
length) you could use the following code:

     for (i in array)
         for (j in array[i])
             print array[i][j]

   The `isarray()' function (*note Type Functions::) lets you test if
an array element is itself an array:

     for (i in array) {
         if (isarray(array[i]) {
             for (j in array[i]) {
                 print array[i][j]
             }
         }
     }

   If the structure of a jagged array of arrays is known in advance,
you can often devise workarounds using control statements. For example,
the following code prints the elements of our main array `a':

     for (i in a) {
         for (j in a[i]) {
             if (j == 3) {
                 for (k in a[i][j])
                     print a[i][j][k]
             } else
                 print a[i][j]
         }
     }

*Note Walking Arrays::, for a user-defined function that will "walk" an
arbitrarily-dimensioned array of arrays.

   Recall that a reference to an uninitialized array element yields a
value of `""', the null string. This has one important implication when
you intend to use a subarray as an argument to a function, as
illustrated by the following example:

     $ gawk 'BEGIN { split("a b c d", b[1]); print b[1][1] }'
     error--> gawk: cmd. line:1: fatal: split: second argument is not an array

   The way to work around this is to first force `b[1]' to be an array
by creating an arbitrary index:

     $ gawk 'BEGIN { b[1][1] = ""; split("a b c d", b[1]); print b[1][1] }'
     -| a


File: gawk.info,  Node: Functions,  Next: Internationalization,  Prev: Arrays,  Up: Top

9 Functions
***********

This major node describes `awk''s built-in functions, which fall into
three categories: numeric, string, and I/O.  `gawk' provides additional
groups of functions to work with values that represent time, do bit
manipulation, sort arrays, and internationalize and localize programs.

   Besides the built-in functions, `awk' has provisions for writing new
functions that the rest of a program can use.  The second half of this
major node describes these "user-defined" functions.

* Menu:

* Built-in::                    Summarizes the built-in functions.
* User-defined::                Describes User-defined functions in detail.
* Indirect Calls::              Choosing the function to call at runtime.


File: gawk.info,  Node: Built-in,  Next: User-defined,  Up: Functions

9.1 Built-in Functions
======================

"Built-in" functions are always available for your `awk' program to
call.  This minor node defines all the built-in functions in `awk';
some of these are mentioned in other sections but are summarized here
for your convenience.

* Menu:

* Calling Built-in::            How to call built-in functions.
* Numeric Functions::           Functions that work with numbers, including
                                `int()', `sin()' and `rand()'.
* String Functions::            Functions for string manipulation, such as
                                `split()', `match()' and
                                `sprintf()'.
* I/O Functions::               Functions for files and shell commands.
* Time Functions::              Functions for dealing with timestamps.
* Bitwise Functions::           Functions for bitwise operations.
* Type Functions::              Functions for type information.
* I18N Functions::              Functions for string translation.


File: gawk.info,  Node: Calling Built-in,  Next: Numeric Functions,  Up: Built-in

9.1.1 Calling Built-in Functions
--------------------------------

To call one of `awk''s built-in functions, write the name of the
function followed by arguments in parentheses.  For example, `atan2(y +
z, 1)' is a call to the function `atan2()' and has two arguments.

   Whitespace is ignored between the built-in function name and the
open parenthesis, but nonetheless it is good practice to avoid using
whitespace there.  User-defined functions do not permit whitespace in
this way, and it is easier to avoid mistakes by following a simple
convention that always works--no whitespace after a function name.

   Each built-in function accepts a certain number of arguments.  In
some cases, arguments can be omitted. The defaults for omitted
arguments vary from function to function and are described under the
individual functions.  In some `awk' implementations, extra arguments
given to built-in functions are ignored.  However, in `gawk', it is a
fatal error to give extra arguments to a built-in function.

   When a function is called, expressions that create the function's
actual parameters are evaluated completely before the call is performed.
For example, in the following code fragment:

     i = 4
     j = sqrt(i++)

the variable `i' is incremented to the value five before `sqrt()' is
called with a value of four for its actual parameter.  The order of
evaluation of the expressions used for the function's parameters is
undefined.  Thus, avoid writing programs that assume that parameters
are evaluated from left to right or from right to left.  For example:

     i = 5
     j = atan2(i++, i *= 2)

   If the order of evaluation is left to right, then `i' first becomes
6, and then 12, and `atan2()' is called with the two arguments 6 and
12.  But if the order of evaluation is right to left, `i' first becomes
10, then 11, and `atan2()' is called with the two arguments 11 and 10.


File: gawk.info,  Node: Numeric Functions,  Next: String Functions,  Prev: Calling Built-in,  Up: Built-in

9.1.2 Numeric Functions
-----------------------

The following list describes all of the built-in functions that work
with numbers.  Optional parameters are enclosed in square
brackets ([ ]):

`atan2(Y, X)'
     Return the arctangent of `Y / X' in radians.

`cos(X)'
     Return the cosine of X, with X in radians.

`exp(X)'
     Return the exponential of X (`e ^ X') or report an error if X is
     out of range.  The range of values X can have depends on your
     machine's floating-point representation.

`int(X)'
     Return the nearest integer to X, located between X and zero and
     truncated toward zero.

     For example, `int(3)' is 3, `int(3.9)' is 3, `int(-3.9)' is -3,
     and `int(-3)' is -3 as well.

`log(X)'
     Return the natural logarithm of X, if X is positive; otherwise,
     report an error.

`rand()'
     Return a random number.  The values of `rand()' are uniformly
     distributed between zero and one.  The value could be zero but is
     never one.(1)

     Often random integers are needed instead.  Following is a
     user-defined function that can be used to obtain a random
     non-negative integer less than N:

          function randint(n) {
               return int(n * rand())
          }

     The multiplication produces a random number greater than zero and
     less than `n'.  Using `int()', this result is made into an integer
     between zero and `n' - 1, inclusive.

     The following example uses a similar function to produce random
     integers between one and N.  This program prints a new random
     number for each input record:

          # Function to roll a simulated die.
          function roll(n) { return 1 + int(rand() * n) }

          # Roll 3 six-sided dice and
          # print total number of points.
          {
                printf("%d points\n",
                       roll(6)+roll(6)+roll(6))
          }

          CAUTION: In most `awk' implementations, including `gawk',
          `rand()' starts generating numbers from the same starting
          number, or "seed", each time you run `awk'.(2)  Thus, a
          program generates the same results each time you run it.  The
          numbers are random within one `awk' run but predictable from
          run to run.  This is convenient for debugging, but if you want
          a program to do different things each time it is used, you
          must change the seed to a value that is different in each
          run.  To do this, use `srand()'.

`sin(X)'
     Return the sine of X, with X in radians.

`sqrt(X)'
     Return the positive square root of X.  `gawk' prints a warning
     message if X is negative.  Thus, `sqrt(4)' is 2.

`srand([X])'
     Set the starting point, or seed, for generating random numbers to
     the value X.

     Each seed value leads to a particular sequence of random
     numbers.(3) Thus, if the seed is set to the same value a second
     time, the same sequence of random numbers is produced again.

          CAUTION: Different `awk' implementations use different
          random-number generators internally.  Don't expect the same
          `awk' program to produce the same series of random numbers
          when executed by different versions of `awk'.

     If the argument X is omitted, as in `srand()', then the current
     date and time of day are used for a seed.  This is the way to get
     random numbers that are truly unpredictable.

     The return value of `srand()' is the previous seed.  This makes it
     easy to keep track of the seeds in case you need to consistently
     reproduce sequences of random numbers.

   ---------- Footnotes ----------

   (1) The C version of `rand()' on many Unix systems is known to
produce fairly poor sequences of random numbers.  However, nothing
requires that an `awk' implementation use the C `rand()' to implement
the `awk' version of `rand()'.  In fact, `gawk' uses the BSD `random()'
function, which is considerably better than `rand()', to produce random
numbers.

   (2) `mawk' uses a different seed each time.

   (3) Computer-generated random numbers really are not truly random.
They are technically known as "pseudorandom."  This means that while
the numbers in a sequence appear to be random, you can in fact generate
the same sequence of random numbers over and over again.


File: gawk.info,  Node: String Functions,  Next: I/O Functions,  Prev: Numeric Functions,  Up: Built-in

9.1.3 String-Manipulation Functions
-----------------------------------

The functions in this minor node look at or change the text of one or
more strings.  `gawk' understands locales (*note Locales::), and does
all string processing in terms of _characters_, not _bytes_.  This
distinction is particularly important to understand for locales where
one character may be represented by multiple bytes.  Thus, for example,
`length()' returns the number of characters in a string, and not the
number of bytes used to represent those characters, Similarly,
`index()' works with character indices, and not byte indices.

   In the following list, optional parameters are enclosed in square
brackets ([ ]).  Several functions perform string substitution; the
full discussion is provided in the description of the `sub()' function,
which comes towards the end since the list is presented in alphabetic
order.  Those functions that are specific to `gawk' are marked with a
pound sign (`#'):

* Menu:

* Gory Details::                More than you want to know about `\' and
                                `&' with `sub()', `gsub()', and
                                `gensub()'.

`asort(SOURCE [, DEST [, HOW  ] ]) #'
     Return the number of elements in the array SOURCE.  `gawk' sorts
     the contents of SOURCE and replaces the indices of the sorted
     values of SOURCE with sequential integers starting with one.  If
     the optional array DEST is specified, then SOURCE is duplicated
     into DEST.  DEST is then sorted, leaving the indices of SOURCE
     unchanged.  The optional third argument HOW is a string which
     controls the rule for comparing values, and the sort direction.  A
     single space is required between the comparison mode, `string' or
     `number', and the direction specification, `ascending' or
     `descending'.  You can omit direction and/or mode in which case it
     will default to `ascending' and `string', respectively.  An empty
     string "" is the same as the default `"ascending string"' for the
     value of HOW.  If the `source' array contains subarrays as values,
     they will come out last(first) in the `dest' array for
     `ascending'(`descending') order specification.  The value of
     `IGNORECASE' affects the sorting.  The third argument can also be
     a user-defined function name in which case the value returned by
     the function is used to order the array elements before
     constructing the result array.  *Note Array Sorting Functions::,
     for more information.

     For example, if the contents of `a' are as follows:

          a["last"] = "de"
          a["first"] = "sac"
          a["middle"] = "cul"

     A call to `asort()':

          asort(a)

     results in the following contents of `a':

          a[1] = "cul"
          a[2] = "de"
          a[3] = "sac"

     In order to reverse the direction of the sorted results in the
     above example, `asort()' can be called with three arguments as
     follows:

          asort(a, a, "descending")

     The `asort()' function is described in more detail in *note Array
     Sorting Functions::.  `asort()' is a `gawk' extension; it is not
     available in compatibility mode (*note Options::).

`asorti(SOURCE [, DEST [, HOW  ] ]) #'
     Return the number of elements in the array SOURCE.  It works
     similarly to `asort()', however, the _indices_ are sorted, instead
     of the values. (Here too, `IGNORECASE' affects the sorting.)

     The `asorti()' function is described in more detail in *note Array
     Sorting Functions::.  `asorti()' is a `gawk' extension; it is not
     available in compatibility mode (*note Options::).

`gensub(REGEXP, REPLACEMENT, HOW [, TARGET]) #'
     Search the target string TARGET for matches of the regular
     expression REGEXP.  If HOW is a string beginning with `g' or `G'
     (short for "global"), then replace all matches of REGEXP with
     REPLACEMENT.  Otherwise, HOW is treated as a number indicating
     which match of REGEXP to replace. If no TARGET is supplied, use
     `$0'.  It returns the modified string as the result of the
     function and the original target string is _not_ changed.

     `gensub()' is a general substitution function.  It's purpose is to
     provide more features than the standard `sub()' and `gsub()'
     functions.

     `gensub()' provides an additional feature that is not available in
     `sub()' or `gsub()': the ability to specify components of a regexp
     in the replacement text.  This is done by using parentheses in the
     regexp to mark the components and then specifying `\N' in the
     replacement text, where N is a digit from 1 to 9.  For example:

          $ gawk '
          > BEGIN {
          >      a = "abc def"
          >      b = gensub(/(.+) (.+)/, "\\2 \\1", "g", a)
          >      print b
          > }'
          -| def abc

     As with `sub()', you must type two backslashes in order to get one
     into the string.  In the replacement text, the sequence `\0'
     represents the entire matched text, as does the character `&'.

     The following example shows how you can use the third argument to
     control which match of the regexp should be changed:

          $ echo a b c a b c |
          > gawk '{ print gensub(/a/, "AA", 2) }'
          -| a b c AA b c

     In this case, `$0' is the default target string.  `gensub()'
     returns the new string as its result, which is passed directly to
     `print' for printing.

     If the HOW argument is a string that does not begin with `g' or
     `G', or if it is a number that is less than or equal to zero, only
     one substitution is performed.  If HOW is zero, `gawk' issues a
     warning message.

     If REGEXP does not match TARGET, `gensub()''s return value is the
     original unchanged value of TARGET.

     `gensub()' is a `gawk' extension; it is not available in
     compatibility mode (*note Options::).

`gsub(REGEXP, REPLACEMENT [, TARGET])'
     Search TARGET for _all_ of the longest, leftmost, _nonoverlapping_
     matching substrings it can find and replace them with REPLACEMENT.
     The `g' in `gsub()' stands for "global," which means replace
     everywhere.  For example:

          { gsub(/Britain/, "United Kingdom"); print }

     replaces all occurrences of the string `Britain' with `United
     Kingdom' for all input records.

     The `gsub()' function returns the number of substitutions made.  If
     the variable to search and alter (TARGET) is omitted, then the
     entire input record (`$0') is used.  As in `sub()', the characters
     `&' and `\' are special, and the third argument must be assignable.

`index(IN, FIND)'
     Search the string IN for the first occurrence of the string FIND,
     and return the position in characters where that occurrence begins
     in the string IN.  Consider the following example:

          $ awk 'BEGIN { print index("peanut", "an") }'
          -| 3

     If FIND is not found, `index()' returns zero.  (Remember that
     string indices in `awk' start at one.)

`length([STRING])'
     Return the number of characters in STRING.  If STRING is a number,
     the length of the digit string representing that number is
     returned.  For example, `length("abcde")' is five.  By contrast,
     `length(15 * 35)' works out to three. In this example, 15 * 35 =
     525, and 525 is then converted to the string `"525"', which has
     three characters.

     If no argument is supplied, `length()' returns the length of `$0'.

          NOTE: In older versions of `awk', the `length()' function
          could be called without any parentheses.  Doing so is
          considered poor practice, although the 2008 POSIX standard
          explicitly allows it, to support historical practice.  For
          programs to be maximally portable, always supply the
          parentheses.

     If `length()' is called with a variable that has not been used,
     `gawk' forces the variable to be a scalar.  Other implementations
     of `awk' leave the variable without a type.  (d.c.)  Consider:

          $ gawk 'BEGIN { print length(x) ; x[1] = 1 }'
          -| 0
          error--> gawk: fatal: attempt to use scalar `x' as array

          $ nawk 'BEGIN { print length(x) ; x[1] = 1 }'
          -| 0

     If `--lint' has been specified on the command line, `gawk' issues a
     warning about this.

     With `gawk' and several other `awk' implementations, when given an
     array argument, the `length()' function returns the number of
     elements in the array. (c.e.)  This is less useful than it might
     seem at first, as the array is not guaranteed to be indexed from
     one to the number of elements in it.  If `--lint' is provided on
     the command line (*note Options::), `gawk' warns that passing an
     array argument is not portable.  If `--posix' is supplied, using
     an array argument is a fatal error (*note Arrays::).

`match(STRING, REGEXP [, ARRAY])'
     Search STRING for the longest, leftmost substring matched by the
     regular expression, REGEXP and return the character position, or
     "index", at which that substring begins (one, if it starts at the
     beginning of STRING).  If no match is found, return zero.

     The REGEXP argument may be either a regexp constant (`/.../') or a
     string constant (`"..."').  In the latter case, the string is
     treated as a regexp to be matched.  *Note Computed Regexps::, for a
     discussion of the difference between the two forms, and the
     implications for writing your program correctly.

     The order of the first two arguments is backwards from most other
     string functions that work with regular expressions, such as
     `sub()' and `gsub()'.  It might help to remember that for
     `match()', the order is the same as for the `~' operator: `STRING
     ~ REGEXP'.

     The `match()' function sets the built-in variable `RSTART' to the
     index.  It also sets the built-in variable `RLENGTH' to the length
     in characters of the matched substring.  If no match is found,
     `RSTART' is set to zero, and `RLENGTH' to -1.

     For example:

          {
                 if ($1 == "FIND")
                   regex = $2
                 else {
                   where = match($0, regex)
                   if (where != 0)
                     print "Match of", regex, "found at",
                               where, "in", $0
                 }
          }

     This program looks for lines that match the regular expression
     stored in the variable `regex'.  This regular expression can be
     changed.  If the first word on a line is `FIND', `regex' is
     changed to be the second word on that line.  Therefore, if given:

          FIND ru+n
          My program runs
          but not very quickly
          FIND Melvin
          JF+KM
          This line is property of Reality Engineering Co.
          Melvin was here.

     `awk' prints:

          Match of ru+n found at 12 in My program runs
          Match of Melvin found at 1 in Melvin was here.

     If ARRAY is present, it is cleared, and then the zeroth element of
     ARRAY is set to the entire portion of STRING matched by REGEXP.
     If REGEXP contains parentheses, the integer-indexed elements of
     ARRAY are set to contain the portion of STRING matching the
     corresponding parenthesized subexpression.  For example:

          $ echo foooobazbarrrrr |
          > gawk '{ match($0, /(fo+).+(bar*)/, arr)
          >         print arr[1], arr[2] }'
          -| foooo barrrrr

     In addition, multidimensional subscripts are available providing
     the start index and length of each matched subexpression:

          $ echo foooobazbarrrrr |
          > gawk '{ match($0, /(fo+).+(bar*)/, arr)
          >           print arr[1], arr[2]
          >           print arr[1, "start"], arr[1, "length"]
          >           print arr[2, "start"], arr[2, "length"]
          > }'
          -| foooo barrrrr
          -| 1 5
          -| 9 7

     There may not be subscripts for the start and index for every
     parenthesized subexpression, since they may not all have matched
     text; thus they should be tested for with the `in' operator (*note
     Reference to Elements::).

     The ARRAY argument to `match()' is a `gawk' extension.  In
     compatibility mode (*note Options::), using a third argument is a
     fatal error.

`patsplit(STRING, ARRAY [, FIELDPAT [, SEPS ] ]) #'
     Divide STRING into pieces defined by FIELDPAT and store the pieces
     in ARRAY and the separator strings in the SEPS array.  The first
     piece is stored in `ARRAY[1]', the second piece in `ARRAY[2]', and
     so forth.  The third argument, FIELDPAT, is a regexp describing
     the fields in STRING (just as `FPAT' is a regexp describing the
     fields in input records).  It may be either a regexp constant or a
     string.  If FIELDPAT is omitted, the value of `FPAT' is used.
     `patsplit()' returns the number of elements created.  `SEPS[I]' is
     the separator string between `ARRAY[I]' and `ARRAY[I+1]'.  Any
     leading separator will be in `SEPS[0]'.

     The `patsplit()' function splits strings into pieces in a manner
     similar to the way input lines are split into fields using `FPAT'
     (*note Splitting By Content::.

     Before splitting the string, `patsplit()' deletes any previously
     existing elements in the arrays ARRAY and SEPS.

     The `patsplit()' function is a `gawk' extension.  In compatibility
     mode (*note Options::), it is not available.

`split(STRING, ARRAY [, FIELDSEP [, SEPS ] ])'
     Divide STRING into pieces separated by FIELDSEP and store the
     pieces in ARRAY and the separator strings in the SEPS array.  The
     first piece is stored in `ARRAY[1]', the second piece in
     `ARRAY[2]', and so forth.  The string value of the third argument,
     FIELDSEP, is a regexp describing where to split STRING (much as
     `FS' can be a regexp describing where to split input records;
     *note Regexp Field Splitting::).  If FIELDSEP is omitted, the
     value of `FS' is used.  `split()' returns the number of elements
     created.  SEPS is a `gawk' extension with `SEPS[I]' being the
     separator string between `ARRAY[I]' and `ARRAY[I+1]'.  If FIELDSEP
     is a single space then any leading whitespace goes into `SEPS[0]'
     and any trailing whitespace goes into `SEPS[N]' where N is the
     return value of `split()' (that is, the number of elements in
     ARRAY).

     The `split()' function splits strings into pieces in a manner
     similar to the way input lines are split into fields.  For example:

          split("cul-de-sac", a, "-", seps)

     splits the string `cul-de-sac' into three fields using `-' as the
     separator.  It sets the contents of the array `a' as follows:

          a[1] = "cul"
          a[2] = "de"
          a[3] = "sac"

     and sets the contents of the array `seps' as follows:

          seps[1] = "-"
          seps[2] = "-"

     The value returned by this call to `split()' is three.

     As with input field-splitting, when the value of FIELDSEP is
     `" "', leading and trailing whitespace is ignored in values
     assigned to the elements of ARRAY but not in SEPS, and the elements
     are separated by runs of whitespace.  Also as with input
     field-splitting, if FIELDSEP is the null string, each individual
     character in the string is split into its own array element.
     (c.e.)

     Note, however, that `RS' has no effect on the way `split()' works.
     Even though `RS = ""' causes newline to also be an input field
     separator, this does not affect how `split()' splits strings.

     Modern implementations of `awk', including `gawk', allow the third
     argument to be a regexp constant (`/abc/') as well as a string.
     (d.c.)  The POSIX standard allows this as well.  *Note Computed
     Regexps::, for a discussion of the difference between using a
     string constant or a regexp constant, and the implications for
     writing your program correctly.

     Before splitting the string, `split()' deletes any previously
     existing elements in the arrays ARRAY and SEPS.

     If STRING is null, the array has no elements. (So this is a
     portable way to delete an entire array with one statement.  *Note
     Delete::.)

     If STRING does not match FIELDSEP at all (but is not null), ARRAY
     has one element only. The value of that element is the original
     STRING.

`sprintf(FORMAT, EXPRESSION1, ...)'
     Return (without printing) the string that `printf' would have
     printed out with the same arguments (*note Printf::).  For example:

          pival = sprintf("pi = %.2f (approx.)", 22/7)

     assigns the string `pi = 3.14 (approx.)' to the variable `pival'.

`strtonum(STR) #'
     Examine STR and return its numeric value.  If STR begins with a
     leading `0', `strtonum()' assumes that STR is an octal number.  If
     STR begins with a leading `0x' or `0X', `strtonum()' assumes that
     STR is a hexadecimal number.  For example:

          $ echo 0x11 |
          > gawk '{ printf "%d\n", strtonum($1) }'
          -| 17

     Using the `strtonum()' function is _not_ the same as adding zero
     to a string value; the automatic coercion of strings to numbers
     works only for decimal data, not for octal or hexadecimal.(1)

     Note also that `strtonum()' uses the current locale's decimal point
     for recognizing numbers (*note Locales::).

     `strtonum()' is a `gawk' extension; it is not available in
     compatibility mode (*note Options::).

`sub(REGEXP, REPLACEMENT [, TARGET])'
     Search TARGET, which is treated as a string, for the leftmost,
     longest substring matched by the regular expression REGEXP.
     Modify the entire string by replacing the matched text with
     REPLACEMENT.  The modified string becomes the new value of TARGET.
     Return the number of substitutions made (zero or one).

     The REGEXP argument may be either a regexp constant (`/.../') or a
     string constant (`"..."').  In the latter case, the string is
     treated as a regexp to be matched.  *Note Computed Regexps::, for a
     discussion of the difference between the two forms, and the
     implications for writing your program correctly.

     This function is peculiar because TARGET is not simply used to
     compute a value, and not just any expression will do--it must be a
     variable, field, or array element so that `sub()' can store a
     modified value there.  If this argument is omitted, then the
     default is to use and alter `$0'.(2) For example:

          str = "water, water, everywhere"
          sub(/at/, "ith", str)

     sets `str' to `wither, water, everywhere', by replacing the
     leftmost longest occurrence of `at' with `ith'.

     If the special character `&' appears in REPLACEMENT, it stands for
     the precise substring that was matched by REGEXP.  (If the regexp
     can match more than one string, then this precise substring may
     vary.)  For example:

          { sub(/candidate/, "& and his wife"); print }

     changes the first occurrence of `candidate' to `candidate and his
     wife' on each input line.  Here is another example:

          $ awk 'BEGIN {
          >         str = "daabaaa"
          >         sub(/a+/, "C&C", str)
          >         print str
          > }'
          -| dCaaCbaaa

     This shows how `&' can represent a nonconstant string and also
     illustrates the "leftmost, longest" rule in regexp matching (*note
     Leftmost Longest::).

     The effect of this special character (`&') can be turned off by
     putting a backslash before it in the string.  As usual, to insert
     one backslash in the string, you must write two backslashes.
     Therefore, write `\\&' in a string constant to include a literal
     `&' in the replacement.  For example, the following shows how to
     replace the first `|' on each line with an `&':

          { sub(/\|/, "\\&"); print }

     As mentioned, the third argument to `sub()' must be a variable,
     field or array element.  Some versions of `awk' allow the third
     argument to be an expression that is not an lvalue.  In such a
     case, `sub()' still searches for the pattern and returns zero or
     one, but the result of the substitution (if any) is thrown away
     because there is no place to put it.  Such versions of `awk'
     accept expressions like the following:

          sub(/USA/, "United States", "the USA and Canada")

     For historical compatibility, `gawk' accepts such erroneous code.
     However, using any other nonchangeable object as the third
     parameter causes a fatal error and your program will not run.

     Finally, if the REGEXP is not a regexp constant, it is converted
     into a string, and then the value of that string is treated as the
     regexp to match.

`substr(STRING, START [, LENGTH])'
     Return a LENGTH-character-long substring of STRING, starting at
     character number START.  The first character of a string is
     character number one.(3) For example, `substr("washington", 5, 3)'
     returns `"ing"'.

     If LENGTH is not present, `substr()' returns the whole suffix of
     STRING that begins at character number START.  For example,
     `substr("washington", 5)' returns `"ington"'.  The whole suffix is
     also returned if LENGTH is greater than the number of characters
     remaining in the string, counting from character START.

     If START is less than one, `substr()' treats it as if it was one.
     (POSIX doesn't specify what to do in this case: Brian Kernighan's
     `awk' acts this way, and therefore `gawk' does too.)  If START is
     greater than the number of characters in the string, `substr()'
     returns the null string.  Similarly, if LENGTH is present but less
     than or equal to zero, the null string is returned.

     The string returned by `substr()' _cannot_ be assigned.  Thus, it
     is a mistake to attempt to change a portion of a string, as shown
     in the following example:

          string = "abcdef"
          # try to get "abCDEf", won't work
          substr(string, 3, 3) = "CDE"

     It is also a mistake to use `substr()' as the third argument of
     `sub()' or `gsub()':

          gsub(/xyz/, "pdq", substr($0, 5, 20))  # WRONG

     (Some commercial versions of `awk' treat `substr()' as assignable,
     but doing so is not portable.)

     If you need to replace bits and pieces of a string, combine
     `substr()' with string concatenation, in the following manner:

          string = "abcdef"
          ...
          string = substr(string, 1, 2) "CDE" substr(string, 6)

`tolower(STRING)'
     Return a copy of STRING, with each uppercase character in the
     string replaced with its corresponding lowercase character.
     Nonalphabetic characters are left unchanged.  For example,
     `tolower("MiXeD cAsE 123")' returns `"mixed case 123"'.

`toupper(STRING)'
     Return a copy of STRING, with each lowercase character in the
     string replaced with its corresponding uppercase character.
     Nonalphabetic characters are left unchanged.  For example,
     `toupper("MiXeD cAsE 123")' returns `"MIXED CASE 123"'.

   ---------- Footnotes ----------

   (1) Unless you use the `--non-decimal-data' option, which isn't
recommended.  *Note Nondecimal Data::, for more information.

   (2) Note that this means that the record will first be regenerated
using the value of `OFS' if any fields have been changed, and that the
fields will be updated after the substitution, even if the operation is
a "no-op" such as `sub(/^/, "")'.

   (3) This is different from C and C++, in which the first character
is number zero.


File: gawk.info,  Node: Gory Details,  Up: String Functions

9.1.3.1 More About `\' and `&' with `sub()', `gsub()', and `gensub()'
.....................................................................

When using `sub()', `gsub()', or `gensub()', and trying to get literal
backslashes and ampersands into the replacement text, you need to
remember that there are several levels of "escape processing" going on.

   First, there is the "lexical" level, which is when `awk' reads your
program and builds an internal copy of it that can be executed.  Then
there is the runtime level, which is when `awk' actually scans the
replacement string to determine what to generate.

   At both levels, `awk' looks for a defined set of characters that can
come after a backslash.  At the lexical level, it looks for the escape
sequences listed in *note Escape Sequences::.  Thus, for every `\' that
`awk' processes at the runtime level, you must type two backslashes at
the lexical level.  When a character that is not valid for an escape
sequence follows the `\', Brian Kernighan's `awk' and `gawk' both
simply remove the initial `\' and put the next character into the
string. Thus, for example, `"a\qb"' is treated as `"aqb"'.

   At the runtime level, the various functions handle sequences of `\'
and `&' differently.  The situation is (sadly) somewhat complex.
Historically, the `sub()' and `gsub()' functions treated the two
character sequence `\&' specially; this sequence was replaced in the
generated text with a single `&'.  Any other `\' within the REPLACEMENT
string that did not precede an `&' was passed through unchanged.  This
is illustrated in *note table-sub-escapes::.

      You type         `sub()' sees          `sub()' generates
      -------         ---------          --------------
          `\&'              `&'            the matched text
         `\\&'             `\&'            a literal `&'
        `\\\&'             `\&'            a literal `&'
       `\\\\&'            `\\&'            a literal `\&'
      `\\\\\&'            `\\&'            a literal `\&'
     `\\\\\\&'           `\\\&'            a literal `\\&'
         `\\q'             `\q'            a literal `\q'

Table 9.1: Historical Escape Sequence Processing for `sub()' and
`gsub()'

This table shows both the lexical-level processing, where an odd number
of backslashes becomes an even number at the runtime level, as well as
the runtime processing done by `sub()'.  (For the sake of simplicity,
the rest of the following tables only show the case of even numbers of
backslashes entered at the lexical level.)

   The problem with the historical approach is that there is no way to
get a literal `\' followed by the matched text.

   The POSIX rules state that `\&' in the replacement string produces a
literal `&', `\\' produces a literal `\', and `\' followed by anything
else is not special; the `\' is placed straight into the output.  These
rules are presented in *note table-posix-sub::.

      You type         `sub()' sees         `sub()' generates
      -------         ---------         --------------
     `\\\\\\&'           `\\\&'            a literal `\&'
       `\\\\&'            `\\&'            a literal `\', followed by the matched text
         `\\&'             `\&'            a literal `&'
         `\\q'             `\q'            a literal `\q'
        `\\\\'             `\\'            `\'

Table 9.2: POSIX rules for `sub()' and `gsub()'

   `gawk' follows the POSIX rules.

   The rules for `gensub()' are considerably simpler. At the runtime
level, whenever `gawk' sees a `\', if the following character is a
digit, then the text that matched the corresponding parenthesized
subexpression is placed in the generated output.  Otherwise, no matter
what character follows the `\', it appears in the generated text and
the `\' does not, as shown in *note table-gensub-escapes::.

       You type          `gensub()' sees         `gensub()' generates
       -------          ------------         -----------------
           `&'                    `&'            the matched text
         `\\&'                   `\&'            a literal `&'
        `\\\\'                   `\\'            a literal `\'
       `\\\\&'                  `\\&'            a literal `\', then the matched text
     `\\\\\\&'                 `\\\&'            a literal `\&'
         `\\q'                   `\q'            a literal `q'

Table 9.3: Escape Sequence Processing for `gensub()'

   Because of the complexity of the lexical and runtime level processing
and the special cases for `sub()' and `gsub()', we recommend the use of
`gawk' and `gensub()' when you have to do substitutions.

Advanced Notes: Matching the Null String
----------------------------------------

In `awk', the `*' operator can match the null string.  This is
particularly important for the `sub()', `gsub()', and `gensub()'
functions.  For example:

     $ echo abc | awk '{ gsub(/m*/, "X"); print }'
     -| XaXbXcX

Although this makes a certain amount of sense, it can be surprising.


File: gawk.info,  Node: I/O Functions,  Next: Time Functions,  Prev: String Functions,  Up: Built-in

9.1.4 Input/Output Functions
----------------------------

The following functions relate to input/output (I/O).  Optional
parameters are enclosed in square brackets ([ ]):

`close(FILENAME [, HOW])'
     Close the file FILENAME for input or output. Alternatively, the
     argument may be a shell command that was used for creating a
     coprocess, or for redirecting to or from a pipe; then the
     coprocess or pipe is closed.  *Note Close Files And Pipes::, for
     more information.

     When closing a coprocess, it is occasionally useful to first close
     one end of the two-way pipe and then to close the other.  This is
     done by providing a second argument to `close()'.  This second
     argument should be one of the two string values `"to"' or `"from"',
     indicating which end of the pipe to close.  Case in the string does
     not matter.  *Note Two-way I/O::, which discusses this feature in
     more detail and gives an example.

`fflush([FILENAME])'
     Flush any buffered output associated with FILENAME, which is
     either a file opened for writing or a shell command for
     redirecting output to a pipe or coprocess. (c.e.).

     Many utility programs "buffer" their output; i.e., they save
     information to write to a disk file or the screen in memory until
     there is enough for it to be worthwhile to send the data to the
     output device.  This is often more efficient than writing every
     little bit of information as soon as it is ready.  However,
     sometimes it is necessary to force a program to "flush" its
     buffers; that is, write the information to its destination, even
     if a buffer is not full.  This is the purpose of the `fflush()'
     function--`gawk' also buffers its output and the `fflush()'
     function forces `gawk' to flush its buffers.

     `fflush()' was added to Brian Kernighan's version of `awk' in
     1994; it is not part of the POSIX standard and is not available if
     `--posix' has been specified on the command line (*note Options::).

     `gawk' extends the `fflush()' function in two ways.  The first is
     to allow no argument at all. In this case, the buffer for the
     standard output is flushed.  The second is to allow the null string
     (`""') as the argument. In this case, the buffers for _all_ open
     output files and pipes are flushed.  Brian Kernighan's `awk' also
     supports these extensions.

     `fflush()' returns zero if the buffer is successfully flushed;
     otherwise, it returns -1.  In the case where all buffers are
     flushed, the return value is zero only if all buffers were flushed
     successfully.  Otherwise, it is -1, and `gawk' warns about the
     problem FILENAME.

     `gawk' also issues a warning message if you attempt to flush a
     file or pipe that was opened for reading (such as with `getline'),
     or if FILENAME is not an open file, pipe, or coprocess.  In such a
     case, `fflush()' returns -1, as well.

`system(COMMAND)'
     Execute the operating-system command COMMAND and then return to
     the `awk' program.  Return COMMAND's exit status.

     For example, if the following fragment of code is put in your `awk'
     program:

          END {
               system("date | mail -s 'awk run done' root")
          }

     the system administrator is sent mail when the `awk' program
     finishes processing input and begins its end-of-input processing.

     Note that redirecting `print' or `printf' into a pipe is often
     enough to accomplish your task.  If you need to run many commands,
     it is more efficient to simply print them down a pipeline to the
     shell:

          while (MORE STUFF TO DO)
              print COMMAND | "/bin/sh"
          close("/bin/sh")

     However, if your `awk' program is interactive, `system()' is
     useful for running large self-contained programs, such as a shell
     or an editor.  Some operating systems cannot implement the
     `system()' function.  `system()' causes a fatal error if it is not
     supported.

          NOTE: When `--sandbox' is specified, the `system()' function
          is disabled (*note Options::).


Advanced Notes: Interactive Versus Noninteractive Buffering
-----------------------------------------------------------

As a side point, buffering issues can be even more confusing, depending
upon whether your program is "interactive", i.e., communicating with a
user sitting at a keyboard.(1)

   Interactive programs generally "line buffer" their output; i.e., they
write out every line.  Noninteractive programs wait until they have a
full buffer, which may be many lines of output.  Here is an example of
the difference:

     $ awk '{ print $1 + $2 }'
     1 1
     -| 2
     2 3
     -| 5
     Ctrl-d

Each line of output is printed immediately. Compare that behavior with
this example:

     $ awk '{ print $1 + $2 }' | cat
     1 1
     2 3
     Ctrl-d
     -| 2
     -| 5

Here, no output is printed until after the `Ctrl-d' is typed, because
it is all buffered and sent down the pipe to `cat' in one shot.

Advanced Notes: Controlling Output Buffering with `system()'
------------------------------------------------------------

The `fflush()' function provides explicit control over output buffering
for individual files and pipes.  However, its use is not portable to
many other `awk' implementations.  An alternative method to flush output
buffers is to call `system()' with a null string as its argument:

     system("")   # flush output

`gawk' treats this use of the `system()' function as a special case and
is smart enough not to run a shell (or other command interpreter) with
the empty command.  Therefore, with `gawk', this idiom is not only
useful, it is also efficient.  While this method should work with other
`awk' implementations, it does not necessarily avoid starting an
unnecessary shell.  (Other implementations may only flush the buffer
associated with the standard output and not necessarily all buffered
output.)

   If you think about what a programmer expects, it makes sense that
`system()' should flush any pending output.  The following program:

     BEGIN {
          print "first print"
          system("echo system echo")
          print "second print"
     }

must print:

     first print
     system echo
     second print

and not:

     system echo
     first print
     second print

   If `awk' did not flush its buffers before calling `system()', you
would see the latter (undesirable) output.

   ---------- Footnotes ----------

   (1) A program is interactive if the standard output is connected to
a terminal device. On modern systems, this means your keyboard and
screen.


File: gawk.info,  Node: Time Functions,  Next: Bitwise Functions,  Prev: I/O Functions,  Up: Built-in

9.1.5 Time Functions
--------------------

`awk' programs are commonly used to process log files containing
timestamp information, indicating when a particular log record was
written.  Many programs log their timestamp in the form returned by the
`time()' system call, which is the number of seconds since a particular
epoch.  On POSIX-compliant systems, it is the number of seconds since
1970-01-01 00:00:00 UTC, not counting leap seconds.(1) All known
POSIX-compliant systems support timestamps from 0 through 2^31 - 1,
which is sufficient to represent times through 2038-01-19 03:14:07 UTC.
Many systems support a wider range of timestamps, including negative
timestamps that represent times before the epoch.

   In order to make it easier to process such log files and to produce
useful reports, `gawk' provides the following functions for working
with timestamps.  They are `gawk' extensions; they are not specified in
the POSIX standard, nor are they in any other known version of `awk'.(2)
Optional parameters are enclosed in square brackets ([ ]):

`mktime(DATESPEC)'
     Turn DATESPEC into a timestamp in the same form as is returned by
     `systime()'.  It is similar to the function of the same name in
     ISO C.  The argument, DATESPEC, is a string of the form
     `"YYYY MM DD HH MM SS [DST]"'.  The string consists of six or
     seven numbers representing, respectively, the full year including
     century, the month from 1 to 12, the day of the month from 1 to
     31, the hour of the day from 0 to 23, the minute from 0 to 59, the
     second from 0 to 60,(3) and an optional daylight-savings flag.

     The values of these numbers need not be within the ranges
     specified; for example, an hour of -1 means 1 hour before midnight.
     The origin-zero Gregorian calendar is assumed, with year 0
     preceding year 1 and year -1 preceding year 0.  The time is
     assumed to be in the local timezone.  If the daylight-savings flag
     is positive, the time is assumed to be daylight savings time; if
     zero, the time is assumed to be standard time; and if negative
     (the default), `mktime()' attempts to determine whether daylight
     savings time is in effect for the specified time.

     If DATESPEC does not contain enough elements or if the resulting
     time is out of range, `mktime()' returns -1.

`strftime([FORMAT [, TIMESTAMP [, UTC-FLAG]]])'
     Format the time specified by TIMESTAMP based on the contents of
     the FORMAT string and return the result.  It is similar to the
     function of the same name in ISO C.  If UTC-FLAG is present and is
     either nonzero or non-null, the value is formatted as UTC
     (Coordinated Universal Time, formerly GMT or Greenwich Mean Time).
     Otherwise, the value is formatted for the local time zone.  The
     TIMESTAMP is in the same format as the value returned by the
     `systime()' function.  If no TIMESTAMP argument is supplied,
     `gawk' uses the current time of day as the timestamp.  If no
     FORMAT argument is supplied, `strftime()' uses the value of
     `PROCINFO["strftime"]' as the format string (*note Built-in
     Variables::).  The default string value is
     `"%a %b %e %H:%M:%S %Z %Y"'.  This format string produces output
     that is equivalent to that of the `date' utility.  You can assign
     a new value to `PROCINFO["strftime"]' to change the default format.

`systime()'
     Return the current time as the number of seconds since the system
     epoch.  On POSIX systems, this is the number of seconds since
     1970-01-01 00:00:00 UTC, not counting leap seconds.  It may be a
     different number on other systems.

   The `systime()' function allows you to compare a timestamp from a
log file with the current time of day.  In particular, it is easy to
determine how long ago a particular record was logged.  It also allows
you to produce log records using the "seconds since the epoch" format.

   The `mktime()' function allows you to convert a textual
representation of a date and time into a timestamp.   This makes it
easy to do before/after comparisons of dates and times, particularly
when dealing with date and time data coming from an external source,
such as a log file.

   The `strftime()' function allows you to easily turn a timestamp into
human-readable information.  It is similar in nature to the `sprintf()'
function (*note String Functions::), in that it copies nonformat
specification characters verbatim to the returned string, while
substituting date and time values for format specifications in the
FORMAT string.

   `strftime()' is guaranteed by the 1999 ISO C standard(4) to support
the following date format specifications:

`%a'
     The locale's abbreviated weekday name.

`%A'
     The locale's full weekday name.

`%b'
     The locale's abbreviated month name.

`%B'
     The locale's full month name.

`%c'
     The locale's "appropriate" date and time representation.  (This is
     `%A %B %d %T %Y' in the `"C"' locale.)

`%C'
     The century part of the current year.  This is the year divided by
     100 and truncated to the next lower integer.

`%d'
     The day of the month as a decimal number (01-31).

`%D'
     Equivalent to specifying `%m/%d/%y'.

`%e'
     The day of the month, padded with a space if it is only one digit.

`%F'
     Equivalent to specifying `%Y-%m-%d'.  This is the ISO 8601 date
     format.

`%g'
     The year modulo 100 of the ISO 8601 week number, as a decimal
     number (00-99).  For example, January 1, 1993 is in week 53 of
     1992. Thus, the year of its ISO 8601 week number is 1992, even
     though its year is 1993.  Similarly, December 31, 1973 is in week
     1 of 1974. Thus, the year of its ISO week number is 1974, even
     though its year is 1973.

`%G'
     The full year of the ISO week number, as a decimal number.

`%h'
     Equivalent to `%b'.

`%H'
     The hour (24-hour clock) as a decimal number (00-23).

`%I'
     The hour (12-hour clock) as a decimal number (01-12).

`%j'
     The day of the year as a decimal number (001-366).

`%m'
     The month as a decimal number (01-12).

`%M'
     The minute as a decimal number (00-59).

`%n'
     A newline character (ASCII LF).

`%p'
     The locale's equivalent of the AM/PM designations associated with
     a 12-hour clock.

`%r'
     The locale's 12-hour clock time.  (This is `%I:%M:%S %p' in the
     `"C"' locale.)

`%R'
     Equivalent to specifying `%H:%M'.

`%S'
     The second as a decimal number (00-60).

`%t'
     A TAB character.

`%T'
     Equivalent to specifying `%H:%M:%S'.

`%u'
     The weekday as a decimal number (1-7).  Monday is day one.

`%U'
     The week number of the year (the first Sunday as the first day of
     week one) as a decimal number (00-53).

`%V'
     The week number of the year (the first Monday as the first day of
     week one) as a decimal number (01-53).  The method for determining
     the week number is as specified by ISO 8601.  (To wit: if the week
     containing January 1 has four or more days in the new year, then
     it is week one; otherwise it is week 53 of the previous year and
     the next week is week one.)

`%w'
     The weekday as a decimal number (0-6).  Sunday is day zero.

`%W'
     The week number of the year (the first Monday as the first day of
     week one) as a decimal number (00-53).

`%x'
     The locale's "appropriate" date representation.  (This is `%A %B
     %d %Y' in the `"C"' locale.)

`%X'
     The locale's "appropriate" time representation.  (This is `%T' in
     the `"C"' locale.)

`%y'
     The year modulo 100 as a decimal number (00-99).

`%Y'
     The full year as a decimal number (e.g., 2011).

`%z'
     The timezone offset in a +HHMM format (e.g., the format necessary
     to produce RFC 822/RFC 1036 date headers).

`%Z'
     The time zone name or abbreviation; no characters if no time zone
     is determinable.

`%Ec %EC %Ex %EX %Ey %EY %Od %Oe %OH'
`%OI %Om %OM %OS %Ou %OU %OV %Ow %OW %Oy'
     "Alternate representations" for the specifications that use only
     the second letter (`%c', `%C', and so on).(5) (These facilitate
     compliance with the POSIX `date' utility.)

`%%'
     A literal `%'.

   If a conversion specifier is not one of the above, the behavior is
undefined.(6)

   Informally, a "locale" is the geographic place in which a program is
meant to run.  For example, a common way to abbreviate the date
September 4, 2012 in the United States is "9/4/12."  In many countries
in Europe, however, it is abbreviated "4.9.12."  Thus, the `%x'
specification in a `"US"' locale might produce `9/4/12', while in a
`"EUROPE"' locale, it might produce `4.9.12'.  The ISO C standard
defines a default `"C"' locale, which is an environment that is typical
of what many C programmers are used to.

   For systems that are not yet fully standards-compliant, `gawk'
supplies a copy of `strftime()' from the GNU C Library.  It supports
all of the just-listed format specifications.  If that version is used
to compile `gawk' (*note Installation::), then the following additional
format specifications are available:

`%k'
     The hour (24-hour clock) as a decimal number (0-23).  Single-digit
     numbers are padded with a space.

`%l'
     The hour (12-hour clock) as a decimal number (1-12).  Single-digit
     numbers are padded with a space.

`%s'
     The time as a decimal timestamp in seconds since the epoch.


   Additionally, the alternate representations are recognized but their
normal representations are used.

   The following example is an `awk' implementation of the POSIX `date'
utility.  Normally, the `date' utility prints the current date and time
of day in a well-known format.  However, if you provide an argument to
it that begins with a `+', `date' copies nonformat specifier characters
to the standard output and interprets the current time according to the
format specifiers in the string.  For example:

     $ date '+Today is %A, %B %d, %Y.'
     -| Today is Wednesday, March 30, 2011.

   Here is the `gawk' version of the `date' utility.  It has a shell
"wrapper" to handle the `-u' option, which requires that `date' run as
if the time zone is set to UTC:

     #! /bin/sh
     #
     # date --- approximate the POSIX 'date' command

     case $1 in
     -u)  TZ=UTC0     # use UTC
          export TZ
          shift ;;
     esac

     gawk 'BEGIN  {
         format = "%a %b %e %H:%M:%S %Z %Y"
         exitval = 0

         if (ARGC > 2)
             exitval = 1
         else if (ARGC == 2) {
             format = ARGV[1]
             if (format ~ /^\+/)
                 format = substr(format, 2)   # remove leading +
         }
         print strftime(format)
         exit exitval
     }' "$@"

   ---------- Footnotes ----------

   (1) *Note Glossary::, especially the entries "Epoch" and "UTC."

   (2) The GNU `date' utility can also do many of the things described
here.  Its use may be preferable for simple time-related operations in
shell scripts.

   (3) Occasionally there are minutes in a year with a leap second,
which is why the seconds can go up to 60.

   (4) Unfortunately, not every system's `strftime()' necessarily
supports all of the conversions listed here.

   (5) If you don't understand any of this, don't worry about it; these
facilities are meant to make it easier to "internationalize" programs.
Other internationalization features are described in *note
Internationalization::.

   (6) This is because ISO C leaves the behavior of the C version of
`strftime()' undefined and `gawk' uses the system's version of
`strftime()' if it's there.  Typically, the conversion specifier either
does not appear in the returned string or appears literally.


File: gawk.info,  Node: Bitwise Functions,  Next: Type Functions,  Prev: Time Functions,  Up: Built-in

9.1.6 Bit-Manipulation Functions
--------------------------------

     I can explain it for you, but I can't understand it for you.
     Anonymous

   Many languages provide the ability to perform "bitwise" operations
on two integer numbers.  In other words, the operation is performed on
each successive pair of bits in the operands.  Three common operations
are bitwise AND, OR, and XOR.  The operations are described in *note
table-bitwise-ops::.

                     Bit Operator
               |  AND  |   OR  |  XOR
               |--+--+--+--+--+--
     Operands  | 0 | 1 | 0 | 1 | 0 | 1
     ---------+--+--+--+--+--+--
         0     | 0   0 | 0   1 | 0   1
         1     | 0   1 | 1   1 | 1   0

Table 9.4: Bitwise Operations

   As you can see, the result of an AND operation is 1 only when _both_
bits are 1.  The result of an OR operation is 1 if _either_ bit is 1.
The result of an XOR operation is 1 if either bit is 1, but not both.
The next operation is the "complement"; the complement of 1 is 0 and
the complement of 0 is 1. Thus, this operation "flips" all the bits of
a given value.

   Finally, two other common operations are to shift the bits left or
right.  For example, if you have a bit string `10111001' and you shift
it right by three bits, you end up with `00010111'.(1) If you start over
again with `10111001' and shift it left by three bits, you end up with
`11001000'.  `gawk' provides built-in functions that implement the
bitwise operations just described. They are:

`and(V1, V2)'
     Return the bitwise AND of the values provided by V1 and V2.

`compl(VAL)'
     Return the bitwise complement of VAL.

`lshift(VAL, COUNT)'
     Return the value of VAL, shifted left by COUNT bits.

`or(V1, V2)'
     Return the bitwise OR of the values provided by V1 and V2.

`rshift(VAL, COUNT)'
     Return the value of VAL, shifted right by COUNT bits.

`xor(V1, V2)'
     Return the bitwise XOR of the values provided by V1 and V2.

   For all of these functions, first the double precision
floating-point value is converted to the widest C unsigned integer
type, then the bitwise operation is performed.  If the result cannot be
represented exactly as a C `double', leading nonzero bits are removed
one by one until it can be represented exactly.  The result is then
converted back into a C `double'.  (If you don't understand this
paragraph, don't worry about it.)

   Here is a user-defined function (*note User-defined::) that
illustrates the use of these functions:

     # bits2str --- turn a byte into readable 1's and 0's

     function bits2str(bits,        data, mask)
     {
         if (bits == 0)
             return "0"

         mask = 1
         for (; bits != 0; bits = rshift(bits, 1))
             data = (and(bits, mask) ? "1" : "0") data

         while ((length(data) % 8) != 0)
             data = "0" data

         return data
     }

     BEGIN {
         printf "123 = %s\n", bits2str(123)
         printf "0123 = %s\n", bits2str(0123)
         printf "0x99 = %s\n", bits2str(0x99)
         comp = compl(0x99)
         printf "compl(0x99) = %#x = %s\n", comp, bits2str(comp)
         shift = lshift(0x99, 2)
         printf "lshift(0x99, 2) = %#x = %s\n", shift, bits2str(shift)
         shift = rshift(0x99, 2)
         printf "rshift(0x99, 2) = %#x = %s\n", shift, bits2str(shift)
     }

This program produces the following output when run:

     $ gawk -f testbits.awk
     -| 123 = 01111011
     -| 0123 = 01010011
     -| 0x99 = 10011001
     -| compl(0x99) = 0xffffff66 = 11111111111111111111111101100110
     -| lshift(0x99, 2) = 0x264 = 0000001001100100
     -| rshift(0x99, 2) = 0x26 = 00100110

   The `bits2str()' function turns a binary number into a string.  The
number `1' represents a binary value where the rightmost bit is set to
1.  Using this mask, the function repeatedly checks the rightmost bit.
ANDing the mask with the value indicates whether the rightmost bit is 1
or not. If so, a `"1"' is concatenated onto the front of the string.
Otherwise, a `"0"' is added.  The value is then shifted right by one
bit and the loop continues until there are no more 1 bits.

   If the initial value is zero it returns a simple `"0"'.  Otherwise,
at the end, it pads the value with zeros to represent multiples of
8-bit quantities. This is typical in modern computers.

   The main code in the `BEGIN' rule shows the difference between the
decimal and octal values for the same numbers (*note
Nondecimal-numbers::), and then demonstrates the results of the
`compl()', `lshift()', and `rshift()' functions.

   ---------- Footnotes ----------

   (1) This example shows that 0's come in on the left side. For
`gawk', this is always true, but in some languages, it's possible to
have the left side fill with 1's. Caveat emptor.


File: gawk.info,  Node: Type Functions,  Next: I18N Functions,  Prev: Bitwise Functions,  Up: Built-in

9.1.7 Getting Type Information
------------------------------

`gawk' provides a single function that lets you distinguish an array
from a scalar variable.  This is necessary for writing code that
traverses every element of a true multidimensional array (*note Arrays
of Arrays::).

`isarray(X)'
     Return a true value if X is an array. Otherwise return false.


File: gawk.info,  Node: I18N Functions,  Prev: Type Functions,  Up: Built-in

9.1.8 String-Translation Functions
----------------------------------

`gawk' provides facilities for internationalizing `awk' programs.
These include the functions described in the following list.  The
descriptions here are purposely brief.  *Note Internationalization::,
for the full story.  Optional parameters are enclosed in square
brackets ([ ]):

`bindtextdomain(DIRECTORY [, DOMAIN])'
     Set the directory in which `gawk' will look for message
     translation files, in case they will not or cannot be placed in
     the "standard" locations (e.g., during testing).  It returns the
     directory in which DOMAIN is "bound."

     The default DOMAIN is the value of `TEXTDOMAIN'.  If DIRECTORY is
     the null string (`""'), then `bindtextdomain()' returns the
     current binding for the given DOMAIN.

`dcgettext(STRING [, DOMAIN [, CATEGORY]])'
     Return the translation of STRING in text domain DOMAIN for locale
     category CATEGORY.  The default value for DOMAIN is the current
     value of `TEXTDOMAIN'.  The default value for CATEGORY is
     `"LC_MESSAGES"'.

`dcngettext(STRING1, STRING2, NUMBER [, DOMAIN [, CATEGORY]])'
     Return the plural form used for NUMBER of the translation of
     STRING1 and STRING2 in text domain DOMAIN for locale category
     CATEGORY. STRING1 is the English singular variant of a message,
     and STRING2 the English plural variant of the same message.  The
     default value for DOMAIN is the current value of `TEXTDOMAIN'.
     The default value for CATEGORY is `"LC_MESSAGES"'.


File: gawk.info,  Node: User-defined,  Next: Indirect Calls,  Prev: Built-in,  Up: Functions

9.2 User-Defined Functions
==========================

Complicated `awk' programs can often be simplified by defining your own
functions.  User-defined functions can be called just like built-in
ones (*note Function Calls::), but it is up to you to define them,
i.e., to tell `awk' what they should do.

* Menu:

* Definition Syntax::           How to write definitions and what they mean.
* Function Example::            An example function definition and what it
                                does.
* Function Caveats::            Things to watch out for.
* Return Statement::            Specifying the value a function returns.
* Dynamic Typing::              How variable types can change at runtime.


File: gawk.info,  Node: Definition Syntax,  Next: Function Example,  Up: User-defined

9.2.1 Function Definition Syntax
--------------------------------

Definitions of functions can appear anywhere between the rules of an
`awk' program.  Thus, the general form of an `awk' program is extended
to include sequences of rules _and_ user-defined function definitions.
There is no need to put the definition of a function before all uses of
the function.  This is because `awk' reads the entire program before
starting to execute any of it.

   The definition of a function named NAME looks like this:

     function NAME([PARAMETER-LIST])
     {
          BODY-OF-FUNCTION
     }

Here, NAME is the name of the function to define.  A valid function
name is like a valid variable name: a sequence of letters, digits, and
underscores that doesn't start with a digit.  Within a single `awk'
program, any particular name can only be used as a variable, array, or
function.

   PARAMETER-LIST is an optional list of the function's arguments and
local variable names, separated by commas.  When the function is called,
the argument names are used to hold the argument values given in the
call.  The local variables are initialized to the empty string.  A
function cannot have two parameters with the same name, nor may it have
a parameter with the same name as the function itself.

   In addition, according to the POSIX standard, function parameters
cannot have the same name as one of the special built-in variables
(*note Built-in Variables::.  Not all versions of `awk' enforce this
restriction.

   The BODY-OF-FUNCTION consists of `awk' statements.  It is the most
important part of the definition, because it says what the function
should actually _do_.  The argument names exist to give the body a way
to talk about the arguments; local variables exist to give the body
places to keep temporary values.

   Argument names are not distinguished syntactically from local
variable names. Instead, the number of arguments supplied when the
function is called determines how many argument variables there are.
Thus, if three argument values are given, the first three names in
PARAMETER-LIST are arguments and the rest are local variables.

   It follows that if the number of arguments is not the same in all
calls to the function, some of the names in PARAMETER-LIST may be
arguments on some occasions and local variables on others.  Another way
to think of this is that omitted arguments default to the null string.

   Usually when you write a function, you know how many names you
intend to use for arguments and how many you intend to use as local
variables.  It is conventional to place some extra space between the
arguments and the local variables, in order to document how your
function is supposed to be used.

   During execution of the function body, the arguments and local
variable values hide, or "shadow", any variables of the same names used
in the rest of the program.  The shadowed variables are not accessible
in the function definition, because there is no way to name them while
their names have been taken away for the local variables.  All other
variables used in the `awk' program can be referenced or set normally
in the function's body.

   The arguments and local variables last only as long as the function
body is executing.  Once the body finishes, you can once again access
the variables that were shadowed while the function was running.

   The function body can contain expressions that call functions.  They
can even call this function, either directly or by way of another
function.  When this happens, we say the function is "recursive".  The
act of a function calling itself is called "recursion".

   All the built-in functions return a value to their caller.
User-defined functions can do also, using the `return' statement, which
is described in detail in *note Return Statement::.  Many of the
subsequent examples in this minor node use the `return' statement.

   In many `awk' implementations, including `gawk', the keyword
`function' may be abbreviated `func'. (c.e.)  However, POSIX only
specifies the use of the keyword `function'.  This actually has some
practical implications.  If `gawk' is in POSIX-compatibility mode
(*note Options::), then the following statement does _not_ define a
function:

     func foo() { a = sqrt($1) ; print a }

Instead it defines a rule that, for each record, concatenates the value
of the variable `func' with the return value of the function `foo'.  If
the resulting string is non-null, the action is executed.  This is
probably not what is desired.  (`awk' accepts this input as
syntactically valid, because functions may be used before they are
defined in `awk' programs.(1))

   To ensure that your `awk' programs are portable, always use the
keyword `function' when defining a function.

   ---------- Footnotes ----------

   (1) This program won't actually run, since `foo()' is undefined.


File: gawk.info,  Node: Function Example,  Next: Function Caveats,  Prev: Definition Syntax,  Up: User-defined

9.2.2 Function Definition Examples
----------------------------------

Here is an example of a user-defined function, called `myprint()', that
takes a number and prints it in a specific format:

     function myprint(num)
     {
          printf "%6.3g\n", num
     }

To illustrate, here is an `awk' rule that uses our `myprint' function:

     $3 > 0     { myprint($3) }

This program prints, in our special format, all the third fields that
contain a positive number in our input.  Therefore, when given the
following input:

      1.2   3.4    5.6   7.8
      9.10 11.12 -13.14 15.16
     17.18 19.20  21.22 23.24

this program, using our function to format the results, prints:

        5.6
       21.2

   This function deletes all the elements in an array:

     function delarray(a,    i)
     {
         for (i in a)
            delete a[i]
     }

   When working with arrays, it is often necessary to delete all the
elements in an array and start over with a new list of elements (*note
Delete::).  Instead of having to repeat this loop everywhere that you
need to clear out an array, your program can just call `delarray'.
(This guarantees portability.  The use of `delete ARRAY' to delete the
contents of an entire array is a nonstandard extension.)

   The following is an example of a recursive function.  It takes a
string as an input parameter and returns the string in backwards order.
Recursive functions must always have a test that stops the recursion.
In this case, the recursion terminates when the starting position is
zero, i.e., when there are no more characters left in the string.

     function rev(str, start)
     {
         if (start == 0)
             return ""

         return (substr(str, start, 1) rev(str, start - 1))
     }

   If this function is in a file named `rev.awk', it can be tested this
way:

     $ echo "Don't Panic!" |
     > gawk --source '{ print rev($0, length($0)) }' -f rev.awk
     -| !cinaP t'noD

   The C `ctime()' function takes a timestamp and returns it in a
string, formatted in a well-known fashion.  The following example uses
the built-in `strftime()' function (*note Time Functions::) to create
an `awk' version of `ctime()':

     # ctime.awk
     #
     # awk version of C ctime(3) function

     function ctime(ts,    format)
     {
         format = "%a %b %e %H:%M:%S %Z %Y"
         if (ts == 0)
             ts = systime()       # use current time as default
         return strftime(format, ts)
     }


File: gawk.info,  Node: Function Caveats,  Next: Return Statement,  Prev: Function Example,  Up: User-defined

9.2.3 Calling User-Defined Functions
------------------------------------

This section describes how to call a user-defined function.

* Menu:

* Calling A Function::          Don't use spaces.
* Variable Scope::              Controlling variable scope.
* Pass By Value/Reference::     Passing parameters.


File: gawk.info,  Node: Calling A Function,  Next: Variable Scope,  Up: Function Caveats

9.2.3.1 Writing A Function Call
...............................

"Calling a function" means causing the function to run and do its job.
A function call is an expression and its value is the value returned by
the function.

   A function call consists of the function name followed by the
arguments in parentheses.  `awk' expressions are what you write in the
call for the arguments.  Each time the call is executed, these
expressions are evaluated, and the values become the actual arguments.
For example, here is a call to `foo()' with three arguments (the first
being a string concatenation):

     foo(x y, "lose", 4 * z)

     CAUTION: Whitespace characters (spaces and TABs) are not allowed
     between the function name and the open-parenthesis of the argument
     list.  If you write whitespace by mistake, `awk' might think that
     you mean to concatenate a variable with an expression in
     parentheses.  However, it notices that you used a function name
     and not a variable name, and reports an error.


File: gawk.info,  Node: Variable Scope,  Next: Pass By Value/Reference,  Prev: Calling A Function,  Up: Function Caveats

9.2.3.2 Controlling Variable Scope
..................................

There is no way to make a variable local to a `{ ... }' block in `awk',
but you can make a variable local to a function. It is good practice to
do so whenever a variable is needed only in that function.

   To make a variable local to a function, simply declare the variable
as an argument after the actual function arguments (*note Definition
Syntax::).  Look at the following example where variable `i' is a
global variable used by both functions `foo()' and `bar()':

     function bar()
     {
         for (i = 0; i < 3; i++)
             print "bar's i=" i
     }

     function foo(j)
     {
         i = j + 1
         print "foo's i=" i
         bar()
         print "foo's i=" i
     }

     BEGIN {
           i = 10
           print "top's i=" i
           foo(0)
           print "top's i=" i
     }

   Running this script produces the following, because the `i' in
functions `foo()' and `bar()' and at the top level refer to the same
variable instance:

     top's i=10
     foo's i=1
     bar's i=0
     bar's i=1
     bar's i=2
     foo's i=3
     top's i=3

   If you want `i' to be local to both `foo()' and `bar()' do as
follows (the extra-space before `i' is a coding convention to indicate
that `i' is a local variable, not an argument):

     function bar(    i)
     {
         for (i = 0; i < 3; i++)
             print "bar's i=" i
     }

     function foo(j,    i)
     {
         i = j + 1
         print "foo's i=" i
         bar()
         print "foo's i=" i
     }

     BEGIN {
           i = 10
           print "top's i=" i
           foo(0)
           print "top's i=" i
     }

   Running the corrected script produces the following:

     top's i=10
     foo's i=1
     bar's i=0
     bar's i=1
     bar's i=2
     foo's i=1
     top's i=10


File: gawk.info,  Node: Pass By Value/Reference,  Prev: Variable Scope,  Up: Function Caveats

9.2.3.3 Passing Function Arguments By Value Or By Reference
...........................................................

In `awk', when you declare a function, there is no way to declare
explicitly whether the arguments are passed "by value" or "by
reference".

   Instead the passing convention is determined at runtime when the
function is called according to the following rule:

   * If the argument is an array variable, then it is passed by
     reference,

   * Otherwise the argument is passed by value.

   Passing an argument by value means that when a function is called, it
is given a _copy_ of the value of this argument.  The caller may use a
variable as the expression for the argument, but the called function
does not know this--it only knows what value the argument had.  For
example, if you write the following code:

     foo = "bar"
     z = myfunc(foo)

then you should not think of the argument to `myfunc()' as being "the
variable `foo'."  Instead, think of the argument as the string value
`"bar"'.  If the function `myfunc()' alters the values of its local
variables, this has no effect on any other variables.  Thus, if
`myfunc()' does this:

     function myfunc(str)
     {
        print str
        str = "zzz"
        print str
     }

to change its first argument variable `str', it does _not_ change the
value of `foo' in the caller.  The role of `foo' in calling `myfunc()'
ended when its value (`"bar"') was computed.  If `str' also exists
outside of `myfunc()', the function body cannot alter this outer value,
because it is shadowed during the execution of `myfunc()' and cannot be
seen or changed from there.

   However, when arrays are the parameters to functions, they are _not_
copied.  Instead, the array itself is made available for direct
manipulation by the function.  This is usually termed "call by
reference".  Changes made to an array parameter inside the body of a
function _are_ visible outside that function.

     NOTE: Changing an array parameter inside a function can be very
     dangerous if you do not watch what you are doing.  For example:

          function changeit(array, ind, nvalue)
          {
               array[ind] = nvalue
          }

          BEGIN {
              a[1] = 1; a[2] = 2; a[3] = 3
              changeit(a, 2, "two")
              printf "a[1] = %s, a[2] = %s, a[3] = %s\n",
                      a[1], a[2], a[3]
          }

     prints `a[1] = 1, a[2] = two, a[3] = 3', because `changeit' stores
     `"two"' in the second element of `a'.

   Some `awk' implementations allow you to call a function that has not
been defined. They only report a problem at runtime when the program
actually tries to call the function. For example:

     BEGIN {
         if (0)
             foo()
         else
             bar()
     }
     function bar() { ... }
     # note that `foo' is not defined

Because the `if' statement will never be true, it is not really a
problem that `foo()' has not been defined.  Usually, though, it is a
problem if a program calls an undefined function.

   If `--lint' is specified (*note Options::), `gawk' reports calls to
undefined functions.

   Some `awk' implementations generate a runtime error if you use the
`next' statement (*note Next Statement::) inside a user-defined
function.  `gawk' does not have this limitation.


File: gawk.info,  Node: Return Statement,  Next: Dynamic Typing,  Prev: Function Caveats,  Up: User-defined

9.2.4 The `return' Statement
----------------------------

As seen in several earlier examples, the body of a user-defined
function can contain a `return' statement.  This statement returns
control to the calling part of the `awk' program.  It can also be used
to return a value for use in the rest of the `awk' program.  It looks
like this:

     return [EXPRESSION]

   The EXPRESSION part is optional.  Due most likely to an oversight,
POSIX does not define what the return value is if you omit the
EXPRESSION.  Technically speaking, this make the returned value
undefined, and therefore, unpredictable.  In practice, though, all
versions of `awk' simply return the null string, which acts like zero
if used in a numeric context.

   A `return' statement with no value expression is assumed at the end
of every function definition.  So if control reaches the end of the
function body, then technically, the function returns an unpredictable
value.  In practice, it returns the empty string.  `awk' does _not_
warn you if you use the return value of such a function.

   Sometimes, you want to write a function for what it does, not for
what it returns.  Such a function corresponds to a `void' function in
C, C++ or Java, or to a `procedure' in Ada.  Thus, it may be
appropriate to not return any value; simply bear in mind that you
should not be using the return value of such a function.

   The following is an example of a user-defined function that returns
a value for the largest number among the elements of an array:

     function maxelt(vec,   i, ret)
     {
          for (i in vec) {
               if (ret == "" || vec[i] > ret)
                    ret = vec[i]
          }
          return ret
     }

You call `maxelt()' with one argument, which is an array name.  The
local variables `i' and `ret' are not intended to be arguments; while
there is nothing to stop you from passing more than one argument to
`maxelt()', the results would be strange.  The extra space before `i'
in the function parameter list indicates that `i' and `ret' are local
variables.  You should follow this convention when defining functions.

   The following program uses the `maxelt()' function.  It loads an
array, calls `maxelt()', and then reports the maximum number in that
array:

     function maxelt(vec,   i, ret)
     {
          for (i in vec) {
               if (ret == "" || vec[i] > ret)
                    ret = vec[i]
          }
          return ret
     }

     # Load all fields of each record into nums.
     {
          for(i = 1; i <= NF; i++)
               nums[NR, i] = $i
     }

     END {
          print maxelt(nums)
     }

   Given the following input:

      1 5 23 8 16
     44 3 5 2 8 26
     256 291 1396 2962 100
     -6 467 998 1101
     99385 11 0 225

the program reports (predictably) that 99,385 is the largest value in
the array.


File: gawk.info,  Node: Dynamic Typing,  Prev: Return Statement,  Up: User-defined

9.2.5 Functions and Their Effects on Variable Typing
----------------------------------------------------

`awk' is a very fluid language.  It is possible that `awk' can't tell
if an identifier represents a scalar variable or an array until runtime.
Here is an annotated sample program:

     function foo(a)
     {
         a[1] = 1   # parameter is an array
     }

     BEGIN {
         b = 1
         foo(b)  # invalid: fatal type mismatch

         foo(x)  # x uninitialized, becomes an array dynamically
         x = 1   # now not allowed, runtime error
     }

   Usually, such things aren't a big issue, but it's worth being aware
of them.


File: gawk.info,  Node: Indirect Calls,  Prev: User-defined,  Up: Functions

9.3 Indirect Function Calls
===========================

This section describes a `gawk'-specific extension.

   Often, you may wish to defer the choice of function to call until
runtime.  For example, you may have different kinds of records, each of
which should be processed differently.

   Normally, you would have to use a series of `if'-`else' statements
to decide which function to call.  By using "indirect" function calls,
you can specify the name of the function to call as a string variable,
and then call the function.  Let's look at an example.

   Suppose you have a file with your test scores for the classes you
are taking.  The first field is the class name. The following fields
are the functions to call to process the data, up to a "marker" field
`data:'.  Following the marker, to the end of the record, are the
various numeric test scores.

   Here is the initial file; you wish to get the sum and the average of
your test scores:

     Biology_101 sum average data: 87.0 92.4 78.5 94.9
     Chemistry_305 sum average data: 75.2 98.3 94.7 88.2
     English_401 sum average data: 100.0 95.6 87.1 93.4

   To process the data, you might write initially:

     {
         class = $1
         for (i = 2; $i != "data:"; i++) {
             if ($i == "sum")
                 sum()   # processes the whole record
             else if ($i == "average")
                 average()
             ...           # and so on
         }
     }

This style of programming works, but can be awkward.  With "indirect"
function calls, you tell `gawk' to use the _value_ of a variable as the
name of the function to call.

   The syntax is similar to that of a regular function call: an
identifier immediately followed by a left parenthesis, any arguments,
and then a closing right parenthesis, with the addition of a leading `@'
character:

     the_func = "sum"
     result = @the_func()   # calls the `sum' function

   Here is a full program that processes the previously shown data,
using indirect function calls.

     # indirectcall.awk --- Demonstrate indirect function calls

     # average --- return the average of the values in fields $first - $last

     function average(first, last,   sum, i)
     {
         sum = 0;
         for (i = first; i <= last; i++)
             sum += $i

         return sum / (last - first + 1)
     }

     # sum --- return the sum of the values in fields $first - $last

     function sum(first, last,   ret, i)
     {
         ret = 0;
         for (i = first; i <= last; i++)
             ret += $i

         return ret
     }

   These two functions expect to work on fields; thus the parameters
`first' and `last' indicate where in the fields to start and end.
Otherwise they perform the expected computations and are not unusual.

     # For each record, print the class name and the requested statistics

     {
         class_name = $1
         gsub(/_/, " ", class_name)  # Replace _ with spaces

         # find start
         for (i = 1; i <= NF; i++) {
             if ($i == "data:") {
                 start = i + 1
                 break
             }
         }

         printf("%s:\n", class_name)
         for (i = 2; $i != "data:"; i++) {
             the_function = $i
             printf("\t%s: <%s>\n", $i, @the_function(start, NF) "")
         }
         print ""
     }

   This is the main processing for each record. It prints the class
name (with underscores replaced with spaces). It then finds the start
of the actual data, saving it in `start'.  The last part of the code
loops through each function name (from `$2' up to the marker, `data:'),
calling the function named by the field. The indirect function call
itself occurs as a parameter in the call to `printf'.  (The `printf'
format string uses `%s' as the format specifier so that we can use
functions that return strings, as well as numbers. Note that the result
from the indirect call is concatenated with the empty string, in order
to force it to be a string value.)

   Here is the result of running the program:

     $ gawk -f indirectcall.awk class_data1
     -| Biology 101:
     -|     sum: <352.8>
     -|     average: <88.2>
     -|
     -| Chemistry 305:
     -|     sum: <356.4>
     -|     average: <89.1>
     -|
     -| English 401:
     -|     sum: <376.1>
     -|     average: <94.025>

   The ability to use indirect function calls is more powerful than you
may think at first.  The C and C++ languages provide "function
pointers," which are a mechanism for calling a function chosen at
runtime.  One of the most well-known uses of this ability is the C
`qsort()' function, which sorts an array using the famous "quick sort"
algorithm (see the Wikipedia article
(http://en.wikipedia.org/wiki/Quick_sort) for more information).  To
use this function, you supply a pointer to a comparison function.  This
mechanism allows you to sort arbitrary data in an arbitrary fashion.

   We can do something similar using `gawk', like this:

     # quicksort.awk --- Quicksort algorithm, with user-supplied
     #                   comparison function
     # quicksort --- C.A.R. Hoare's quick sort algorithm. See Wikipedia
     #               or almost any algorithms or computer science text

     function quicksort(data, left, right, less_than,    i, last)
     {
         if (left >= right)  # do nothing if array contains fewer
             return          # than two elements

         quicksort_swap(data, left, int((left + right) / 2))
         last = left
         for (i = left + 1; i <= right; i++)
             if (@less_than(data[i], data[left]))
                 quicksort_swap(data, ++last, i)
         quicksort_swap(data, left, last)
         quicksort(data, left, last - 1, less_than)
         quicksort(data, last + 1, right, less_than)
     }

     # quicksort_swap --- helper function for quicksort, should really be inline

     function quicksort_swap(data, i, j, temp)
     {
         temp = data[i]
         data[i] = data[j]
         data[j] = temp
     }

   The `quicksort()' function receives the `data' array, the starting
and ending indices to sort (`left' and `right'), and the name of a
function that performs a "less than" comparison.  It then implements
the quick sort algorithm.

   To make use of the sorting function, we return to our previous
example. The first thing to do is write some comparison functions:

     # num_lt --- do a numeric less than comparison

     function num_lt(left, right)
     {
         return ((left + 0) < (right + 0))
     }

     # num_ge --- do a numeric greater than or equal to comparison

     function num_ge(left, right)
     {
         return ((left + 0) >= (right + 0))
     }

   The `num_ge()' function is needed to perform a descending sort; when
used to perform a "less than" test, it actually does the opposite
(greater than or equal to), which yields data sorted in descending
order.

   Next comes a sorting function.  It is parameterized with the
starting and ending field numbers and the comparison function. It
builds an array with the data and calls `quicksort' appropriately, and
then formats the results as a single string:

     # do_sort --- sort the data according to `compare'
     #             and return it as a string

     function do_sort(first, last, compare,      data, i, retval)
     {
         delete data
         for (i = 1; first <= last; first++) {
             data[i] = $first
             i++
         }

         quicksort(data, 1, i-1, compare)

         retval = data[1]
         for (i = 2; i in data; i++)
             retval = retval " " data[i]

         return retval
     }

   Finally, the two sorting functions call `do_sort()', passing in the
names of the two comparison functions:

     # sort --- sort the data in ascending order and return it as a string

     function sort(first, last)
     {
         return do_sort(first, last, "num_lt")
     }

     # rsort --- sort the data in descending order and return it as a string

     function rsort(first, last)
     {
         return do_sort(first, last, "num_ge")
     }

   Here is an extended version of the data file:

     Biology_101 sum average sort rsort data: 87.0 92.4 78.5 94.9
     Chemistry_305 sum average sort rsort data: 75.2 98.3 94.7 88.2
     English_401 sum average sort rsort data: 100.0 95.6 87.1 93.4

   Finally, here are the results when the enhanced program is run:

     $ gawk -f quicksort.awk -f indirectcall.awk class_data2
     -| Biology 101:
     -|     sum: <352.8>
     -|     average: <88.2>
     -|     sort: <78.5 87.0 92.4 94.9>
     -|     rsort: <94.9 92.4 87.0 78.5>
     -|
     -| Chemistry 305:
     -|     sum: <356.4>
     -|     average: <89.1>
     -|     sort: <75.2 88.2 94.7 98.3>
     -|     rsort: <98.3 94.7 88.2 75.2>
     -|
     -| English 401:
     -|     sum: <376.1>
     -|     average: <94.025>
     -|     sort: <87.1 93.4 95.6 100.0>
     -|     rsort: <100.0 95.6 93.4 87.1>

   Remember that you must supply a leading `@' in front of an indirect
function call.

   Unfortunately, indirect function calls cannot be used with the
built-in functions.  However, you can generally write "wrapper"
functions which call the built-in ones, and those can be called
indirectly. (Other than, perhaps, the mathematical functions, there is
not a lot of reason to try to call the built-in functions indirectly.)

   `gawk' does its best to make indirect function calls efficient.  For
example, in the following case:

     for (i = 1; i <= n; i++)
         @the_func()

`gawk' will look up the actual function to call only once.


File: gawk.info,  Node: Internationalization,  Next: Advanced Features,  Prev: Functions,  Up: Top

10 Internationalization with `gawk'
***********************************

Once upon a time, computer makers wrote software that worked only in
English.  Eventually, hardware and software vendors noticed that if
their systems worked in the native languages of non-English-speaking
countries, they were able to sell more systems.  As a result,
internationalization and localization of programs and software systems
became a common practice.

   For many years, the ability to provide internationalization was
largely restricted to programs written in C and C++.  This major node
describes the underlying library `gawk' uses for internationalization,
as well as how `gawk' makes internationalization features available at
the `awk' program level.  Having internationalization available at the
`awk' level gives software developers additional flexibility--they are
no longer forced to write in C or C++ when internationalization is a
requirement.

* Menu:

* I18N and L10N::               Internationalization and Localization.
* Explaining gettext::          How GNU `gettext' works.
* Programmer i18n::             Features for the programmer.
* Translator i18n::             Features for the translator.
* I18N Example::                A simple i18n example.
* Gawk I18N::                   `gawk' is also internationalized.


File: gawk.info,  Node: I18N and L10N,  Next: Explaining gettext,  Up: Internationalization

10.1 Internationalization and Localization
==========================================

"Internationalization" means writing (or modifying) a program once, in
such a way that it can use multiple languages without requiring further
source-code changes.  "Localization" means providing the data necessary
for an internationalized program to work in a particular language.
Most typically, these terms refer to features such as the language used
for printing error messages, the language used to read responses, and
information related to how numerical and monetary values are printed
and read.


File: gawk.info,  Node: Explaining gettext,  Next: Programmer i18n,  Prev: I18N and L10N,  Up: Internationalization

10.2 GNU `gettext'
==================

The facilities in GNU `gettext' focus on messages; strings printed by a
program, either directly or via formatting with `printf' or
`sprintf()'.(1)

   When using GNU `gettext', each application has its own "text
domain".  This is a unique name, such as `kpilot' or `gawk', that
identifies the application.  A complete application may have multiple
components--programs written in C or C++, as well as scripts written in
`sh' or `awk'.  All of the components use the same text domain.

   To make the discussion concrete, assume we're writing an application
named `guide'.  Internationalization consists of the following steps,
in this order:

  1. The programmer goes through the source for all of `guide''s
     components and marks each string that is a candidate for
     translation.  For example, `"`-F': option required"' is a good
     candidate for translation.  A table with strings of option names
     is not (e.g., `gawk''s `--profile' option should remain the same,
     no matter what the local language).

  2. The programmer indicates the application's text domain (`"guide"')
     to the `gettext' library, by calling the `textdomain()' function.

  3. Messages from the application are extracted from the source code
     and collected into a portable object template file (`guide.pot'),
     which lists the strings and their translations.  The translations
     are initially empty.  The original (usually English) messages
     serve as the key for lookup of the translations.

  4. For each language with a translator, `guide.pot' is copied to a
     portable object file (`.po') and translations are created and
     shipped with the application.  For example, there might be a
     `fr.po' for a French translation.

  5. Each language's `.po' file is converted into a binary message
     object (`.mo') file.  A message object file contains the original
     messages and their translations in a binary format that allows
     fast lookup of translations at runtime.

  6. When `guide' is built and installed, the binary translation files
     are installed in a standard place.

  7. For testing and development, it is possible to tell `gettext' to
     use `.mo' files in a different directory than the standard one by
     using the `bindtextdomain()' function.

  8. At runtime, `guide' looks up each string via a call to
     `gettext()'.  The returned string is the translated string if
     available, or the original string if not.

  9. If necessary, it is possible to access messages from a different
     text domain than the one belonging to the application, without
     having to switch the application's default text domain back and
     forth.

   In C (or C++), the string marking and dynamic translation lookup are
accomplished by wrapping each string in a call to `gettext()':

     printf("%s", gettext("Don't Panic!\n"));

   The tools that extract messages from source code pull out all
strings enclosed in calls to `gettext()'.

   The GNU `gettext' developers, recognizing that typing `gettext(...)'
over and over again is both painful and ugly to look at, use the macro
`_' (an underscore) to make things easier:

     /* In the standard header file: */
     #define _(str) gettext(str)

     /* In the program text: */
     printf("%s", _("Don't Panic!\n"));

This reduces the typing overhead to just three extra characters per
string and is considerably easier to read as well.

   There are locale "categories" for different types of locale-related
information.  The defined locale categories that `gettext' knows about
are:

`LC_MESSAGES'
     Text messages.  This is the default category for `gettext'
     operations, but it is possible to supply a different one
     explicitly, if necessary.  (It is almost never necessary to supply
     a different category.)

`LC_COLLATE'
     Text-collation information; i.e., how different characters and/or
     groups of characters sort in a given language.

`LC_CTYPE'
     Character-type information (alphabetic, digit, upper- or
     lowercase, and so on).  This information is accessed via the POSIX
     character classes in regular expressions, such as `/[[:alnum:]]/'
     (*note Regexp Operators::).

`LC_MONETARY'
     Monetary information, such as the currency symbol, and whether the
     symbol goes before or after a number.

`LC_NUMERIC'
     Numeric information, such as which characters to use for the
     decimal point and the thousands separator.(2)

`LC_RESPONSE'
     Response information, such as how "yes" and "no" appear in the
     local language, and possibly other information as well.

`LC_TIME'
     Time- and date-related information, such as 12- or 24-hour clock,
     month printed before or after the day in a date, local month
     abbreviations, and so on.

`LC_ALL'
     All of the above.  (Not too useful in the context of `gettext'.)

   ---------- Footnotes ----------

   (1) For some operating systems, the `gawk' port doesn't support GNU
`gettext'.  Therefore, these features are not available if you are
using one of those operating systems. Sorry.

   (2) Americans use a comma every three decimal places and a period
for the decimal point, while many Europeans do exactly the opposite:
1,234.56 versus 1.234,56.


File: gawk.info,  Node: Programmer i18n,  Next: Translator i18n,  Prev: Explaining gettext,  Up: Internationalization

10.3 Internationalizing `awk' Programs
======================================

`gawk' provides the following variables and functions for
internationalization:

`TEXTDOMAIN'
     This variable indicates the application's text domain.  For
     compatibility with GNU `gettext', the default value is
     `"messages"'.

`_"your message here"'
     String constants marked with a leading underscore are candidates
     for translation at runtime.  String constants without a leading
     underscore are not translated.

`dcgettext(STRING [, DOMAIN [, CATEGORY]])'
     Return the translation of STRING in text domain DOMAIN for locale
     category CATEGORY.  The default value for DOMAIN is the current
     value of `TEXTDOMAIN'.  The default value for CATEGORY is
     `"LC_MESSAGES"'.

     If you supply a value for CATEGORY, it must be a string equal to
     one of the known locale categories described in *note Explaining
     gettext::.  You must also supply a text domain.  Use `TEXTDOMAIN'
     if you want to use the current domain.

          CAUTION: The order of arguments to the `awk' version of the
          `dcgettext()' function is purposely different from the order
          for the C version.  The `awk' version's order was chosen to
          be simple and to allow for reasonable `awk'-style default
          arguments.

`dcngettext(STRING1, STRING2, NUMBER [, DOMAIN [, CATEGORY]])'
     Return the plural form used for NUMBER of the translation of
     STRING1 and STRING2 in text domain DOMAIN for locale category
     CATEGORY. STRING1 is the English singular variant of a message,
     and STRING2 the English plural variant of the same message.  The
     default value for DOMAIN is the current value of `TEXTDOMAIN'.
     The default value for CATEGORY is `"LC_MESSAGES"'.

     The same remarks about argument order as for the `dcgettext()'
     function apply.

`bindtextdomain(DIRECTORY [, DOMAIN])'
     Change the directory in which `gettext' looks for `.mo' files, in
     case they will not or cannot be placed in the standard locations
     (e.g., during testing).  Return the directory in which DOMAIN is
     "bound."

     The default DOMAIN is the value of `TEXTDOMAIN'.  If DIRECTORY is
     the null string (`""'), then `bindtextdomain()' returns the
     current binding for the given DOMAIN.

   To use these facilities in your `awk' program, follow the steps
outlined in *note Explaining gettext::, like so:

  1. Set the variable `TEXTDOMAIN' to the text domain of your program.
     This is best done in a `BEGIN' rule (*note BEGIN/END::), or it can
     also be done via the `-v' command-line option (*note Options::):

          BEGIN {
              TEXTDOMAIN = "guide"
              ...
          }

  2. Mark all translatable strings with a leading underscore (`_')
     character.  It _must_ be adjacent to the opening quote of the
     string.  For example:

          print _"hello, world"
          x = _"you goofed"
          printf(_"Number of users is %d\n", nusers)

  3. If you are creating strings dynamically, you can still translate
     them, using the `dcgettext()' built-in function:

          message = nusers " users logged in"
          message = dcgettext(message, "adminprog")
          print message

     Here, the call to `dcgettext()' supplies a different text domain
     (`"adminprog"') in which to find the message, but it uses the
     default `"LC_MESSAGES"' category.

  4. During development, you might want to put the `.mo' file in a
     private directory for testing.  This is done with the
     `bindtextdomain()' built-in function:

          BEGIN {
             TEXTDOMAIN = "guide"   # our text domain
             if (Testing) {
                 # where to find our files
                 bindtextdomain("testdir")
                 # joe is in charge of adminprog
                 bindtextdomain("../joe/testdir", "adminprog")
             }
             ...
          }


   *Note I18N Example::, for an example program showing the steps to
create and use translations from `awk'.


File: gawk.info,  Node: Translator i18n,  Next: I18N Example,  Prev: Programmer i18n,  Up: Internationalization

10.4 Translating `awk' Programs
===============================

Once a program's translatable strings have been marked, they must be
extracted to create the initial `.po' file.  As part of translation, it
is often helpful to rearrange the order in which arguments to `printf'
are output.

   `gawk''s `--gen-pot' command-line option extracts the messages and
is discussed next.  After that, `printf''s ability to rearrange the
order for `printf' arguments at runtime is covered.

* Menu:

* String Extraction::           Extracting marked strings.
* Printf Ordering::             Rearranging `printf' arguments.
* I18N Portability::            `awk'-level portability issues.


File: gawk.info,  Node: String Extraction,  Next: Printf Ordering,  Up: Translator i18n

10.4.1 Extracting Marked Strings
--------------------------------

Once your `awk' program is working, and all the strings have been
marked and you've set (and perhaps bound) the text domain, it is time
to produce translations.  First, use the `--gen-pot' command-line
option to create the initial `.pot' file:

     $ gawk --gen-pot -f guide.awk > guide.pot

   When run with `--gen-pot', `gawk' does not execute your program.
Instead, it parses it as usual and prints all marked strings to
standard output in the format of a GNU `gettext' Portable Object file.
Also included in the output are any constant strings that appear as the
first argument to `dcgettext()' or as the first and second argument to
`dcngettext()'.(1) *Note I18N Example::, for the full list of steps to
go through to create and test translations for `guide'.

   ---------- Footnotes ----------

   (1) The `xgettext' utility that comes with GNU `gettext' can handle
`.awk' files.


File: gawk.info,  Node: Printf Ordering,  Next: I18N Portability,  Prev: String Extraction,  Up: Translator i18n

10.4.2 Rearranging `printf' Arguments
-------------------------------------

Format strings for `printf' and `sprintf()' (*note Printf::) present a
special problem for translation.  Consider the following:(1)

     printf(_"String `%s' has %d characters\n",
               string, length(string)))

   A possible German translation for this might be:

     "%d Zeichen lang ist die Zeichenkette `%s'\n"

   The problem should be obvious: the order of the format
specifications is different from the original!  Even though `gettext()'
can return the translated string at runtime, it cannot change the
argument order in the call to `printf'.

   To solve this problem, `printf' format specifiers may have an
additional optional element, which we call a "positional specifier".
For example:

     "%2$d Zeichen lang ist die Zeichenkette `%1$s'\n"

   Here, the positional specifier consists of an integer count, which
indicates which argument to use, and a `$'. Counts are one-based, and
the format string itself is _not_ included.  Thus, in the following
example, `string' is the first argument and `length(string)' is the
second:

     $ gawk 'BEGIN {
     >     string = "Dont Panic"
     >     printf _"%2$d characters live in \"%1$s\"\n",
     >                         string, length(string)
     > }'
     -| 10 characters live in "Dont Panic"

   If present, positional specifiers come first in the format
specification, before the flags, the field width, and/or the precision.

   Positional specifiers can be used with the dynamic field width and
precision capability:

     $ gawk 'BEGIN {
     >    printf("%*.*s\n", 10, 20, "hello")
     >    printf("%3$*2$.*1$s\n", 20, 10, "hello")
     > }'
     -|      hello
     -|      hello

     NOTE: When using `*' with a positional specifier, the `*' comes
     first, then the integer position, and then the `$'.  This is
     somewhat counterintuitive.

   `gawk' does not allow you to mix regular format specifiers and those
with positional specifiers in the same string:

     $ gawk 'BEGIN { printf _"%d %3$s\n", 1, 2, "hi" }'
     error--> gawk: cmd. line:1: fatal: must use `count$' on all formats or none

     NOTE: There are some pathological cases that `gawk' may fail to
     diagnose.  In such cases, the output may not be what you expect.
     It's still a bad idea to try mixing them, even if `gawk' doesn't
     detect it.

   Although positional specifiers can be used directly in `awk'
programs, their primary purpose is to help in producing correct
translations of format strings into languages different from the one in
which the program is first written.

   ---------- Footnotes ----------

   (1) This example is borrowed from the GNU `gettext' manual.


File: gawk.info,  Node: I18N Portability,  Prev: Printf Ordering,  Up: Translator i18n

10.4.3 `awk' Portability Issues
-------------------------------

`gawk''s internationalization features were purposely chosen to have as
little impact as possible on the portability of `awk' programs that use
them to other versions of `awk'.  Consider this program:

     BEGIN {
         TEXTDOMAIN = "guide"
         if (Test_Guide)   # set with -v
             bindtextdomain("/test/guide/messages")
         print _"don't panic!"
     }

As written, it won't work on other versions of `awk'.  However, it is
actually almost portable, requiring very little change:

   * Assignments to `TEXTDOMAIN' won't have any effect, since
     `TEXTDOMAIN' is not special in other `awk' implementations.

   * Non-GNU versions of `awk' treat marked strings as the
     concatenation of a variable named `_' with the string following
     it.(1) Typically, the variable `_' has the null string (`""') as
     its value, leaving the original string constant as the result.

   * By defining "dummy" functions to replace `dcgettext()',
     `dcngettext()' and `bindtextdomain()', the `awk' program can be
     made to run, but all the messages are output in the original
     language.  For example:

          function bindtextdomain(dir, domain)
          {
              return dir
          }

          function dcgettext(string, domain, category)
          {
              return string
          }

          function dcngettext(string1, string2, number, domain, category)
          {
              return (number == 1 ? string1 : string2)
          }

   * The use of positional specifications in `printf' or `sprintf()' is
     _not_ portable.  To support `gettext()' at the C level, many
     systems' C versions of `sprintf()' do support positional
     specifiers.  But it works only if enough arguments are supplied in
     the function call.  Many versions of `awk' pass `printf' formats
     and arguments unchanged to the underlying C library version of
     `sprintf()', but only one format and argument at a time.  What
     happens if a positional specification is used is anybody's guess.
     However, since the positional specifications are primarily for use
     in _translated_ format strings, and since non-GNU `awk's never
     retrieve the translated string, this should not be a problem in
     practice.

   ---------- Footnotes ----------

   (1) This is good fodder for an "Obfuscated `awk'" contest.


File: gawk.info,  Node: I18N Example,  Next: Gawk I18N,  Prev: Translator i18n,  Up: Internationalization

10.5 A Simple Internationalization Example
==========================================

Now let's look at a step-by-step example of how to internationalize and
localize a simple `awk' program, using `guide.awk' as our original
source:

     BEGIN {
         TEXTDOMAIN = "guide"
         bindtextdomain(".")  # for testing
         print _"Don't Panic"
         print _"The Answer Is", 42
         print "Pardon me, Zaphod who?"
     }

Run `gawk --gen-pot' to create the `.pot' file:

     $ gawk --gen-pot -f guide.awk > guide.pot

This produces:

     #: guide.awk:4
     msgid "Don't Panic"
     msgstr ""

     #: guide.awk:5
     msgid "The Answer Is"
     msgstr ""

   This original portable object template file is saved and reused for
each language into which the application is translated.  The `msgid' is
the original string and the `msgstr' is the translation.

     NOTE: Strings not marked with a leading underscore do not appear
     in the `guide.pot' file.

   Next, the messages must be translated.  Here is a translation to a
hypothetical dialect of English, called "Mellow":(1)

     $ cp guide.pot guide-mellow.po
     ADD TRANSLATIONS TO guide-mellow.po ...

Following are the translations:

     #: guide.awk:4
     msgid "Don't Panic"
     msgstr "Hey man, relax!"

     #: guide.awk:5
     msgid "The Answer Is"
     msgstr "Like, the scoop is"

   The next step is to make the directory to hold the binary message
object file and then to create the `guide.mo' file.  The directory
layout shown here is standard for GNU `gettext' on GNU/Linux systems.
Other versions of `gettext' may use a different layout:

     $ mkdir en_US en_US/LC_MESSAGES

   The `msgfmt' utility does the conversion from human-readable `.po'
file to machine-readable `.mo' file.  By default, `msgfmt' creates a
file named `messages'.  This file must be renamed and placed in the
proper directory so that `gawk' can find it:

     $ msgfmt guide-mellow.po
     $ mv messages en_US/LC_MESSAGES/guide.mo

   Finally, we run the program to test it:

     $ gawk -f guide.awk
     -| Hey man, relax!
     -| Like, the scoop is 42
     -| Pardon me, Zaphod who?

   If the three replacement functions for `dcgettext()', `dcngettext()'
and `bindtextdomain()' (*note I18N Portability::) are in a file named
`libintl.awk', then we can run `guide.awk' unchanged as follows:

     $ gawk --posix -f guide.awk -f libintl.awk
     -| Don't Panic
     -| The Answer Is 42
     -| Pardon me, Zaphod who?

   ---------- Footnotes ----------

   (1) Perhaps it would be better if it were called "Hippy." Ah, well.


File: gawk.info,  Node: Gawk I18N,  Prev: I18N Example,  Up: Internationalization

10.6 `gawk' Can Speak Your Language
===================================

`gawk' itself has been internationalized using the GNU `gettext'
package.  (GNU `gettext' is described in complete detail in *note (GNU
`gettext' utilities)Top:: gettext, GNU gettext tools.)  As of this
writing, the latest version of GNU `gettext' is version 0.18.1
(ftp://ftp.gnu.org/gnu/gettext/gettext-0.18.1.tar.gz).

   If a translation of `gawk''s messages exists, then `gawk' produces
usage messages, warnings, and fatal errors in the local language.


File: gawk.info,  Node: Advanced Features,  Next: Library Functions,  Prev: Internationalization,  Up: Top

11 Advanced Features of `gawk'
******************************

     Write documentation as if whoever reads it is a violent psychopath
     who knows where you live.
     Steve English, as quoted by Peter Langston

   This major node discusses advanced features in `gawk'.  It's a bit
of a "grab bag" of items that are otherwise unrelated to each other.
First, a command-line option allows `gawk' to recognize nondecimal
numbers in input data, not just in `awk' programs.  Then, `gawk''s
special features for sorting arrays are presented.  Next, two-way I/O,
discussed briefly in earlier parts of this Info file, is described in
full detail, along with the basics of TCP/IP networking.  Finally,
`gawk' can "profile" an `awk' program, making it possible to tune it
for performance.

   *note Dynamic Extensions::, discusses the ability to dynamically add
new built-in functions to `gawk'.  As this feature is still immature
and likely to change, its description is relegated to an appendix.

* Menu:

* Nondecimal Data::             Allowing nondecimal input data.
* Array Sorting::               Facilities for controlling array traversal and
                                sorting arrays.
* Two-way I/O::                 Two-way communications with another process.
* TCP/IP Networking::           Using `gawk' for network programming.
* Profiling::                   Profiling your `awk' programs.


File: gawk.info,  Node: Nondecimal Data,  Next: Array Sorting,  Up: Advanced Features

11.1 Allowing Nondecimal Input Data
===================================

If you run `gawk' with the `--non-decimal-data' option, you can have
nondecimal constants in your input data:

     $ echo 0123 123 0x123 |
     > gawk --non-decimal-data '{ printf "%d, %d, %d\n",
     >                                         $1, $2, $3 }'
     -| 83, 123, 291

   For this feature to work, write your program so that `gawk' treats
your data as numeric:

     $ echo 0123 123 0x123 | gawk '{ print $1, $2, $3 }'
     -| 0123 123 0x123

The `print' statement treats its expressions as strings.  Although the
fields can act as numbers when necessary, they are still strings, so
`print' does not try to treat them numerically.  You may need to add
zero to a field to force it to be treated as a number.  For example:

     $ echo 0123 123 0x123 | gawk --non-decimal-data '
     > { print $1, $2, $3
     >   print $1 + 0, $2 + 0, $3 + 0 }'
     -| 0123 123 0x123
     -| 83 123 291

   Because it is common to have decimal data with leading zeros, and
because using this facility could lead to surprising results, the
default is to leave it disabled.  If you want it, you must explicitly
request it.

     CAUTION: _Use of this option is not recommended._ It can break old
     programs very badly.  Instead, use the `strtonum()' function to
     convert your data (*note Nondecimal-numbers::).  This makes your
     programs easier to write and easier to read, and leads to less
     surprising results.


File: gawk.info,  Node: Array Sorting,  Next: Two-way I/O,  Prev: Nondecimal Data,  Up: Advanced Features

11.2 Controlling Array Traversal and Array Sorting
==================================================

`gawk' lets you control the order in which `for (i in array)' loops
will traverse an array.

   In addition, two built-in functions, `asort()' and `asorti()', let
you sort arrays based on the array values and indices, respectively.
These two functions also provide control over the sorting criteria used
to order the elements during sorting.

* Menu:

* Controlling Array Traversal:: How to use PROCINFO["sorted_in"].
* Array Sorting Functions::     How to use `asort()' and `asorti()'.


File: gawk.info,  Node: Controlling Array Traversal,  Next: Array Sorting Functions,  Up: Array Sorting

11.2.1 Controlling Array Traversal
----------------------------------

By default, the order in which a `for (i in array)' loop scans an array
is not defined; it is generally based upon the internal implementation
of arrays inside `awk'.

   Often, though, it is desirable to be able to loop over the elements
in a particular order that you, the programmer, choose.  `gawk' lets
you do this; this node describes how.

* Menu:

* Controlling Scanning With A Function:: Using a function to control scanning.
* Controlling Scanning::                 Controlling the order in which arrays
                                         are scanned.


File: gawk.info,  Node: Controlling Scanning With A Function,  Next: Controlling Scanning,  Up: Controlling Array Traversal

11.2.1.1 Array Scanning Using A User-defined Function
.....................................................

The value of `PROCINFO["sorted_in"]' can be a function name.  This lets
you traverse an array based on any custom criterion.  The array
elements are ordered according to the return value of this function.
The comparison function should be defined with at least four arguments:

     function comp_func(i1, v1, i2, v2)
     {
         COMPARE ELEMENTS 1 AND 2 IN SOME FASHION
         RETURN < 0; 0; OR > 0
     }

   Here, I1 and I2 are the indices, and V1 and V2 are the corresponding
values of the two elements being compared.  Either V1 or V2, or both,
can be arrays if the array being traversed contains subarrays as
values.  The three possible return values are interpreted this way:

`comp_func(i1, v1, i2, v2) < 0'
     Index I1 comes before index I2 during loop traversal.

`comp_func(i1, v1, i2, v2) == 0'
     Indices I1 and I2 come together but the relative order with
     respect to each other is undefined.

`comp_func(i1, v1, i2, v2) > 0'
     Index I1 comes after index I2 during loop traversal.

   Our first comparison function can be used to scan an array in
numerical order of the indices:

     function cmp_num_idx(i1, v1, i2, v2)
     {
          # numerical index comparison, ascending order
          return (i1 - i2)
     }

   Our second function traverses an array based on the string order of
the element values rather than by indices:

     function cmp_str_val(i1, v1, i2, v2)
     {
         # string value comparison, ascending order
         v1 = v1 ""
         v2 = v2 ""
         if (v1 < v2)
             return -1
         return (v1 != v2)
     }

   The third comparison function makes all numbers, and numeric strings
without any leading or trailing spaces, come out first during loop
traversal:

     function cmp_num_str_val(i1, v1, i2, v2,   n1, n2)
     {
          # numbers before string value comparison, ascending order
          n1 = v1 + 0
          n2 = v2 + 0
          if (n1 == v1)
              return (n2 == v2) ? (n1 - n2) : -1
          else if (n2 == v2)
              return 1
          return (v1 < v2) ? -1 : (v1 != v2)
     }

   Here is a main program to demonstrate how `gawk' behaves using each
of the previous functions:

     BEGIN {
         data["one"] = 10
         data["two"] = 20
         data[10] = "one"
         data[100] = 100
         data[20] = "two"

         f[1] = "cmp_num_idx"
         f[2] = "cmp_str_val"
         f[3] = "cmp_num_str_val"
         for (i = 1; i <= 3; i++) {
             printf("Sort function: %s\n", f[i])
             PROCINFO["sorted_in"] = f[i]
             for (j in data)
                 printf("\tdata[%s] = %s\n", j, data[j])
             print ""
         }
     }

   Here are the results when the program is run:

     $ gawk -f compdemo.awk
     -| Sort function: cmp_num_idx      Sort by numeric index
     -|     data[two] = 20
     -|     data[one] = 10              Both strings are numerically zero
     -|     data[10] = one
     -|     data[20] = two
     -|     data[100] = 100
     -|
     -| Sort function: cmp_str_val      Sort by element values as strings
     -|     data[one] = 10
     -|     data[100] = 100             String 100 is less than string 20
     -|     data[two] = 20
     -|     data[10] = one
     -|     data[20] = two
     -|
     -| Sort function: cmp_num_str_val  Sort all numbers before all strings
     -|     data[one] = 10
     -|     data[two] = 20
     -|     data[100] = 100
     -|     data[10] = one
     -|     data[20] = two

   Consider sorting the entries of a GNU/Linux system password file
according to login names.  The following program sorts records by a
specific field position and can be used for this purpose:

     # sort.awk --- simple program to sort by field position
     # field position is specified by the global variable POS

     function cmp_field(i1, v1, i2, v2)
     {
         # comparison by value, as string, and ascending order
         return v1[POS] < v2[POS] ? -1 : (v1[POS] != v2[POS])
     }

     {
         for (i = 1; i <= NF; i++)
             a[NR][i] = $i
     }

     END {
         PROCINFO["sorted_in"] = "cmp_field"
         if (POS < 1 || POS > NF)
             POS = 1
         for (i in a) {
             for (j = 1; j <= NF; j++)
                 printf("%s%c", a[i][j], j < NF ? ":" : "")
             print ""
         }
     }

   The first field in each entry of the password file is the user's
login name, and the fields are seperated by colons.  Each record
defines a subarray (*note Arrays of Arrays::), with each field as an
element in the subarray.  Running the program produces the following
output:

     $ gawk -vPOS=1 -F: -f sort.awk /etc/passwd
     -| adm:x:3:4:adm:/var/adm:/sbin/nologin
     -| apache:x:48:48:Apache:/var/www:/sbin/nologin
     -| avahi:x:70:70:Avahi daemon:/:/sbin/nologin
     ...

   The comparison should normally always return the same value when
given a specific pair of array elements as its arguments.  If
inconsistent results are returned then the order is undefined.  This
behavior can be exploited to introduce random order into otherwise
seemingly ordered data:

     function cmp_randomize(i1, v1, i2, v2)
     {
         # random order
         return (2 - 4 * rand())
     }

   As mentioned above, the order of the indices is arbitrary if two
elements compare equal.  This is usually not a problem, but letting the
tied elements come out in arbitrary order can be an issue, especially
when comparing item values.  The partial ordering of the equal elements
may change during the next loop traversal, if other elements are added
or removed from the array.  One way to resolve ties when comparing
elements with otherwise equal values is to include the indices in the
comparison rules.  Note that doing this may make the loop traversal
less efficient, so consider it only if necessary.  The following
comparison functions force a deterministic order, and are based on the
fact that the indices of two elements are never equal:

     function cmp_numeric(i1, v1, i2, v2)
     {
         # numerical value (and index) comparison, descending order
         return (v1 != v2) ? (v2 - v1) : (i2 - i1)
     }

     function cmp_string(i1, v1, i2, v2)
     {
         # string value (and index) comparison, descending order
         v1 = v1 i1
         v2 = v2 i2
         return (v1 > v2) ? -1 : (v1 != v2)
     }

   A custom comparison function can often simplify ordered loop
traversal, and the sky is really the limit when it comes to designing
such a function.

   When string comparisons are made during a sort, either for element
values where one or both aren't numbers, or for element indices handled
as strings, the value of `IGNORECASE' (*note Built-in Variables::)
controls whether the comparisons treat corresponding uppercase and
lowercase letters as equivalent or distinct.

   Another point to keep in mind is that in the case of subarrays the
element values can themselves be arrays; a production comparison
function should use the `isarray()' function (*note Type Functions::),
to check for this, and choose a defined sorting order for subarrays.

   All sorting based on `PROCINFO["sorted_in"]' is disabled in POSIX
mode, since the `PROCINFO' array is not special in that case.

   As a side note, sorting the array indices before traversing the
array has been reported to add 15% to 20% overhead to the execution
time of `awk' programs. For this reason, sorted array traversal is not
the default.


File: gawk.info,  Node: Controlling Scanning,  Prev: Controlling Scanning With A Function,  Up: Controlling Array Traversal

11.2.1.2 Controlling Array Scanning Order
.........................................

As described in *note Controlling Scanning With A Function::, you can
provide the name of a function as the value of `PROCINFO["sorted_in"]'
to specify custom sorting criteria.

   Often, though, you may wish to do something simple, such as "sort
based on comparing the indices in ascending order," or "sort based on
comparing the values in descending order."  Having to write a simple
comparison function for this purpose for use in all of your programs
becomes tedious.  For the common simple cases, `gawk' provides the
option of supplying special names that do the requested sorting for you.
You can think of them as "predefined" sorting functions, if you like,
although the names purposely include characters that are not valid in
real `awk' function names.

   The following special values are available:

`"@ind_str_asc"'
     Order by indices compared as strings; this is the most basic sort.
     (Internally, array indices are always strings, so with `a[2*5] = 1'
     the index is `"10"' rather than numeric 10.)

`"@ind_num_asc"'
     Order by indices but force them to be treated as numbers in the
     process.  Any index with a non-numeric value will end up
     positioned as if it were zero.

`"@val_type_asc"'
     Order by element values rather than indices.  Ordering is by the
     type assigned to the element (*note Typing and Comparison::).  All
     numeric values come before all string values, which in turn come
     before all subarrays.

`"@val_str_asc"'
     Order by element values rather than by indices.  Scalar values are
     compared as strings.  Subarrays, if present, come out last.

`"@val_num_asc"'
     Order by element values rather than by indices.  Scalar values are
     compared as numbers.  Subarrays, if present, come out last.  When
     numeric values are equal, the string values are used to provide an
     ordering: this guarantees consistent results across different
     versions of the C `qsort()' function.(1)

`"@ind_str_desc"'
     Reverse order from the most basic sort.

`"@ind_num_desc"'
     Numeric indices ordered from high to low.

`"@val_type_desc"'
     Element values, based on type, in descending order.

`"@val_str_desc"'
     Element values, treated as strings, ordered from high to low.
     Subarrays, if present, come out first.

`"@val_num_desc"'
     Element values, treated as numbers, ordered from high to low.
     Subarrays, if present, come out first.

`"@unsorted"'
     Array elements are processed in arbitrary order, which is the
     normal `awk' behavior. You can also get the normal behavior by just
     deleting the `"sorted_in"' element from the `PROCINFO' array, if
     it previously had a value assigned to it.

   The array traversal order is determined before the `for' loop starts
to run. Changing `PROCINFO["sorted_in"]' in the loop body will not
affect the loop.

   For example:

     $ gawk 'BEGIN {
     >    a[4] = 4
     >    a[3] = 3
     >    for (i in a)
     >        print i, a[i]
     > }'
     -| 4 4
     -| 3 3
     $ gawk 'BEGIN {
     >    PROCINFO["sorted_in"] = "@str_ind_asc"
     >    a[4] = 4
     >    a[3] = 3
     >    for (i in a)
     >        print i, a[i]
     > }'
     -| 3 3
     -| 4 4

   When sorting an array by element values, if a value happens to be a
subarray then it is considered to be greater than any string or numeric
value, regardless of what the subarray itself contains, and all
subarrays are treated as being equal to each other.  Their order
relative to each other is determined by their index strings.

   ---------- Footnotes ----------

   (1) When two elements compare as equal, the C `qsort()' function
does not guarantee that they will maintain their original relative
order after sorting.  Using the string value to provide a unique
ordering when the numeric values are equal ensures that `gawk' behaves
consistently across different environments.


File: gawk.info,  Node: Array Sorting Functions,  Prev: Controlling Array Traversal,  Up: Array Sorting

11.2.2 Sorting Array Values and Indices with `gawk'
---------------------------------------------------

In most `awk' implementations, sorting an array requires writing a
`sort' function.  While this can be educational for exploring different
sorting algorithms, usually that's not the point of the program.
`gawk' provides the built-in `asort()' and `asorti()' functions (*note
String Functions::) for sorting arrays.  For example:

     POPULATE THE ARRAY data
     n = asort(data)
     for (i = 1; i <= n; i++)
         DO SOMETHING WITH data[i]

   After the call to `asort()', the array `data' is indexed from 1 to
some number N, the total number of elements in `data'.  (This count is
`asort()''s return value.)  `data[1]' <= `data[2]' <= `data[3]', and so
on.  The array elements are compared as strings.

   An important side effect of calling `asort()' is that _the array's
original indices are irrevocably lost_.  As this isn't always
desirable, `asort()' accepts a second argument:

     POPULATE THE ARRAY source
     n = asort(source, dest)
     for (i = 1; i <= n; i++)
         DO SOMETHING WITH dest[i]

   In this case, `gawk' copies the `source' array into the `dest' array
and then sorts `dest', destroying its indices.  However, the `source'
array is not affected.

   `asort()' accepts a third string argument to control comparison of
array elements.  As with `PROCINFO["sorted_in"]', this argument may be
the name of a user-defined function, or one of the predefined names
that `gawk' provides (*note Controlling Scanning With A Function::).

     NOTE: In all cases, the sorted element values consist of the
     original array's element values.  The ability to control
     comparison merely affects the way in which they are sorted.

   Often, what's needed is to sort on the values of the _indices_
instead of the values of the elements.  To do that, use the `asorti()'
function.  The interface is identical to that of `asort()', except that
the index values are used for sorting, and become the values of the
result array:

     { source[$0] = some_func($0) }

     END {
         n = asorti(source, dest)
         for (i = 1; i <= n; i++) {
             Work with sorted indices directly:
             DO SOMETHING WITH dest[i]
             ...
             Access original array via sorted indices:
             DO SOMETHING WITH source[dest[i]]
         }
     }

   Similar to `asort()', in all cases, the sorted element values
consist of the original array's indices.  The ability to control
comparison merely affects the way in which they are sorted.

   Sorting the array by replacing the indices provides maximal
flexibility.  To traverse the elements in decreasing order, use a loop
that goes from N down to 1, either over the elements or over the
indices.(1)

   Copying array indices and elements isn't expensive in terms of
memory.  Internally, `gawk' maintains "reference counts" to data.  For
example, when `asort()' copies the first array to the second one, there
is only one copy of the original array elements' data, even though both
arrays use the values.

   Because `IGNORECASE' affects string comparisons, the value of
`IGNORECASE' also affects sorting for both `asort()' and `asorti()'.
Note also that the locale's sorting order does _not_ come into play;
comparisons are based on character values only.(2) Caveat Emptor.

   ---------- Footnotes ----------

   (1) You may also use one of the predefined sorting names that sorts
in decreasing order.

   (2) This is true because locale-based comparison occurs only when in
POSIX compatibility mode, and since `asort()' and `asorti()' are `gawk'
extensions, they are not available in that case.


File: gawk.info,  Node: Two-way I/O,  Next: TCP/IP Networking,  Prev: Array Sorting,  Up: Advanced Features

11.3 Two-Way Communications with Another Process
================================================

     From: brennan@whidbey.com (Mike Brennan)
     Newsgroups: comp.lang.awk
     Subject: Re: Learn the SECRET to Attract Women Easily
     Date: 4 Aug 1997 17:34:46 GMT
     Message-ID: <5s53rm$eca@news.whidbey.com>

     On 3 Aug 1997 13:17:43 GMT, Want More Dates???
     <tracy78@kilgrona.com> wrote:
     >Learn the SECRET to Attract Women Easily
     >
     >The SCENT(tm)  Pheromone Sex Attractant For Men to Attract Women

     The scent of awk programmers is a lot more attractive to women than
     the scent of perl programmers.
     --
     Mike Brennan

   It is often useful to be able to send data to a separate program for
processing and then read the result.  This can always be done with
temporary files:

     # Write the data for processing
     tempfile = ("mydata." PROCINFO["pid"])
     while (NOT DONE WITH DATA)
         print DATA | ("subprogram > " tempfile)
     close("subprogram > " tempfile)

     # Read the results, remove tempfile when done
     while ((getline newdata < tempfile) > 0)
         PROCESS newdata APPROPRIATELY
     close(tempfile)
     system("rm " tempfile)

This works, but not elegantly.  Among other things, it requires that
the program be run in a directory that cannot be shared among users;
for example, `/tmp' will not do, as another user might happen to be
using a temporary file with the same name.

   However, with `gawk', it is possible to open a _two-way_ pipe to
another process.  The second process is termed a "coprocess", since it
runs in parallel with `gawk'.  The two-way connection is created using
the `|&' operator (borrowed from the Korn shell, `ksh'):(1)

     do {
         print DATA |& "subprogram"
         "subprogram" |& getline results
     } while (DATA LEFT TO PROCESS)
     close("subprogram")

   The first time an I/O operation is executed using the `|&' operator,
`gawk' creates a two-way pipeline to a child process that runs the
other program.  Output created with `print' or `printf' is written to
the program's standard input, and output from the program's standard
output can be read by the `gawk' program using `getline'.  As is the
case with processes started by `|', the subprogram can be any program,
or pipeline of programs, that can be started by the shell.

   There are some cautionary items to be aware of:

   * As the code inside `gawk' currently stands, the coprocess's
     standard error goes to the same place that the parent `gawk''s
     standard error goes. It is not possible to read the child's
     standard error separately.

   * I/O buffering may be a problem.  `gawk' automatically flushes all
     output down the pipe to the coprocess.  However, if the coprocess
     does not flush its output, `gawk' may hang when doing a `getline'
     in order to read the coprocess's results.  This could lead to a
     situation known as "deadlock", where each process is waiting for
     the other one to do something.

   It is possible to close just one end of the two-way pipe to a
coprocess, by supplying a second argument to the `close()' function of
either `"to"' or `"from"' (*note Close Files And Pipes::).  These
strings tell `gawk' to close the end of the pipe that sends data to the
coprocess or the end that reads from it, respectively.

   This is particularly necessary in order to use the system `sort'
utility as part of a coprocess; `sort' must read _all_ of its input
data before it can produce any output.  The `sort' program does not
receive an end-of-file indication until `gawk' closes the write end of
the pipe.

   When you have finished writing data to the `sort' utility, you can
close the `"to"' end of the pipe, and then start reading sorted data
via `getline'.  For example:

     BEGIN {
         command = "LC_ALL=C sort"
         n = split("abcdefghijklmnopqrstuvwxyz", a, "")

         for (i = n; i > 0; i--)
             print a[i] |& command
         close(command, "to")

         while ((command |& getline line) > 0)
             print "got", line
         close(command)
     }

   This program writes the letters of the alphabet in reverse order, one
per line, down the two-way pipe to `sort'.  It then closes the write
end of the pipe, so that `sort' receives an end-of-file indication.
This causes `sort' to sort the data and write the sorted data back to
the `gawk' program.  Once all of the data has been read, `gawk'
terminates the coprocess and exits.

   As a side note, the assignment `LC_ALL=C' in the `sort' command
ensures traditional Unix (ASCII) sorting from `sort'.

   You may also use pseudo-ttys (ptys) for two-way communication
instead of pipes, if your system supports them.  This is done on a
per-command basis, by setting a special element in the `PROCINFO' array
(*note Auto-set::), like so:

     command = "sort -nr"           # command, save in convenience variable
     PROCINFO[command, "pty"] = 1   # update PROCINFO
     print ... |& command       # start two-way pipe
     ...

Using ptys avoids the buffer deadlock issues described earlier, at some
loss in performance.  If your system does not have ptys, or if all the
system's ptys are in use, `gawk' automatically falls back to using
regular pipes.

   ---------- Footnotes ----------

   (1) This is very different from the same operator in the C shell.


File: gawk.info,  Node: TCP/IP Networking,  Next: Profiling,  Prev: Two-way I/O,  Up: Advanced Features

11.4 Using `gawk' for Network Programming
=========================================

     `EMISTERED':
     A host is a host from coast to coast,
     and no-one can talk to host that's close,
     unless the host that isn't close
     is busy hung or dead.

   In addition to being able to open a two-way pipeline to a coprocess
on the same system (*note Two-way I/O::), it is possible to make a
two-way connection to another process on another system across an IP
network connection.

   You can think of this as just a _very long_ two-way pipeline to a
coprocess.  The way `gawk' decides that you want to use TCP/IP
networking is by recognizing special file names that begin with one of
`/inet/', `/inet4/' or `/inet6'.

   The full syntax of the special file name is
`/NET-TYPE/PROTOCOL/LOCAL-PORT/REMOTE-HOST/REMOTE-PORT'.  The
components are:

NET-TYPE
     Specifies the kind of Internet connection to make.  Use `/inet4/'
     to force IPv4, and `/inet6/' to force IPv6.  Plain `/inet/' (which
     used to be the only option) uses the system default, most likely
     IPv4.

PROTOCOL
     The protocol to use over IP.  This must be either `tcp', or `udp',
     for a TCP or UDP IP connection, respectively.  The use of TCP is
     recommended for most applications.

LOCAL-PORT
     The local TCP or UDP port number to use.  Use a port number of `0'
     when you want the system to pick a port. This is what you should do
     when writing a TCP or UDP client.  You may also use a well-known
     service name, such as `smtp' or `http', in which case `gawk'
     attempts to determine the predefined port number using the C
     `getaddrinfo()' function.

REMOTE-HOST
     The IP address or fully-qualified domain name of the Internet host
     to which you want to connect.

REMOTE-PORT
     The TCP or UDP port number to use on the given REMOTE-HOST.
     Again, use `0' if you don't care, or else a well-known service
     name.

     NOTE: Failure in opening a two-way socket will result in a
     non-fatal error being returned to the calling code. The value of
     `ERRNO' indicates the error (*note Auto-set::).

   Consider the following very simple example:

     BEGIN {
       Service = "/inet/tcp/0/localhost/daytime"
       Service |& getline
       print $0
       close(Service)
     }

   This program reads the current date and time from the local system's
TCP `daytime' server.  It then prints the results and closes the
connection.

   Because this topic is extensive, the use of `gawk' for TCP/IP
programming is documented separately.  See *note (General
Introduction)Top:: gawkinet, TCP/IP Internetworking with `gawk', for a
much more complete introduction and discussion, as well as extensive
examples.


File: gawk.info,  Node: Profiling,  Prev: TCP/IP Networking,  Up: Advanced Features

11.5 Profiling Your `awk' Programs
==================================

You may produce execution traces of your `awk' programs.  This is done
with a specially compiled version of `gawk', called `pgawk' ("profiling
`gawk'").

   `pgawk' is identical in every way to `gawk', except that when it has
finished running, it creates a profile of your program in a file named
`awkprof.out'.  Because it is profiling, it also executes up to 45%
slower than `gawk' normally does.

   As shown in the following example, the `--profile' option can be
used to change the name of the file where `pgawk' will write the
profile:

     pgawk --profile=myprog.prof -f myprog.awk data1 data2

In the above example, `pgawk' places the profile in `myprog.prof'
instead of in `awkprof.out'.

   Here is a sample session showing a simple `awk' program, its input
data, and the results from running `pgawk'.  First, the `awk' program:

     BEGIN { print "First BEGIN rule" }

     END { print "First END rule" }

     /foo/ {
         print "matched /foo/, gosh"
         for (i = 1; i <= 3; i++)
             sing()
     }

     {
         if (/foo/)
             print "if is true"
         else
             print "else is true"
     }

     BEGIN { print "Second BEGIN rule" }

     END { print "Second END rule" }

     function sing(    dummy)
     {
         print "I gotta be me!"
     }

   Following is the input data:

     foo
     bar
     baz
     foo
     junk

   Here is the `awkprof.out' that results from running `pgawk' on this
program and data (this example also illustrates that `awk' programmers
sometimes have to work late):

             # gawk profile, created Sun Aug 13 00:00:15 2000

             # BEGIN block(s)

             BEGIN {
          1          print "First BEGIN rule"
          1          print "Second BEGIN rule"
             }

             # Rule(s)

          5  /foo/   { # 2
          2          print "matched /foo/, gosh"
          6          for (i = 1; i <= 3; i++) {
          6                  sing()
                     }
             }

          5  {
          5          if (/foo/) { # 2
          2                  print "if is true"
          3          } else {
          3                  print "else is true"
                     }
             }

             # END block(s)

             END {
          1          print "First END rule"
          1          print "Second END rule"
             }

             # Functions, listed alphabetically

          6  function sing(dummy)
             {
          6          print "I gotta be me!"
             }

   This example illustrates many of the basic features of profiling
output.  They are as follows:

   * The program is printed in the order `BEGIN' rule, `BEGINFILE' rule,
     pattern/action rules, `ENDFILE' rule, `END' rule and functions,
     listed alphabetically.  Multiple `BEGIN' and `END' rules are
     merged together, as are multiple `BEGINFILE' and `ENDFILE' rules.

   * Pattern-action rules have two counts.  The first count, to the
     left of the rule, shows how many times the rule's pattern was
     _tested_.  The second count, to the right of the rule's opening
     left brace in a comment, shows how many times the rule's action
     was _executed_.  The difference between the two indicates how many
     times the rule's pattern evaluated to false.

   * Similarly, the count for an `if'-`else' statement shows how many
     times the condition was tested.  To the right of the opening left
     brace for the `if''s body is a count showing how many times the
     condition was true.  The count for the `else' indicates how many
     times the test failed.

   * The count for a loop header (such as `for' or `while') shows how
     many times the loop test was executed.  (Because of this, you
     can't just look at the count on the first statement in a rule to
     determine how many times the rule was executed.  If the first
     statement is a loop, the count is misleading.)

   * For user-defined functions, the count next to the `function'
     keyword indicates how many times the function was called.  The
     counts next to the statements in the body show how many times
     those statements were executed.

   * The layout uses "K&R" style with TABs.  Braces are used
     everywhere, even when the body of an `if', `else', or loop is only
     a single statement.

   * Parentheses are used only where needed, as indicated by the
     structure of the program and the precedence rules.  For example,
     `(3 + 5) * 4' means add three plus five, then multiply the total
     by four.  However, `3 + 5 * 4' has no parentheses, and means `3 +
     (5 * 4)'.

   * Parentheses are used around the arguments to `print' and `printf'
     only when the `print' or `printf' statement is followed by a
     redirection.  Similarly, if the target of a redirection isn't a
     scalar, it gets parenthesized.

   * `pgawk' supplies leading comments in front of the `BEGIN' and
     `END' rules, the pattern/action rules, and the functions.


   The profiled version of your program may not look exactly like what
you typed when you wrote it.  This is because `pgawk' creates the
profiled version by "pretty printing" its internal representation of
the program.  The advantage to this is that `pgawk' can produce a
standard representation.  The disadvantage is that all source-code
comments are lost, as are the distinctions among multiple `BEGIN',
`END', `BEGINFILE', and `ENDFILE' rules.  Also, things such as:

     /foo/

come out as:

     /foo/   {
         print $0
     }

which is correct, but possibly surprising.

   Besides creating profiles when a program has completed, `pgawk' can
produce a profile while it is running.  This is useful if your `awk'
program goes into an infinite loop and you want to see what has been
executed.  To use this feature, run `pgawk' in the background:

     $ pgawk -f myprog &
     [1] 13992

The shell prints a job number and process ID number; in this case,
13992.  Use the `kill' command to send the `USR1' signal to `pgawk':

     $ kill -USR1 13992

As usual, the profiled version of the program is written to
`awkprof.out', or to a different file if you use the `--profile' option.

   Along with the regular profile, as shown earlier, the profile
includes a trace of any active functions:

     # Function Call Stack:

     #   3. baz
     #   2. bar
     #   1. foo
     # -- main --

   You may send `pgawk' the `USR1' signal as many times as you like.
Each time, the profile and function call trace are appended to the
output profile file.

   If you use the `HUP' signal instead of the `USR1' signal, `pgawk'
produces the profile and the function call trace and then exits.

   When `pgawk' runs on MS-Windows systems, it uses the `INT' and
`QUIT' signals for producing the profile and, in the case of the `INT'
signal, `pgawk' exits.  This is because these systems don't support the
`kill' command, so the only signals you can deliver to a program are
those generated by the keyboard.  The `INT' signal is generated by the
`Ctrl-<C>' or `Ctrl-<BREAK>' key, while the `QUIT' signal is generated
by the `Ctrl-<\>' key.

   Finally, regular `gawk' also accepts the `--profile' option.  When
called this way, `gawk' "pretty prints" the program into `awkprof.out',
without any execution counts.


File: gawk.info,  Node: Library Functions,  Next: Sample Programs,  Prev: Advanced Features,  Up: Top

12 A Library of `awk' Functions
*******************************

*note User-defined::, describes how to write your own `awk' functions.
Writing functions is important, because it allows you to encapsulate
algorithms and program tasks in a single place.  It simplifies
programming, making program development more manageable, and making
programs more readable.

   One valuable way to learn a new programming language is to _read_
programs in that language.  To that end, this major node and *note
Sample Programs::, provide a good-sized body of code for you to read,
and hopefully, to learn from.

   This major node presents a library of useful `awk' functions.  Many
of the sample programs presented later in this Info file use these
functions.  The functions are presented here in a progression from
simple to complex.

   *note Extract Program::, presents a program that you can use to
extract the source code for these example library functions and
programs from the Texinfo source for this Info file.  (This has already
been done as part of the `gawk' distribution.)

   If you have written one or more useful, general-purpose `awk'
functions and would like to contribute them to the `awk' user
community, see *note How To Contribute::, for more information.

   The programs in this major node and in *note Sample Programs::,
freely use features that are `gawk'-specific.  Rewriting these programs
for different implementations of `awk' is pretty straightforward.

   * Diagnostic error messages are sent to `/dev/stderr'.  Use `| "cat
     1>&2"' instead of `> "/dev/stderr"' if your system does not have a
     `/dev/stderr', or if you cannot use `gawk'.

   * A number of programs use `nextfile' (*note Nextfile Statement::)
     to skip any remaining input in the input file.

   * Finally, some of the programs choose to ignore upper- and lowercase
     distinctions in their input. They do so by assigning one to
     `IGNORECASE'.  You can achieve almost the same effect(1) by adding
     the following rule to the beginning of the program:

          # ignore case
          { $0 = tolower($0) }

     Also, verify that all regexp and string constants used in
     comparisons use only lowercase letters.

* Menu:

* Library Names::               How to best name private global variables in
                                library functions.
* General Functions::           Functions that are of general use.
* Data File Management::        Functions for managing command-line data
                                files.
* Getopt Function::             A function for processing command-line
                                arguments.
* Passwd Functions::            Functions for getting user information.
* Group Functions::             Functions for getting group information.
* Walking Arrays::              A function to walk arrays of arrays.

   ---------- Footnotes ----------

   (1) The effects are not identical.  Output of the transformed record
will be in all lowercase, while `IGNORECASE' preserves the original
contents of the input record.


File: gawk.info,  Node: Library Names,  Next: General Functions,  Up: Library Functions

12.1 Naming Library Function Global Variables
=============================================

Due to the way the `awk' language evolved, variables are either
"global" (usable by the entire program) or "local" (usable just by a
specific function).  There is no intermediate state analogous to
`static' variables in C.

   Library functions often need to have global variables that they can
use to preserve state information between calls to the function--for
example, `getopt()''s variable `_opti' (*note Getopt Function::).  Such
variables are called "private", since the only functions that need to
use them are the ones in the library.

   When writing a library function, you should try to choose names for
your private variables that will not conflict with any variables used by
either another library function or a user's main program.  For example,
a name like `i' or `j' is not a good choice, because user programs
often use variable names like these for their own purposes.

   The example programs shown in this major node all start the names of
their private variables with an underscore (`_').  Users generally
don't use leading underscores in their variable names, so this
convention immediately decreases the chances that the variable name
will be accidentally shared with the user's program.

   In addition, several of the library functions use a prefix that helps
indicate what function or set of functions use the variables--for
example, `_pw_byname' in the user database routines (*note Passwd
Functions::).  This convention is recommended, since it even further
decreases the chance of inadvertent conflict among variable names.
Note that this convention is used equally well for variable names and
for private function names.(1)

   As a final note on variable naming, if a function makes global
variables available for use by a main program, it is a good convention
to start that variable's name with a capital letter--for example,
`getopt()''s `Opterr' and `Optind' variables (*note Getopt Function::).
The leading capital letter indicates that it is global, while the fact
that the variable name is not all capital letters indicates that the
variable is not one of `awk''s built-in variables, such as `FS'.

   It is also important that _all_ variables in library functions that
do not need to save state are, in fact, declared local.(2) If this is
not done, the variable could accidentally be used in the user's
program, leading to bugs that are very difficult to track down:

     function lib_func(x, y,    l1, l2)
     {
         ...
         USE VARIABLE some_var   # some_var should be local
         ...                     # but is not by oversight
     }

   A different convention, common in the Tcl community, is to use a
single associative array to hold the values needed by the library
function(s), or "package."  This significantly decreases the number of
actual global names in use.  For example, the functions described in
*note Passwd Functions::, might have used array elements
`PW_data["inited"]', `PW_data["total"]', `PW_data["count"]', and
`PW_data["awklib"]', instead of `_pw_inited', `_pw_awklib', `_pw_total',
and `_pw_count'.

   The conventions presented in this minor node are exactly that:
conventions. You are not required to write your programs this way--we
merely recommend that you do so.

   ---------- Footnotes ----------

   (1) While all the library routines could have been rewritten to use
this convention, this was not done, in order to show how our own `awk'
programming style has evolved and to provide some basis for this
discussion.

   (2) `gawk''s `--dump-variables' command-line option is useful for
verifying this.


File: gawk.info,  Node: General Functions,  Next: Data File Management,  Prev: Library Names,  Up: Library Functions

12.2 General Programming
========================

This minor node presents a number of functions that are of general
programming use.

* Menu:

* Strtonum Function::           A replacement for the built-in
                                `strtonum()' function.
* Assert Function::             A function for assertions in `awk'
                                programs.
* Round Function::              A function for rounding if `sprintf()'
                                does not do it correctly.
* Cliff Random Function::       The Cliff Random Number Generator.
* Ordinal Functions::           Functions for using characters as numbers and
                                vice versa.
* Join Function::               A function to join an array into a string.
* Gettimeofday Function::       A function to get formatted times.


File: gawk.info,  Node: Strtonum Function,  Next: Assert Function,  Up: General Functions

12.2.1 Converting Strings To Numbers
------------------------------------

The `strtonum()' function (*note String Functions::) is a `gawk'
extension.  The following function provides an implementation for other
versions of `awk':

     # mystrtonum --- convert string to number

     function mystrtonum(str,        ret, chars, n, i, k, c)
     {
         if (str ~ /^0[0-7]*$/) {
             # octal
             n = length(str)
             ret = 0
             for (i = 1; i <= n; i++) {
                 c = substr(str, i, 1)
                 if ((k = index("01234567", c)) > 0)
                     k-- # adjust for 1-basing in awk

                 ret = ret * 8 + k
             }
         } else if (str ~ /^0[xX][[:xdigit:]]+/) {
             # hexadecimal
             str = substr(str, 3)    # lop off leading 0x
             n = length(str)
             ret = 0
             for (i = 1; i <= n; i++) {
                 c = substr(str, i, 1)
                 c = tolower(c)
                 if ((k = index("0123456789", c)) > 0)
                     k-- # adjust for 1-basing in awk
                 else if ((k = index("abcdef", c)) > 0)
                     k += 9

                 ret = ret * 16 + k
             }
         } else if (str ~ \
       /^[-+]?([0-9]+([.][0-9]*([Ee][0-9]+)?)?|([.][0-9]+([Ee][-+]?[0-9]+)?))$/) {
             # decimal number, possibly floating point
             ret = str + 0
         } else
             ret = "NOT-A-NUMBER"

         return ret
     }

     # BEGIN {     # gawk test harness
     #     a[1] = "25"
     #     a[2] = ".31"
     #     a[3] = "0123"
     #     a[4] = "0xdeadBEEF"
     #     a[5] = "123.45"
     #     a[6] = "1.e3"
     #     a[7] = "1.32"
     #     a[7] = "1.32E2"
     #
     #     for (i = 1; i in a; i++)
     #         print a[i], strtonum(a[i]), mystrtonum(a[i])
     # }

   The function first looks for C-style octal numbers (base 8).  If the
input string matches a regular expression describing octal numbers,
then `mystrtonum()' loops through each character in the string.  It
sets `k' to the index in `"01234567"' of the current octal digit.
Since the return value is one-based, the `k--' adjusts `k' so it can be
used in computing the return value.

   Similar logic applies to the code that checks for and converts a
hexadecimal value, which starts with `0x' or `0X'.  The use of
`tolower()' simplifies the computation for finding the correct numeric
value for each hexadecimal digit.

   Finally, if the string matches the (rather complicated) regexp for a
regular decimal integer or floating-point number, the computation `ret
= str + 0' lets `awk' convert the value to a number.

   A commented-out test program is included, so that the function can
be tested with `gawk' and the results compared to the built-in
`strtonum()' function.

